"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateSuccessResponse = exports.prepareBodyForCurrencyRatesRequest = exports.verifyIncomingWebhookOrPanic = exports.parseWithoutVerificationWebhookWayforpayBody = exports.prepareSignedWebhookResponse = void 0;
const crypto = require("crypto");
const code_mapping_1 = require("./code-mapping");
const prepareSignedWebhookResponse = (merchantSecretKey) => (body) => {
    const answer = {
        orderReference: body.orderReference,
        status: 'accept',
        time: Date.now(),
        signature: '',
    };
    const forHash = [answer.orderReference, answer.status, answer.time].join(';');
    const hash = crypto.createHmac('md5', merchantSecretKey).update(forHash).digest('hex');
    answer.signature = hash;
    return answer;
};
exports.prepareSignedWebhookResponse = prepareSignedWebhookResponse;
const parseWithoutVerificationWebhookWayforpayBody = (body) => {
    if (typeof body !== 'object') {
        throw new Error('webhook payload should be object');
    }
    const entries = Object.entries(body);
    const firstEntry = entries[0];
    if (!firstEntry) {
        throw new Error('webhook payload first entry undefined');
    }
    const [mainRawBody, objRawProducts = {}] = firstEntry;
    const rawProducts = Object.keys(objRawProducts);
    const rawBody = mainRawBody + '[' + rawProducts + ']}';
    return JSON.parse(rawBody);
};
exports.parseWithoutVerificationWebhookWayforpayBody = parseWithoutVerificationWebhookWayforpayBody;
const verifyIncomingWebhookOrPanic = (merchantSecretKey) => (body) => {
    const forHash = [
        body.merchantAccount,
        body.orderReference,
        body.amount,
        body.currency,
        body.authCode,
        body.cardPan,
        body.transactionStatus,
        body.reasonCode,
    ].join(';');
    const expectedMerchantSignature = crypto
        .createHmac('md5', merchantSecretKey)
        .update(forHash)
        .digest('hex');
    if (expectedMerchantSignature !== body.merchantSignature) {
        throw new Error('Corrupted webhook received. Webhook signature is not authentic.');
    }
};
exports.verifyIncomingWebhookOrPanic = verifyIncomingWebhookOrPanic;
const prepareBodyForCurrencyRatesRequest = ({ merchantAccount, merchantSecretKey, }) => {
    const body = {
        transactionType: 'CURRENCY_RATES',
        merchantSignature: '',
        apiVersion: 1,
        orderDate: Math.floor(Date.now() / 1000),
        merchantAccount,
    };
    const forHash = [body.merchantAccount, body.orderDate].join(';');
    const hash = crypto.createHmac('md5', merchantSecretKey).update(forHash).digest('hex');
    body.merchantSignature = hash;
    return body;
};
exports.prepareBodyForCurrencyRatesRequest = prepareBodyForCurrencyRatesRequest;
const validateSuccessResponse = ({ reasonCode }) => {
    if (reasonCode !== code_mapping_1.SUCCESS_WFP_CODE) {
        const details = code_mapping_1.ErrorCodeMap.get(reasonCode);
        if (details) {
            throw details;
        }
        throw new Error(`Unknown error code from WFP: "${reasonCode}"`);
    }
};
exports.validateSuccessResponse = validateSuccessResponse;
//# sourceMappingURL=util.js.map