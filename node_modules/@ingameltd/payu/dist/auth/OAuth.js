"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OAuth = void 0;
const querystring_1 = __importDefault(require("querystring"));
const moment_1 = __importDefault(require("moment"));
const axios_1 = __importDefault(require("axios"));
const endpoints_1 = require("../endpoints");
const AuthenticationError_1 = require("../errors/AuthenticationError");
class OAuth {
    /**
     *Creates an instance of OAuth.
     * @param {AxiosInstance} client - configured axios client for proper backend
     * @param {number} clientId - client id
     * @param {string} clientSecret - client secret
     * @memberof OAuth
     */
    constructor(client, clientId, clientSecret) {
        this.client = client;
        this.clientId = clientId;
        this.clientSecret = clientSecret;
        // initialize the authenticater to have invalidated expiry date
        // so it will fetch new one on first try
        this.expiry = (0, moment_1.default)().subtract(1, "minute").toDate();
        this.accessToken = "";
    }
    _fetchAccessToken() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const data = {
                grant_type: "client_credentials",
                client_id: this.clientId,
                client_secret: this.clientSecret,
            };
            const config = {
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded",
                },
            };
            try {
                const response = yield this.client.post(endpoints_1.AuthorizeEndpoint, querystring_1.default.stringify(data), config);
                const auth = response.data;
                return auth;
            }
            catch (error) {
                this.accessToken = "";
                this.expiry = (0, moment_1.default)().subtract(1, "minute").toDate();
                const errors = error;
                if (axios_1.default.isAxiosError(errors)) {
                    const errResponse = (_a = errors === null || errors === void 0 ? void 0 : errors.response) === null || _a === void 0 ? void 0 : _a.data;
                    throw new AuthenticationError_1.AuthenticationError(errResponse.error, errResponse.error_description);
                }
                throw error;
            }
        });
    }
    /**
     * Get access token from PayU service
     *
     * @returns {Promise<string>} - access token
     * @throws {AuthenticationError}
     * @memberof Auth
     */
    getAccessToken() {
        return __awaiter(this, void 0, void 0, function* () {
            // valid token(valid for 99%)
            if ((0, moment_1.default)().isBefore(this.expiry, "seconds") && this.accessToken !== "") {
                return this.accessToken;
            }
            const token = yield this._fetchAccessToken();
            this.accessToken = token.access_token;
            this.expiry = (0, moment_1.default)().add(token.expires_in, "seconds").toDate();
            return this.accessToken;
        });
    }
}
exports.OAuth = OAuth;
//# sourceMappingURL=OAuth.js.map