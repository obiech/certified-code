"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PayU = void 0;
const crypto_1 = __importDefault(require("crypto"));
const axios_1 = __importDefault(require("axios"));
const OAuth_1 = require("./auth/OAuth");
const endpoints_1 = require("./endpoints");
const PayUError_1 = require("./errors/PayUError");
const ips_1 = require("./ips");
const axios_2 = __importDefault(require("axios"));
const SANDBOX_ENDPOINT = "https://secure.snd.payu.com";
const PRODUCTION_ENDPOINT = "https://secure.payu.com";
class PayU {
    /**
     * Creates an instance of PayU.
     * @param {number} clientId - client id for merchant
     * @param {string} clientSecret - client secret from panel
     * @param {number} merchantPosId - pos id from panel
     * @param {string} secondKey - second key from panel
     * @param {PayUOptions} [options={ sandbox: false }] - additional options
     * @memberof PayU
     */
    constructor(clientId, clientSecret, merchantPosId, secondKey, options = { sandbox: false }) {
        this.clientId = clientId;
        this.clientSecret = clientSecret;
        this.merchantPosId = merchantPosId;
        this.secondKey = secondKey;
        this.options = options;
        this.clientId = clientId;
        this.clientSecret = clientSecret;
        this.merchantPosId = merchantPosId;
        this.secondKey = secondKey;
        this.options = options;
        this.baseEndpoint = !this.options.sandbox
            ? PRODUCTION_ENDPOINT
            : SANDBOX_ENDPOINT;
        this.ips = !this.options.sandbox ? ips_1.ProductionIPs : ips_1.SandboxIPs;
        this.client = axios_1.default.create({ baseURL: this.baseEndpoint });
        this.oAuth = new OAuth_1.OAuth(this.client, this.clientId, this.clientSecret);
    }
    /**
     * Get access token
     *
     * @returns {Promise<string>}
     * @throws {AuthenticationError}
     * @memberof PayU
     */
    getAccessToken() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.oAuth.getAccessToken();
        });
    }
    /**
     * Create a new order
     *
     * @param {Order} order - order to be created
     * @returns {Promise<OrderCreateResponse>}
     * @throws {PayUError}
     * @memberof PayU
     */
    createOrder(order) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const token = yield this.oAuth.getAccessToken();
            const data = Object.assign(Object.assign({}, order), { merchantPosId: this.merchantPosId });
            const headers = {
                Authorization: `Bearer ${token}`,
            };
            try {
                const response = yield this.client.post(endpoints_1.OrderEndpoint, data, {
                    headers: headers,
                    maxRedirects: 0,
                    validateStatus: (status) => {
                        return status === 302;
                    },
                });
                return response.data;
            }
            catch (error) {
                const errors = error;
                if (axios_2.default.isAxiosError(errors)) {
                    const resp = (_a = errors === null || errors === void 0 ? void 0 : errors.response) === null || _a === void 0 ? void 0 : _a.data;
                    throw new PayUError_1.PayUError(resp.status.statusCode, resp.status.code || "", resp.status.codeLiteral, resp.status.statusDesc);
                }
                throw error;
            }
        });
    }
    /**
     * Captures an order from payU making it approved
     *
     * @param {string} orderId
     * @returns {Promise<OrderStatusResponse>}
     * @throws {PayUError}
     * @memberof PayU
     */
    captureOrder(orderId) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const token = yield this.oAuth.getAccessToken();
            const data = {
                orderId: orderId,
                orderStatus: "COMPLETED",
            };
            const headers = {
                Authorization: `Bearer ${token}`,
            };
            try {
                const response = yield this.client.put(`${endpoints_1.OrderEndpoint}/${orderId}/status`, data, {
                    headers: headers,
                });
                return response.data;
            }
            catch (error) {
                const errors = error;
                if (axios_2.default.isAxiosError(errors)) {
                    const resp = (_a = errors === null || errors === void 0 ? void 0 : errors.response) === null || _a === void 0 ? void 0 : _a.data;
                    throw new PayUError_1.PayUError(resp.status.statusCode, resp.status.code || "", resp.status.codeLiteral, resp.status.statusDesc);
                }
                throw error;
            }
        });
    }
    /**
     * Cancels a PayU order
     *
     * @param {string} orderId
     * @returns {Promise<OrderStatusResponse>}
     * @memberof PayU
     */
    cancelOrder(orderId) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const token = yield this.oAuth.getAccessToken();
            const headers = {
                Authorization: `Bearer ${token}`,
            };
            try {
                const response = yield this.client.delete(`${endpoints_1.OrderEndpoint}/${orderId}`, {
                    headers: headers,
                });
                return response.data;
            }
            catch (error) {
                const errors = error;
                if (axios_2.default.isAxiosError(errors)) {
                    const resp = (_a = errors === null || errors === void 0 ? void 0 : errors.response) === null || _a === void 0 ? void 0 : _a.data;
                    throw new PayUError_1.PayUError(resp.status.statusCode, resp.status.code || "", resp.status.codeLiteral, resp.status.statusDesc);
                }
                throw error;
            }
        });
    }
    /**
     * Refunds a PayU order
     *
     * @param {string} orderId - payu order id
     * @param {string} description - description for refund
     * @returns {Promise<OrderStatusResponse>}
     * @memberof PayU
     */
    refundOrder(orderId, description) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const token = yield this.oAuth.getAccessToken();
            const headers = {
                Authorization: `Bearer ${token}`,
            };
            try {
                const response = yield this.client.post(`${endpoints_1.OrderEndpoint}/${orderId}/refund`, {
                    refund: {
                        description,
                    },
                }, {
                    headers: headers,
                });
                return response.data;
            }
            catch (error) {
                const errors = error;
                if (axios_2.default.isAxiosError(errors)) {
                    const resp = (_a = errors === null || errors === void 0 ? void 0 : errors.response) === null || _a === void 0 ? void 0 : _a.data;
                    throw new PayUError_1.PayUError(resp.status.statusCode, resp.status.code || "", resp.status.codeLiteral, resp.status.statusDesc);
                }
                throw errors;
            }
        });
    }
    /**
     * Convert a key=value; list to json
     *
     * @private
     * @param {string} data - key value string
     * @returns {Record<string, string>}
     * @memberof PayU
     */
    parseHeaderToJson(data) {
        return data.split(";").reduce((acc, curr) => {
            if (curr) {
                const [key, val] = curr.split("=");
                acc[key] = val;
            }
            return acc;
        }, {});
    }
    /**
     * Verify notification result with signature
     *
     * @param {string} payuHeader - header string from **OpenPayu-Signature**
     * @param {string} jsonNotification - notification body as a string
     * @returns {boolean}
     * @memberof PayU
     */
    verifyNotification(payuHeader, jsonNotification) {
        const tokens = this.parseHeaderToJson(payuHeader);
        if (!tokens["signature"] ||
            tokens["signature"] === "" ||
            !tokens["algorithm"] ||
            tokens["algorithm"] === "") {
            return false;
        }
        const concatnated = jsonNotification + this.secondKey;
        const exceptedSignature = crypto_1.default
            .createHash("md5")
            .update(concatnated)
            .digest("hex");
        const incomingSignature = tokens["signature"];
        return exceptedSignature === incomingSignature;
    }
    /**
     * Validates the IP address with PayU servers
     *
     * @param {string} ip - ip address
     * @returns {boolean}
     * @memberof PayU
     */
    isIpValid(ip) {
        return this.ips.includes(ip);
    }
}
exports.PayU = PayU;
//# sourceMappingURL=PayU.js.map