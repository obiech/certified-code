"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createDependenciesIf = exports.createNodesFor = exports.getProjectGraph = void 0;
const devkit_1 = require("@nx/devkit");
const minimatch_1 = require("minimatch");
const utils_1 = require("./utils");
function getPackageInfosForNxProjects(pluginName, projectFilter, getPackageInfo, workspace) {
    const workspacePackageInfo = {
        projects: {},
        packages: {},
    };
    Object.entries(workspace.projects)
        .filter(([, project]) => projectFilter(project))
        .forEach(([projectName, project]) => {
        try {
            const pkgInfo = getPackageInfo(project);
            workspacePackageInfo.projects[project.root] = pkgInfo;
            workspacePackageInfo.packages[pkgInfo.packageId] = projectName;
        }
        catch (e) {
            if (process.env['NX_VERBOSE_LOGGING'] === 'true') {
                devkit_1.logger.warn(`[${pluginName}]: Failed to get package info for project '${projectName}'`);
                devkit_1.logger.warn(e);
            }
        }
    });
    return workspacePackageInfo;
}
function getDependenciesForProject(pluginName, filePath, sourceProjectName, workspace) {
    var _a, _b;
    if (process.env['NX_VERBOSE_LOGGING'] === 'true') {
        devkit_1.logger.debug(`[${pluginName}]: Getting dependencies for project '${sourceProjectName}'...`);
    }
    const dependencies = [];
    const sourceProjectRoot = (0, utils_1.getProjectRootFromFile)(filePath);
    const sourcePkgInfo = workspace.projects[sourceProjectRoot];
    (_a = sourcePkgInfo.dependencies) === null || _a === void 0 ? void 0 : _a.forEach((depPkgInfo) => {
        const targetProjectName = workspace.packages[depPkgInfo.packageId];
        if (targetProjectName) {
            dependencies.push({
                source: sourceProjectName,
                target: targetProjectName,
                type: devkit_1.DependencyType.static,
                sourceFile: (0, devkit_1.joinPathFragments)(sourceProjectRoot, sourcePkgInfo.packageFile),
            });
        }
    });
    (_b = sourcePkgInfo.modules) === null || _b === void 0 ? void 0 : _b.forEach((moduleId) => {
        const depProjectName = workspace.packages[moduleId];
        if (depProjectName) {
            dependencies.push({
                source: sourceProjectName,
                target: depProjectName,
                type: devkit_1.DependencyType.static,
                sourceFile: (0, devkit_1.joinPathFragments)(sourceProjectRoot, sourcePkgInfo.packageFile)
            });
        }
    });
    return dependencies;
}
// Project Graph V1
function getProjectGraph(pluginName, projectFilter, getPackageInfo, graph, ctx) {
    const builder = new devkit_1.ProjectGraphBuilder(graph);
    if (process.env['NX_VERBOSE_LOGGING'] === 'true') {
        devkit_1.logger.debug(`[${pluginName}]: Looking related projects inside the workspace...`);
    }
    let workspace = undefined;
    let dependencies = [];
    for (const source in ctx.filesToProcess) {
        const changed = ctx.filesToProcess[source];
        for (const file of changed) {
            // we only create the workspace map once and only if changed file is of interest
            workspace !== null && workspace !== void 0 ? workspace : (workspace = getPackageInfosForNxProjects(pluginName, projectFilter, getPackageInfo, ctx.projectsConfigurations));
            dependencies = dependencies.concat(getDependenciesForProject(pluginName, file.file, source, workspace));
        }
    }
    for (const dep of dependencies) {
        builder.addDependency(dep.source, dep.target, dep.type, dep.source);
    }
    return builder.getUpdatedProjectGraph();
}
exports.getProjectGraph = getProjectGraph;
// Project Graph V2
const createNodesFor = (projectFiles, projectFilter, pluginName) => [
    `**/{${projectFiles.join(',')}}`,
    (file, opt, context) => {
        if (!projectFilter({ root: (0, utils_1.getProjectRootFromFile)(file) })) {
            return {}; // back off if the file/project does not match the criteria
        }
        const { root, name } = (0, utils_1.getNameAndRoot)(file);
        return {
            projects: {
                [name]: {
                    name,
                    root,
                    tags: [`type:${pluginName.replace('@nxrocks/', '')}`],
                },
            },
        };
    }
];
exports.createNodesFor = createNodesFor;
const createDependenciesIf = (pluginName, projectFiles, projectFilter, getPackageInfo, ctx) => {
    if (process.env['NX_VERBOSE_LOGGING'] === 'true') {
        devkit_1.logger.debug(`[${pluginName}]: Looking related projects inside the workspace...`);
    }
    let workspace = undefined;
    let dependencies = [];
    const projectFilePattern = `**/{${projectFiles.join(',')}}`;
    for (const source in ctx.filesToProcess.projectFileMap) {
        const changed = ctx.filesToProcess.projectFileMap[source];
        for (const file of changed) {
            if ((0, minimatch_1.minimatch)(file.file, projectFilePattern)) {
                // we only create the workspace map once and only if changed file is of interest
                workspace !== null && workspace !== void 0 ? workspace : (workspace = getPackageInfosForNxProjects(pluginName, projectFilter, getPackageInfo, { projects: ctx.projects }));
                dependencies = dependencies.concat(getDependenciesForProject(pluginName, file.file, source, workspace));
            }
        }
    }
    dependencies.forEach(dep => (0, devkit_1.validateDependency)(dep, ctx));
    return dependencies;
};
exports.createDependenciesIf = createDependenciesIf;
//# sourceMappingURL=project-graph.js.map