{"ast":null,"code":"import { __read, __spreadArray } from \"tslib\";\nimport { groupBy, keys, map } from '@antv/util';\nimport { findLabelTextShape } from '../../util';\n/**\n * 对同一组(相同 xField )的 Label 进行排序：第一个、最后一个、其他...\n * @param geometry\n * @param labels\n */\nfunction sortLabels(geometry, labels) {\n  var yField = geometry.getXYFields()[1];\n  var result = [];\n  var sortedLabels = labels.sort(function (left, right) {\n    return left.get('data')[yField] - left.get('data')[yField];\n  });\n  if (sortedLabels.length > 0) {\n    result.push(sortedLabels.shift());\n  }\n  if (sortedLabels.length > 0) {\n    result.push(sortedLabels.pop());\n  }\n  result.push.apply(result, __spreadArray([], __read(sortedLabels), false));\n  return result;\n}\nfunction hasSome(dones, current, compare) {\n  return dones.some(function (done) {\n    return compare(done, current);\n  });\n}\n/**\n * 计算两个矩形之间的堆叠区域面积\n */\nfunction getOverlapArea(a, b, margin) {\n  if (margin === void 0) {\n    margin = 0;\n  }\n  var xOverlap = Math.max(0, Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin));\n  var yOverlap = Math.max(0, Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin));\n  return xOverlap * yOverlap;\n}\n/**\n * 判断新添加的 Label 是否和已存在的发生重叠\n * @param dones\n * @param current\n */\nfunction checkShapeOverlap(dones, current) {\n  return hasSome(dones, current, function (left, right) {\n    var leftText = findLabelTextShape(left);\n    var rightText = findLabelTextShape(right);\n    return getOverlapArea(leftText.getCanvasBBox(), rightText.getCanvasBBox(), 2) > 0;\n  });\n}\n/**\n * 适用于 point geometry 的数据标签位置自动调整布局方法\n * @param items\n * @param labels\n * @param shapes\n * @param region\n * @param cfg\n */\nexport function pointAdjustPosition(items, labels, shapes, region, cfg) {\n  var _a, _b;\n  if (shapes.length === 0) {\n    return;\n  }\n  var element = (_a = shapes[0]) === null || _a === void 0 ? void 0 : _a.get('element');\n  var geometry = element === null || element === void 0 ? void 0 : element.geometry;\n  if (!geometry || geometry.type !== 'point') {\n    return;\n  }\n  var _c = __read(geometry.getXYFields(), 2),\n    xField = _c[0],\n    yField = _c[1];\n  var groupedLabels = groupBy(labels, function (label) {\n    return label.get('data')[xField];\n  });\n  var dones = [];\n  var offset = cfg && cfg.offset || ((_b = items[0]) === null || _b === void 0 ? void 0 : _b.offset) || 12;\n  map(keys(groupedLabels).reverse(), function (xValue) {\n    var sortedCollections = sortLabels(geometry, groupedLabels[xValue]);\n    while (sortedCollections.length) {\n      var current = sortedCollections.shift();\n      var textShape = findLabelTextShape(current);\n      if (hasSome(dones, current, function (left, right) {\n        return left.get('data')[xField] === right.get('data')[xField] && left.get('data')[yField] === right.get('data')[yField];\n      })) {\n        // 重复位置，直接隐藏\n        textShape.set('visible', false);\n        continue;\n      }\n      var upFail = checkShapeOverlap(dones, current);\n      var downFail = false;\n      if (upFail) {\n        textShape.attr('y', textShape.attr('y') + 2 * offset);\n        downFail = checkShapeOverlap(dones, current);\n      }\n      if (downFail) {\n        textShape.set('visible', false);\n        continue;\n      }\n      dones.push(current);\n    }\n  });\n}","map":{"version":3,"names":["__read","__spreadArray","groupBy","keys","map","findLabelTextShape","sortLabels","geometry","labels","yField","getXYFields","result","sortedLabels","sort","left","right","get","length","push","shift","pop","apply","hasSome","dones","current","compare","some","done","getOverlapArea","a","b","margin","xOverlap","Math","max","min","x","width","yOverlap","y","height","checkShapeOverlap","leftText","rightText","getCanvasBBox","pointAdjustPosition","items","shapes","region","cfg","_a","_b","element","type","_c","xField","groupedLabels","label","offset","reverse","xValue","sortedCollections","textShape","set","upFail","downFail","attr"],"sources":["/Users/obiechina/Documents/ridy-flutter-full-taxi-solution 2/node_modules/@antv/g2/esm/geometry/label/layout/point/adjust-position.js"],"sourcesContent":["import { __read, __spreadArray } from \"tslib\";\nimport { groupBy, keys, map } from '@antv/util';\nimport { findLabelTextShape } from '../../util';\n/**\n * 对同一组(相同 xField )的 Label 进行排序：第一个、最后一个、其他...\n * @param geometry\n * @param labels\n */\nfunction sortLabels(geometry, labels) {\n    var yField = geometry.getXYFields()[1];\n    var result = [];\n    var sortedLabels = labels.sort(function (left, right) { return left.get('data')[yField] - left.get('data')[yField]; });\n    if (sortedLabels.length > 0) {\n        result.push(sortedLabels.shift());\n    }\n    if (sortedLabels.length > 0) {\n        result.push(sortedLabels.pop());\n    }\n    result.push.apply(result, __spreadArray([], __read(sortedLabels), false));\n    return result;\n}\nfunction hasSome(dones, current, compare) {\n    return dones.some(function (done) { return compare(done, current); });\n}\n/**\n * 计算两个矩形之间的堆叠区域面积\n */\nfunction getOverlapArea(a, b, margin) {\n    if (margin === void 0) { margin = 0; }\n    var xOverlap = Math.max(0, Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin));\n    var yOverlap = Math.max(0, Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin));\n    return xOverlap * yOverlap;\n}\n/**\n * 判断新添加的 Label 是否和已存在的发生重叠\n * @param dones\n * @param current\n */\nfunction checkShapeOverlap(dones, current) {\n    return hasSome(dones, current, function (left, right) {\n        var leftText = findLabelTextShape(left);\n        var rightText = findLabelTextShape(right);\n        return getOverlapArea(leftText.getCanvasBBox(), rightText.getCanvasBBox(), 2) > 0;\n    });\n}\n/**\n * 适用于 point geometry 的数据标签位置自动调整布局方法\n * @param items\n * @param labels\n * @param shapes\n * @param region\n * @param cfg\n */\nexport function pointAdjustPosition(items, labels, shapes, region, cfg) {\n    var _a, _b;\n    if (shapes.length === 0) {\n        return;\n    }\n    var element = (_a = shapes[0]) === null || _a === void 0 ? void 0 : _a.get('element');\n    var geometry = element === null || element === void 0 ? void 0 : element.geometry;\n    if (!geometry || geometry.type !== 'point') {\n        return;\n    }\n    var _c = __read(geometry.getXYFields(), 2), xField = _c[0], yField = _c[1];\n    var groupedLabels = groupBy(labels, function (label) { return label.get('data')[xField]; });\n    var dones = [];\n    var offset = (cfg && cfg.offset) || ((_b = items[0]) === null || _b === void 0 ? void 0 : _b.offset) || 12;\n    map(keys(groupedLabels).reverse(), function (xValue) {\n        var sortedCollections = sortLabels(geometry, groupedLabels[xValue]);\n        while (sortedCollections.length) {\n            var current = sortedCollections.shift();\n            var textShape = findLabelTextShape(current);\n            if (hasSome(dones, current, function (left, right) {\n                return left.get('data')[xField] === right.get('data')[xField] &&\n                    left.get('data')[yField] === right.get('data')[yField];\n            })) {\n                // 重复位置，直接隐藏\n                textShape.set('visible', false);\n                continue;\n            }\n            var upFail = checkShapeOverlap(dones, current);\n            var downFail = false;\n            if (upFail) {\n                textShape.attr('y', textShape.attr('y') + 2 * offset);\n                downFail = checkShapeOverlap(dones, current);\n            }\n            if (downFail) {\n                textShape.set('visible', false);\n                continue;\n            }\n            dones.push(current);\n        }\n    });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}