{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { vec2 } from '@antv/matrix-util';\nimport { each, isFunction, isNil, isNumberEqual, isObject } from '@antv/util';\nimport AxisBase from './base';\nimport * as OverlapUtil from './overlap';\nvar Line = /** @class */function (_super) {\n  __extends(Line, _super);\n  function Line() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  Line.prototype.getDefaultCfg = function () {\n    var cfg = _super.prototype.getDefaultCfg.call(this);\n    return __assign(__assign({}, cfg), {\n      type: 'line',\n      locationType: 'region',\n      /**\n       * 起始点, x, y\n       * @type {object}\n       */\n      start: null,\n      /**\n       * 结束点, x, y\n       * @type {object}\n       */\n      end: null\n    });\n  };\n  // 获取坐标轴线的 path\n  Line.prototype.getLinePath = function () {\n    var start = this.get('start');\n    var end = this.get('end');\n    var path = [];\n    path.push(['M', start.x, start.y]);\n    path.push(['L', end.x, end.y]);\n    return path;\n  };\n  // 重新计算 layout bbox，考虑到 line 不显示\n  Line.prototype.getInnerLayoutBBox = function () {\n    var start = this.get('start');\n    var end = this.get('end');\n    var bbox = _super.prototype.getInnerLayoutBBox.call(this);\n    var minX = Math.min(start.x, end.x, bbox.x);\n    var minY = Math.min(start.y, end.y, bbox.y);\n    var maxX = Math.max(start.x, end.x, bbox.maxX);\n    var maxY = Math.max(start.y, end.y, bbox.maxY);\n    return {\n      x: minX,\n      y: minY,\n      minX: minX,\n      minY: minY,\n      maxX: maxX,\n      maxY: maxY,\n      width: maxX - minX,\n      height: maxY - minY\n    };\n  };\n  Line.prototype.isVertical = function () {\n    var start = this.get('start');\n    var end = this.get('end');\n    return isNumberEqual(start.x, end.x);\n  };\n  Line.prototype.isHorizontal = function () {\n    var start = this.get('start');\n    var end = this.get('end');\n    return isNumberEqual(start.y, end.y);\n  };\n  Line.prototype.getTickPoint = function (tickValue) {\n    var self = this;\n    var start = self.get('start');\n    var end = self.get('end');\n    var regionX = end.x - start.x;\n    var regionY = end.y - start.y;\n    return {\n      x: start.x + regionX * tickValue,\n      y: start.y + regionY * tickValue\n    };\n  };\n  // 直线坐标轴下任一点的向量方向都相同\n  Line.prototype.getSideVector = function (offset) {\n    var axisVector = this.getAxisVector();\n    var normal = vec2.normalize([0, 0], axisVector);\n    var factor = this.get('verticalFactor');\n    var verticalVector = [normal[1], normal[0] * -1]; // 垂直方向，逆时针方向\n    return vec2.scale([0, 0], verticalVector, offset * factor);\n  };\n  // 获取坐标轴的向量\n  Line.prototype.getAxisVector = function () {\n    var start = this.get('start');\n    var end = this.get('end');\n    return [end.x - start.x, end.y - start.y];\n  };\n  Line.prototype.processOverlap = function (labelGroup) {\n    var _this = this;\n    var isVertical = this.isVertical();\n    var isHorizontal = this.isHorizontal();\n    // 非垂直，或者非水平时不处理遮挡问题\n    if (!isVertical && !isHorizontal) {\n      return;\n    }\n    var labelCfg = this.get('label');\n    var titleCfg = this.get('title');\n    var verticalLimitLength = this.get('verticalLimitLength');\n    var labelOffset = labelCfg.offset;\n    var limitLength = verticalLimitLength;\n    var titleHeight = 0;\n    var titleSpacing = 0;\n    if (titleCfg) {\n      titleHeight = titleCfg.style.fontSize;\n      titleSpacing = titleCfg.spacing;\n    }\n    if (limitLength) {\n      limitLength = limitLength - labelOffset - titleSpacing - titleHeight;\n    }\n    var overlapOrder = this.get('overlapOrder');\n    each(overlapOrder, function (name) {\n      if (labelCfg[name] && _this.canProcessOverlap(name)) {\n        _this.autoProcessOverlap(name, labelCfg[name], labelGroup, limitLength);\n      }\n    });\n    if (titleCfg) {\n      if (isNil(titleCfg.offset)) {\n        // 调整 title 的 offset\n        var bbox = labelGroup.getCanvasBBox();\n        var length_1 = isVertical ? bbox.width : bbox.height;\n        // 如果用户没有设置 offset，则自动计算\n        titleCfg.offset = labelOffset + length_1 + titleSpacing + titleHeight / 2;\n      }\n    }\n  };\n  /**\n   * 是否可以执行某一 overlap\n   * @param name\n   */\n  Line.prototype.canProcessOverlap = function (name) {\n    var labelCfg = this.get('label');\n    // 对 autoRotate，如果配置了旋转角度，直接进行固定角度旋转\n    if (name === 'autoRotate') {\n      return isNil(labelCfg.rotate);\n    }\n    // 默认所有 overlap 都可执行\n    return true;\n  };\n  Line.prototype.autoProcessOverlap = function (name, value, labelGroup, limitLength) {\n    var _this = this;\n    var isVertical = this.isVertical();\n    var hasAdjusted = false;\n    var util = OverlapUtil[name];\n    if (value === true) {\n      var labelCfg = this.get('label');\n      // true 形式的配置：使用 overlap 默认的的处理方法进行处理\n      hasAdjusted = util.getDefault()(isVertical, labelGroup, limitLength);\n    } else if (isFunction(value)) {\n      // 回调函数形式的配置： 用户可以传入回调函数\n      hasAdjusted = value(isVertical, labelGroup, limitLength);\n    } else if (isObject(value)) {\n      // object 形式的配置方式：包括 处理方法 type， 和可选参数配置 cfg\n      var overlapCfg = value;\n      if (util[overlapCfg.type]) {\n        hasAdjusted = util[overlapCfg.type](isVertical, labelGroup, limitLength, overlapCfg.cfg);\n      }\n    } else if (util[value]) {\n      // 字符串类型的配置：按照名称执行 overlap 处理方法\n      hasAdjusted = util[value](isVertical, labelGroup, limitLength);\n    }\n    if (name === 'autoRotate') {\n      // 文本旋转后，文本的对齐方式可能就不合适了\n      if (hasAdjusted) {\n        var labels = labelGroup.getChildren();\n        var verticalFactor_1 = this.get('verticalFactor');\n        each(labels, function (label) {\n          var textAlign = label.attr('textAlign');\n          if (textAlign === 'center') {\n            // 居中的文本需要调整旋转度\n            var newAlign = verticalFactor_1 > 0 ? 'end' : 'start';\n            label.attr('textAlign', newAlign);\n          }\n        });\n      }\n    } else if (name === 'autoHide') {\n      var children = labelGroup.getChildren().slice(0); // 复制数组，删除时不会出错\n      each(children, function (label) {\n        if (!label.get('visible')) {\n          if (_this.get('isRegister')) {\n            // 已经注册过了，则删除\n            _this.unregisterElement(label);\n          }\n          label.remove(); // 防止 label 数量太多，所以统一删除\n        }\n      });\n    }\n  };\n\n  return Line;\n}(AxisBase);\nexport default Line;","map":{"version":3,"names":["__assign","__extends","vec2","each","isFunction","isNil","isNumberEqual","isObject","AxisBase","OverlapUtil","Line","_super","apply","arguments","prototype","getDefaultCfg","cfg","call","type","locationType","start","end","getLinePath","get","path","push","x","y","getInnerLayoutBBox","bbox","minX","Math","min","minY","maxX","max","maxY","width","height","isVertical","isHorizontal","getTickPoint","tickValue","self","regionX","regionY","getSideVector","offset","axisVector","getAxisVector","normal","normalize","factor","verticalVector","scale","processOverlap","labelGroup","_this","labelCfg","titleCfg","verticalLimitLength","labelOffset","limitLength","titleHeight","titleSpacing","style","fontSize","spacing","overlapOrder","name","canProcessOverlap","autoProcessOverlap","getCanvasBBox","length_1","rotate","value","hasAdjusted","util","getDefault","overlapCfg","labels","getChildren","verticalFactor_1","label","textAlign","attr","newAlign","children","slice","unregisterElement","remove"],"sources":["/Users/obiechina/Documents/ridy-flutter-full-taxi-solution 2/node_modules/@antv/component/esm/axis/line.js"],"sourcesContent":["import { __assign, __extends } from \"tslib\";\nimport { vec2 } from '@antv/matrix-util';\nimport { each, isFunction, isNil, isNumberEqual, isObject } from '@antv/util';\nimport AxisBase from './base';\nimport * as OverlapUtil from './overlap';\nvar Line = /** @class */ (function (_super) {\n    __extends(Line, _super);\n    function Line() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Line.prototype.getDefaultCfg = function () {\n        var cfg = _super.prototype.getDefaultCfg.call(this);\n        return __assign(__assign({}, cfg), { type: 'line', locationType: 'region', \n            /**\n             * 起始点, x, y\n             * @type {object}\n             */\n            start: null, \n            /**\n             * 结束点, x, y\n             * @type {object}\n             */\n            end: null });\n    };\n    // 获取坐标轴线的 path\n    Line.prototype.getLinePath = function () {\n        var start = this.get('start');\n        var end = this.get('end');\n        var path = [];\n        path.push(['M', start.x, start.y]);\n        path.push(['L', end.x, end.y]);\n        return path;\n    };\n    // 重新计算 layout bbox，考虑到 line 不显示\n    Line.prototype.getInnerLayoutBBox = function () {\n        var start = this.get('start');\n        var end = this.get('end');\n        var bbox = _super.prototype.getInnerLayoutBBox.call(this);\n        var minX = Math.min(start.x, end.x, bbox.x);\n        var minY = Math.min(start.y, end.y, bbox.y);\n        var maxX = Math.max(start.x, end.x, bbox.maxX);\n        var maxY = Math.max(start.y, end.y, bbox.maxY);\n        return {\n            x: minX,\n            y: minY,\n            minX: minX,\n            minY: minY,\n            maxX: maxX,\n            maxY: maxY,\n            width: maxX - minX,\n            height: maxY - minY,\n        };\n    };\n    Line.prototype.isVertical = function () {\n        var start = this.get('start');\n        var end = this.get('end');\n        return isNumberEqual(start.x, end.x);\n    };\n    Line.prototype.isHorizontal = function () {\n        var start = this.get('start');\n        var end = this.get('end');\n        return isNumberEqual(start.y, end.y);\n    };\n    Line.prototype.getTickPoint = function (tickValue) {\n        var self = this;\n        var start = self.get('start');\n        var end = self.get('end');\n        var regionX = end.x - start.x;\n        var regionY = end.y - start.y;\n        return {\n            x: start.x + regionX * tickValue,\n            y: start.y + regionY * tickValue,\n        };\n    };\n    // 直线坐标轴下任一点的向量方向都相同\n    Line.prototype.getSideVector = function (offset) {\n        var axisVector = this.getAxisVector();\n        var normal = vec2.normalize([0, 0], axisVector);\n        var factor = this.get('verticalFactor');\n        var verticalVector = [normal[1], normal[0] * -1]; // 垂直方向，逆时针方向\n        return vec2.scale([0, 0], verticalVector, offset * factor);\n    };\n    // 获取坐标轴的向量\n    Line.prototype.getAxisVector = function () {\n        var start = this.get('start');\n        var end = this.get('end');\n        return [end.x - start.x, end.y - start.y];\n    };\n    Line.prototype.processOverlap = function (labelGroup) {\n        var _this = this;\n        var isVertical = this.isVertical();\n        var isHorizontal = this.isHorizontal();\n        // 非垂直，或者非水平时不处理遮挡问题\n        if (!isVertical && !isHorizontal) {\n            return;\n        }\n        var labelCfg = this.get('label');\n        var titleCfg = this.get('title');\n        var verticalLimitLength = this.get('verticalLimitLength');\n        var labelOffset = labelCfg.offset;\n        var limitLength = verticalLimitLength;\n        var titleHeight = 0;\n        var titleSpacing = 0;\n        if (titleCfg) {\n            titleHeight = titleCfg.style.fontSize;\n            titleSpacing = titleCfg.spacing;\n        }\n        if (limitLength) {\n            limitLength = limitLength - labelOffset - titleSpacing - titleHeight;\n        }\n        var overlapOrder = this.get('overlapOrder');\n        each(overlapOrder, function (name) {\n            if (labelCfg[name] && _this.canProcessOverlap(name)) {\n                _this.autoProcessOverlap(name, labelCfg[name], labelGroup, limitLength);\n            }\n        });\n        if (titleCfg) {\n            if (isNil(titleCfg.offset)) {\n                // 调整 title 的 offset\n                var bbox = labelGroup.getCanvasBBox();\n                var length_1 = isVertical ? bbox.width : bbox.height;\n                // 如果用户没有设置 offset，则自动计算\n                titleCfg.offset = labelOffset + length_1 + titleSpacing + titleHeight / 2;\n            }\n        }\n    };\n    /**\n     * 是否可以执行某一 overlap\n     * @param name\n     */\n    Line.prototype.canProcessOverlap = function (name) {\n        var labelCfg = this.get('label');\n        // 对 autoRotate，如果配置了旋转角度，直接进行固定角度旋转\n        if (name === 'autoRotate') {\n            return isNil(labelCfg.rotate);\n        }\n        // 默认所有 overlap 都可执行\n        return true;\n    };\n    Line.prototype.autoProcessOverlap = function (name, value, labelGroup, limitLength) {\n        var _this = this;\n        var isVertical = this.isVertical();\n        var hasAdjusted = false;\n        var util = OverlapUtil[name];\n        if (value === true) {\n            var labelCfg = this.get('label');\n            // true 形式的配置：使用 overlap 默认的的处理方法进行处理\n            hasAdjusted = util.getDefault()(isVertical, labelGroup, limitLength);\n        }\n        else if (isFunction(value)) {\n            // 回调函数形式的配置： 用户可以传入回调函数\n            hasAdjusted = value(isVertical, labelGroup, limitLength);\n        }\n        else if (isObject(value)) {\n            // object 形式的配置方式：包括 处理方法 type， 和可选参数配置 cfg\n            var overlapCfg = value;\n            if (util[overlapCfg.type]) {\n                hasAdjusted = util[overlapCfg.type](isVertical, labelGroup, limitLength, overlapCfg.cfg);\n            }\n        }\n        else if (util[value]) {\n            // 字符串类型的配置：按照名称执行 overlap 处理方法\n            hasAdjusted = util[value](isVertical, labelGroup, limitLength);\n        }\n        if (name === 'autoRotate') {\n            // 文本旋转后，文本的对齐方式可能就不合适了\n            if (hasAdjusted) {\n                var labels = labelGroup.getChildren();\n                var verticalFactor_1 = this.get('verticalFactor');\n                each(labels, function (label) {\n                    var textAlign = label.attr('textAlign');\n                    if (textAlign === 'center') {\n                        // 居中的文本需要调整旋转度\n                        var newAlign = verticalFactor_1 > 0 ? 'end' : 'start';\n                        label.attr('textAlign', newAlign);\n                    }\n                });\n            }\n        }\n        else if (name === 'autoHide') {\n            var children = labelGroup.getChildren().slice(0); // 复制数组，删除时不会出错\n            each(children, function (label) {\n                if (!label.get('visible')) {\n                    if (_this.get('isRegister')) {\n                        // 已经注册过了，则删除\n                        _this.unregisterElement(label);\n                    }\n                    label.remove(); // 防止 label 数量太多，所以统一删除\n                }\n            });\n        }\n    };\n    return Line;\n}(AxisBase));\nexport default Line;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}