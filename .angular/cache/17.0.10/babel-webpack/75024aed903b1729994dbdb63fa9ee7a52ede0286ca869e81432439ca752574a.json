{"ast":null,"code":"import { __read, __spreadArray } from \"tslib\";\nfunction dot(a, b) {\n  return (a[0] || 0) * (b[0] || 0) + (a[1] || 0) * (b[1] || 0) + (a[2] || 0) * (b[2] || 0);\n}\n/**\n * @private\n * 1. 获取投影轴\n */\nfunction getAxes(points /** 多边形的关键点 */) {\n  // 目前先处理 平行矩形 的场景, 其他多边形不处理\n  if (points.length > 4) {\n    return [];\n  }\n  // 获取向量\n  var vector = function (start, end) {\n    return [end.x - start.x, end.y - start.y];\n  };\n  // 由于 矩形的平行原理，所以只有 2 条投影轴: A -> B, B -> C\n  var AB = vector(points[0], points[1]);\n  var BC = vector(points[1], points[2]);\n  return [AB, BC];\n}\n/**\n * @private\n * 绕指定点顺时针旋转后的点坐标\n * 默认绕原点旋转\n */\nfunction rotateAtPoint(point, deg, origin) {\n  if (deg === void 0) {\n    deg = 0;\n  }\n  if (origin === void 0) {\n    origin = {\n      x: 0,\n      y: 0\n    };\n  }\n  var x = point.x,\n    y = point.y;\n  return {\n    x: (x - origin.x) * Math.cos(-deg) + (y - origin.y) * Math.sin(-deg) + origin.x,\n    y: (origin.x - x) * Math.sin(-deg) + (y - origin.y) * Math.cos(-deg) + origin.y\n  };\n}\n/**\n * @private\n * 转化为顶点坐标数组\n *\n * @param {Object} box\n */\nfunction getRectPoints(box) {\n  var points = [{\n    x: box.x,\n    y: box.y\n  }, {\n    x: box.x + box.width,\n    y: box.y\n  }, {\n    x: box.x + box.width,\n    y: box.y + box.height\n  }, {\n    x: box.x,\n    y: box.y + box.height\n  }];\n  var rotation = box.rotation;\n  if (rotation) {\n    return [rotateAtPoint(points[0], rotation, points[0]), rotateAtPoint(points[1], rotation, points[0]), rotateAtPoint(points[2], rotation, points[0]), rotateAtPoint(points[3], rotation, points[0])];\n  }\n  return points;\n}\n/**\n * @private\n * 2. 获取多边形在投影轴上的投影\n *\n * 向量的点积的其中一个几何含义是：一个向量在平行于另一个向量方向上的投影的数值乘积。\n * 由于投影轴是单位向量（长度为1），投影的长度为 x1 * x2 + y1 * y2\n */\nfunction getProjection(points /** 多边形的关键点 */, axis) {\n  // 目前先处理矩形的场景\n  if (points.length > 4) {\n    return {\n      min: 0,\n      max: 0\n    };\n  }\n  var scalars = [];\n  points.forEach(function (point) {\n    scalars.push(dot([point.x, point.y], axis));\n  });\n  return {\n    min: Math.min.apply(Math, __spreadArray([], __read(scalars), false)),\n    max: Math.max.apply(Math, __spreadArray([], __read(scalars), false))\n  };\n}\nfunction isProjectionOverlap(projection1, projection2) {\n  return projection1.max > projection2.min && projection1.min < projection2.max;\n}\nfunction isValidNumber(d) {\n  return typeof d === 'number' && !Number.isNaN(d) && d !== Infinity && d !== -Infinity;\n}\nfunction isValidBox(box) {\n  return ['x', 'y', 'width', 'height'].every(function (attr) {\n    return isValidNumber(box[attr]);\n  });\n}\n/**\n * 快速判断两个无旋转矩形是否遮挡\n */\nexport function isIntersectRect(box1, box2, margin) {\n  if (margin === void 0) {\n    margin = 0;\n  }\n  return !(box2.x > box1.x + box1.width + margin || box2.x + box2.width < box1.x - margin || box2.y > box1.y + box1.height + margin || box2.y + box2.height < box1.y - margin);\n}\n/**\n * detect whether two shape is intersected, useful when shape is been rotated\n * 判断两个矩形是否重叠（相交和包含, 是否旋转）\n *\n * - 原理: 分离轴定律\n */\nexport function intersect(box1, box2, margin) {\n  if (margin === void 0) {\n    margin = 0;\n  }\n  // 如果两个 box 中有一个是不合法的 box，也就是不会被渲染出来的，那么它们就不相交。\n  if (!isValidBox(box1) || !isValidBox(box2)) return false;\n  // 如果两个矩形没有旋转，使用快速判断\n  if (!box1.rotation && !box2.rotation) {\n    return isIntersectRect(box1, box2, margin);\n  }\n  // 分别获取 4 个关键点\n  var rect1Points = getRectPoints(box1);\n  var rect2Points = getRectPoints(box2);\n  // 获取所有投影轴\n  var axes = getAxes(rect1Points).concat(getAxes(rect2Points));\n  for (var i = 0; i < axes.length; i++) {\n    var axis = axes[i];\n    var projection1 = getProjection(rect1Points, axis);\n    var projection2 = getProjection(rect2Points, axis);\n    // 判断投影轴上的投影是否存在重叠，若检测到存在间隙则立刻退出判断，消除不必要的运算。\n    if (!isProjectionOverlap(projection1, projection2)) {\n      return false;\n    }\n  }\n  return true;\n}","map":{"version":3,"names":["__read","__spreadArray","dot","a","b","getAxes","points","length","vector","start","end","x","y","AB","BC","rotateAtPoint","point","deg","origin","Math","cos","sin","getRectPoints","box","width","height","rotation","getProjection","axis","min","max","scalars","forEach","push","apply","isProjectionOverlap","projection1","projection2","isValidNumber","d","Number","isNaN","Infinity","isValidBox","every","attr","isIntersectRect","box1","box2","margin","intersect","rect1Points","rect2Points","axes","concat","i"],"sources":["/Users/obiechina/Documents/ridy-flutter-full-taxi-solution 2/node_modules/@antv/g2/esm/util/collision-detect.js"],"sourcesContent":["import { __read, __spreadArray } from \"tslib\";\nfunction dot(a, b) {\n    return (a[0] || 0) * (b[0] || 0) + (a[1] || 0) * (b[1] || 0) + (a[2] || 0) * (b[2] || 0);\n}\n/**\n * @private\n * 1. 获取投影轴\n */\nfunction getAxes(points /** 多边形的关键点 */) {\n    // 目前先处理 平行矩形 的场景, 其他多边形不处理\n    if (points.length > 4) {\n        return [];\n    }\n    // 获取向量\n    var vector = function (start, end) {\n        return [end.x - start.x, end.y - start.y];\n    };\n    // 由于 矩形的平行原理，所以只有 2 条投影轴: A -> B, B -> C\n    var AB = vector(points[0], points[1]);\n    var BC = vector(points[1], points[2]);\n    return [AB, BC];\n}\n/**\n * @private\n * 绕指定点顺时针旋转后的点坐标\n * 默认绕原点旋转\n */\nfunction rotateAtPoint(point, deg, origin) {\n    if (deg === void 0) { deg = 0; }\n    if (origin === void 0) { origin = { x: 0, y: 0 }; }\n    var x = point.x, y = point.y;\n    return {\n        x: (x - origin.x) * Math.cos(-deg) + (y - origin.y) * Math.sin(-deg) + origin.x,\n        y: (origin.x - x) * Math.sin(-deg) + (y - origin.y) * Math.cos(-deg) + origin.y,\n    };\n}\n/**\n * @private\n * 转化为顶点坐标数组\n *\n * @param {Object} box\n */\nfunction getRectPoints(box) {\n    var points = [\n        { x: box.x, y: box.y },\n        { x: box.x + box.width, y: box.y },\n        { x: box.x + box.width, y: box.y + box.height },\n        { x: box.x, y: box.y + box.height },\n    ];\n    var rotation = box.rotation;\n    if (rotation) {\n        return [\n            rotateAtPoint(points[0], rotation, points[0]),\n            rotateAtPoint(points[1], rotation, points[0]),\n            rotateAtPoint(points[2], rotation, points[0]),\n            rotateAtPoint(points[3], rotation, points[0]),\n        ];\n    }\n    return points;\n}\n/**\n * @private\n * 2. 获取多边形在投影轴上的投影\n *\n * 向量的点积的其中一个几何含义是：一个向量在平行于另一个向量方向上的投影的数值乘积。\n * 由于投影轴是单位向量（长度为1），投影的长度为 x1 * x2 + y1 * y2\n */\nfunction getProjection(points /** 多边形的关键点 */, axis) {\n    // 目前先处理矩形的场景\n    if (points.length > 4) {\n        return { min: 0, max: 0 };\n    }\n    var scalars = [];\n    points.forEach(function (point) {\n        scalars.push(dot([point.x, point.y], axis));\n    });\n    return { min: Math.min.apply(Math, __spreadArray([], __read(scalars), false)), max: Math.max.apply(Math, __spreadArray([], __read(scalars), false)) };\n}\nfunction isProjectionOverlap(projection1, projection2) {\n    return projection1.max > projection2.min && projection1.min < projection2.max;\n}\nfunction isValidNumber(d) {\n    return typeof d === 'number' && !Number.isNaN(d) && d !== Infinity && d !== -Infinity;\n}\nfunction isValidBox(box) {\n    return ['x', 'y', 'width', 'height'].every(function (attr) { return isValidNumber(box[attr]); });\n}\n/**\n * 快速判断两个无旋转矩形是否遮挡\n */\nexport function isIntersectRect(box1, box2, margin) {\n    if (margin === void 0) { margin = 0; }\n    return !(box2.x > box1.x + box1.width + margin ||\n        box2.x + box2.width < box1.x - margin ||\n        box2.y > box1.y + box1.height + margin ||\n        box2.y + box2.height < box1.y - margin);\n}\n/**\n * detect whether two shape is intersected, useful when shape is been rotated\n * 判断两个矩形是否重叠（相交和包含, 是否旋转）\n *\n * - 原理: 分离轴定律\n */\nexport function intersect(box1, box2, margin) {\n    if (margin === void 0) { margin = 0; }\n    // 如果两个 box 中有一个是不合法的 box，也就是不会被渲染出来的，那么它们就不相交。\n    if (!isValidBox(box1) || !isValidBox(box2))\n        return false;\n    // 如果两个矩形没有旋转，使用快速判断\n    if (!box1.rotation && !box2.rotation) {\n        return isIntersectRect(box1, box2, margin);\n    }\n    // 分别获取 4 个关键点\n    var rect1Points = getRectPoints(box1);\n    var rect2Points = getRectPoints(box2);\n    // 获取所有投影轴\n    var axes = getAxes(rect1Points).concat(getAxes(rect2Points));\n    for (var i = 0; i < axes.length; i++) {\n        var axis = axes[i];\n        var projection1 = getProjection(rect1Points, axis);\n        var projection2 = getProjection(rect2Points, axis);\n        // 判断投影轴上的投影是否存在重叠，若检测到存在间隙则立刻退出判断，消除不必要的运算。\n        if (!isProjectionOverlap(projection1, projection2)) {\n            return false;\n        }\n    }\n    return true;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}