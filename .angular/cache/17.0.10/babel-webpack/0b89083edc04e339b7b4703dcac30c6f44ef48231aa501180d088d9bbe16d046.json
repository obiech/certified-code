{"ast":null,"code":"import { getMaxLabelWidth } from '../../util/label';\nimport { getAngleByMatrix } from '../../util/matrix';\nimport { near } from '../../util/util';\n// 文本是否旋转\nfunction isRotate(label) {\n  var matrix = label.attr('matrix');\n  return matrix && matrix[0] !== 1; // 仅在这个场景下判定\n}\n\nfunction getRotateAngle(label) {\n  var angle = isRotate(label) ? getAngleByMatrix(label.attr('matrix')) : 0;\n  return angle % 360;\n}\n// autohide 不再考虑超出限制\n// function isOutLimit(isVertical: boolean, label: IElement, limitLength: number) {\n//   if (!limitLength) {\n//     // 如果没限制 limitLength 则直接返回 false\n//     return false;\n//   }\n//   const canvasBBox = label.getCanvasBBox();\n//   let isOut = false;\n//   if (isVertical) {\n//     isOut = canvasBBox.width > limitLength;\n//   } else {\n//     isOut = canvasBBox.height > limitLength;\n//   }\n//   return isOut;\n// }\n// 是否重叠\nfunction isOverlap(isVertical, first, second, minGap) {\n  var overlap = false;\n  var angle = getRotateAngle(first);\n  var distance = isVertical ? Math.abs(second.attr('y') - first.attr('y')) : Math.abs(second.attr('x') - first.attr('x'));\n  var prevBBox = (isVertical ? second.attr('y') > first.attr('y') : second.attr('x') > first.attr('x')) ? first.getBBox() : second.getBBox();\n  if (isVertical) {\n    var ratio = Math.abs(Math.cos(angle));\n    if (near(ratio, 0, Math.PI / 180)) {\n      overlap = prevBBox.width + minGap > distance;\n    } else {\n      overlap = prevBBox.height / ratio + minGap > distance;\n    }\n  } else {\n    var ratio = Math.abs(Math.sin(angle));\n    if (near(ratio, 0, Math.PI / 180)) {\n      overlap = prevBBox.width + minGap > distance;\n    } else {\n      overlap = prevBBox.height / ratio + minGap > distance;\n    }\n  }\n  return overlap;\n}\n// 保留第一个或者最后一个\nfunction reserveOne(isVertical, labelsGroup, reversed, autoHideCfg) {\n  var minGap = (autoHideCfg === null || autoHideCfg === void 0 ? void 0 : autoHideCfg.minGap) || 0;\n  var labels = labelsGroup.getChildren().slice() // 复制数组\n  .filter(function (item) {\n    return item.get('visible');\n  });\n  if (!labels.length) {\n    return false;\n  }\n  var hasHide = false;\n  if (reversed) {\n    // 翻转\n    labels.reverse();\n  }\n  var count = labels.length;\n  var first = labels[0];\n  var prev = first;\n  for (var i = 1; i < count; i++) {\n    var label = labels[i];\n    var curBBox = label.getBBox();\n    // 不再考虑超出限制，而仅仅根据是否重叠进行隐藏 isOutLimit(isVertical, label, limitLength) ||\n    var isHide = isOverlap(isVertical, prev, label, minGap);\n    if (isHide) {\n      label.hide();\n      hasHide = true;\n    } else {\n      prev = label;\n    }\n  }\n  return hasHide;\n}\n// 均匀抽样隐藏标签，注意这里假设 label/tick 是均匀的\nfunction parityHide(isVertical, labelsGroup, autoHideCfg) {\n  var minGap = (autoHideCfg === null || autoHideCfg === void 0 ? void 0 : autoHideCfg.minGap) || 0;\n  var labels = labelsGroup.getChildren().slice(); // 复制数组\n  if (labels.length < 2) {\n    // 如果数量小于 2 则直接返回，等于 2 时可能也会重合\n    return false;\n  }\n  var hasHide = false;\n  var first = labels[0];\n  var firstBBox = first.getBBox();\n  var second = labels[1];\n  var count = labels.length;\n  var angle = getRotateAngle(first);\n  var distance = isVertical ? Math.abs(second.attr('y') - first.attr('y')) : Math.abs(second.attr('x') - first.attr('x'));\n  var interval = 0; // 不重叠的坐标文本间距个数\n  if (isVertical) {\n    // 垂直的坐标轴计算垂直方向的间距\n    var ratio = Math.abs(Math.cos(angle));\n    if (near(ratio, 0, Math.PI / 180)) {\n      var maxWidth = getMaxLabelWidth(labels);\n      interval = (maxWidth + minGap) / distance;\n    } else {\n      interval = (firstBBox.height / ratio + minGap) / distance;\n    }\n  } else {\n    // 水平坐标轴\n    var ratio = Math.abs(Math.sin(angle));\n    if (near(ratio, 0, Math.PI / 180)) {\n      var maxWidth = getMaxLabelWidth(labels);\n      interval = (maxWidth + minGap) / distance;\n    } else {\n      interval = (firstBBox.height / ratio + minGap) / distance;\n    }\n  }\n  // interval > 1 时需要对 label 进行隐藏\n  if (interval > 1) {\n    interval = Math.ceil(interval);\n    for (var i = 0; i < count; i++) {\n      if (i % interval !== 0) {\n        // 仅保留被整除的 label\n        labels[i].hide();\n        hasHide = true;\n      }\n    }\n  }\n  return hasHide;\n}\nexport function getDefault() {\n  return equidistance;\n}\n/**\n * 保证首个 label 可见，即使超过 limitLength 也不隐藏\n * @param {boolean} isVertical  是否垂直\n * @param {IGroup}  labelsGroup label 的分组\n * @param {number} limitLength 另一个方向的长度限制，autoHide 不关心\n * @param {AxisLabelAutoHideCfg} autoHideCfg autoHide overlap 的可选配置参数\n */\nexport function reserveFirst(isVertical, labelsGroup, limitLength, autoHideCfg) {\n  return reserveOne(isVertical, labelsGroup, false, autoHideCfg);\n}\n/**\n * 保证最后一个 label 可见，即使超过 limitLength 也不隐藏\n * @param {boolean} isVertical  是否垂直\n * @param {IGroup}  labelsGroup label 的分组\n * @param {number} limitLength 另一个方向的长度限制，autoHide 不关心\n * @param {AxisLabelAutoHideCfg} autoHideCfg autoHide overlap 的可选配置参数\n */\nexport function reserveLast(isVertical, labelsGroup, limitLength, autoHideCfg) {\n  return reserveOne(isVertical, labelsGroup, true, autoHideCfg);\n}\n/**\n * 保证第一个最后一个 label 可见，即使超过 limitLength 也不隐藏\n * @param {boolean} isVertical  是否垂直\n * @param {IGroup}  labelsGroup label 的分组\n * @param {number} limitLength 另一个方向的长度限制，autoHide 不关心\n * @param {AxisLabelAutoHideCfg} autoHideCfg autoHide overlap 的可选配置参数\n */\nexport function reserveBoth(isVertical, labelsGroup, limitLength, autoHideCfg) {\n  var minGap = (autoHideCfg === null || autoHideCfg === void 0 ? void 0 : autoHideCfg.minGap) || 0;\n  var labels = labelsGroup.getChildren().slice(); // 复制数组\n  if (labels.length <= 2) {\n    // 如果数量小于或等于 2 则直接返回\n    return false;\n  }\n  var hasHide = false;\n  var count = labels.length;\n  var first = labels[0];\n  var last = labels[count - 1];\n  var preLabel = first;\n  // 按照先保存第一个的逻辑循环一遍，最后一个不参与循环\n  for (var i = 1; i < count - 1; i++) {\n    var label = labels[i];\n    var curBBox = label.getBBox();\n    // 废弃 isOutLimit(isVertical, label, limitLength) ||\n    var isHide = isOverlap(isVertical, preLabel, label, minGap);\n    if (isHide) {\n      label.hide();\n      hasHide = true;\n    } else {\n      preLabel = label;\n    }\n  }\n  var overlap = isOverlap(isVertical, preLabel, last, minGap);\n  if (overlap) {\n    // 发生冲突，则隐藏前一个保留后一个\n    preLabel.hide();\n    hasHide = true;\n  }\n  return hasHide;\n}\n/**\n * 保证 label 均匀显示 和 不出现重叠，主要解决文本层叠的问题，对于 limitLength 不处理\n * @param {boolean} isVertical  是否垂直\n * @param {IGroup}  labelsGroup label 的分组\n * @param {number} limitLength 另一个方向的长度限制，autoHide 不关心\n * @param {AxisLabelAutoHideCfg} autoHideCfg autoHide overlap 的可选配置参数\n */\nexport function equidistance(isVertical, labelsGroup, limitLength, autoHideCfg) {\n  var hasHide = parityHide(isVertical, labelsGroup, autoHideCfg);\n  // 处理  timeCat 类型的 tick，在均匀的基础上，再次检查出现重叠的进行隐藏\n  if (reserveOne(isVertical, labelsGroup, false)) {\n    hasHide = true;\n  }\n  return hasHide;\n}\n/**\n * 同 equidistance， 首先会保证 labels 均匀显示，然后会保留首尾\n * @param isVertical\n * @param labelsGroup\n * @param {number} limitLength 另一个方向的长度限制，autoHide 不关心\n * @param {AxisLabelAutoHideCfg} autoHideCfg autoHide overlap 的可选配置参数\n */\nexport function equidistanceWithReverseBoth(isVertical, labelsGroup, limitLength, autoHideCfg) {\n  var labels = labelsGroup.getChildren().slice(); // 复制数组\n  var hasHide = parityHide(isVertical, labelsGroup, autoHideCfg);\n  if (labels.length > 2) {\n    var first = labels[0];\n    var last = labels[labels.length - 1];\n    // 如果第一个被隐藏了\n    if (!first.get('visible')) {\n      first.show();\n      if (reserveOne(isVertical, labelsGroup, false, autoHideCfg)) {\n        hasHide = true;\n      }\n    }\n    // 如果最后一个被隐藏了\n    if (!last.get('visible')) {\n      last.show();\n      if (reserveOne(isVertical, labelsGroup, true, autoHideCfg)) {\n        hasHide = true;\n      }\n    }\n  }\n  return hasHide;\n}","map":{"version":3,"names":["getMaxLabelWidth","getAngleByMatrix","near","isRotate","label","matrix","attr","getRotateAngle","angle","isOverlap","isVertical","first","second","minGap","overlap","distance","Math","abs","prevBBox","getBBox","ratio","cos","PI","width","height","sin","reserveOne","labelsGroup","reversed","autoHideCfg","labels","getChildren","slice","filter","item","get","length","hasHide","reverse","count","prev","i","curBBox","isHide","hide","parityHide","firstBBox","interval","maxWidth","ceil","getDefault","equidistance","reserveFirst","limitLength","reserveLast","reserveBoth","last","preLabel","equidistanceWithReverseBoth","show"],"sources":["/Users/obiechina/Documents/ridy-flutter-full-taxi-solution 2/node_modules/@antv/component/esm/axis/overlap/auto-hide.js"],"sourcesContent":["import { getMaxLabelWidth } from '../../util/label';\nimport { getAngleByMatrix } from '../../util/matrix';\nimport { near } from '../../util/util';\n// 文本是否旋转\nfunction isRotate(label) {\n    var matrix = label.attr('matrix');\n    return matrix && matrix[0] !== 1; // 仅在这个场景下判定\n}\nfunction getRotateAngle(label) {\n    var angle = isRotate(label) ? getAngleByMatrix(label.attr('matrix')) : 0;\n    return angle % 360;\n}\n// autohide 不再考虑超出限制\n// function isOutLimit(isVertical: boolean, label: IElement, limitLength: number) {\n//   if (!limitLength) {\n//     // 如果没限制 limitLength 则直接返回 false\n//     return false;\n//   }\n//   const canvasBBox = label.getCanvasBBox();\n//   let isOut = false;\n//   if (isVertical) {\n//     isOut = canvasBBox.width > limitLength;\n//   } else {\n//     isOut = canvasBBox.height > limitLength;\n//   }\n//   return isOut;\n// }\n// 是否重叠\nfunction isOverlap(isVertical, first, second, minGap) {\n    var overlap = false;\n    var angle = getRotateAngle(first);\n    var distance = isVertical\n        ? Math.abs(second.attr('y') - first.attr('y'))\n        : Math.abs(second.attr('x') - first.attr('x'));\n    var prevBBox = (isVertical\n        ? second.attr('y') > first.attr('y')\n        : second.attr('x') > first.attr('x'))\n        ? first.getBBox()\n        : second.getBBox();\n    if (isVertical) {\n        var ratio = Math.abs(Math.cos(angle));\n        if (near(ratio, 0, Math.PI / 180)) {\n            overlap = prevBBox.width + minGap > distance;\n        }\n        else {\n            overlap = prevBBox.height / ratio + minGap > distance;\n        }\n    }\n    else {\n        var ratio = Math.abs(Math.sin(angle));\n        if (near(ratio, 0, Math.PI / 180)) {\n            overlap = prevBBox.width + minGap > distance;\n        }\n        else {\n            overlap = prevBBox.height / ratio + minGap > distance;\n        }\n    }\n    return overlap;\n}\n// 保留第一个或者最后一个\nfunction reserveOne(isVertical, labelsGroup, reversed, autoHideCfg) {\n    var minGap = (autoHideCfg === null || autoHideCfg === void 0 ? void 0 : autoHideCfg.minGap) || 0;\n    var labels = labelsGroup\n        .getChildren()\n        .slice() // 复制数组\n        .filter(function (item) { return item.get('visible'); });\n    if (!labels.length) {\n        return false;\n    }\n    var hasHide = false;\n    if (reversed) {\n        // 翻转\n        labels.reverse();\n    }\n    var count = labels.length;\n    var first = labels[0];\n    var prev = first;\n    for (var i = 1; i < count; i++) {\n        var label = labels[i];\n        var curBBox = label.getBBox();\n        // 不再考虑超出限制，而仅仅根据是否重叠进行隐藏 isOutLimit(isVertical, label, limitLength) ||\n        var isHide = isOverlap(isVertical, prev, label, minGap);\n        if (isHide) {\n            label.hide();\n            hasHide = true;\n        }\n        else {\n            prev = label;\n        }\n    }\n    return hasHide;\n}\n// 均匀抽样隐藏标签，注意这里假设 label/tick 是均匀的\nfunction parityHide(isVertical, labelsGroup, autoHideCfg) {\n    var minGap = (autoHideCfg === null || autoHideCfg === void 0 ? void 0 : autoHideCfg.minGap) || 0;\n    var labels = labelsGroup.getChildren().slice(); // 复制数组\n    if (labels.length < 2) {\n        // 如果数量小于 2 则直接返回，等于 2 时可能也会重合\n        return false;\n    }\n    var hasHide = false;\n    var first = labels[0];\n    var firstBBox = first.getBBox();\n    var second = labels[1];\n    var count = labels.length;\n    var angle = getRotateAngle(first);\n    var distance = isVertical\n        ? Math.abs(second.attr('y') - first.attr('y'))\n        : Math.abs(second.attr('x') - first.attr('x'));\n    var interval = 0; // 不重叠的坐标文本间距个数\n    if (isVertical) {\n        // 垂直的坐标轴计算垂直方向的间距\n        var ratio = Math.abs(Math.cos(angle));\n        if (near(ratio, 0, Math.PI / 180)) {\n            var maxWidth = getMaxLabelWidth(labels);\n            interval = (maxWidth + minGap) / distance;\n        }\n        else {\n            interval = (firstBBox.height / ratio + minGap) / distance;\n        }\n    }\n    else {\n        // 水平坐标轴\n        var ratio = Math.abs(Math.sin(angle));\n        if (near(ratio, 0, Math.PI / 180)) {\n            var maxWidth = getMaxLabelWidth(labels);\n            interval = (maxWidth + minGap) / distance;\n        }\n        else {\n            interval = (firstBBox.height / ratio + minGap) / distance;\n        }\n    }\n    // interval > 1 时需要对 label 进行隐藏\n    if (interval > 1) {\n        interval = Math.ceil(interval);\n        for (var i = 0; i < count; i++) {\n            if (i % interval !== 0) {\n                // 仅保留被整除的 label\n                labels[i].hide();\n                hasHide = true;\n            }\n        }\n    }\n    return hasHide;\n}\nexport function getDefault() {\n    return equidistance;\n}\n/**\n * 保证首个 label 可见，即使超过 limitLength 也不隐藏\n * @param {boolean} isVertical  是否垂直\n * @param {IGroup}  labelsGroup label 的分组\n * @param {number} limitLength 另一个方向的长度限制，autoHide 不关心\n * @param {AxisLabelAutoHideCfg} autoHideCfg autoHide overlap 的可选配置参数\n */\nexport function reserveFirst(isVertical, labelsGroup, limitLength, autoHideCfg) {\n    return reserveOne(isVertical, labelsGroup, false, autoHideCfg);\n}\n/**\n * 保证最后一个 label 可见，即使超过 limitLength 也不隐藏\n * @param {boolean} isVertical  是否垂直\n * @param {IGroup}  labelsGroup label 的分组\n * @param {number} limitLength 另一个方向的长度限制，autoHide 不关心\n * @param {AxisLabelAutoHideCfg} autoHideCfg autoHide overlap 的可选配置参数\n */\nexport function reserveLast(isVertical, labelsGroup, limitLength, autoHideCfg) {\n    return reserveOne(isVertical, labelsGroup, true, autoHideCfg);\n}\n/**\n * 保证第一个最后一个 label 可见，即使超过 limitLength 也不隐藏\n * @param {boolean} isVertical  是否垂直\n * @param {IGroup}  labelsGroup label 的分组\n * @param {number} limitLength 另一个方向的长度限制，autoHide 不关心\n * @param {AxisLabelAutoHideCfg} autoHideCfg autoHide overlap 的可选配置参数\n */\nexport function reserveBoth(isVertical, labelsGroup, limitLength, autoHideCfg) {\n    var minGap = (autoHideCfg === null || autoHideCfg === void 0 ? void 0 : autoHideCfg.minGap) || 0;\n    var labels = labelsGroup.getChildren().slice(); // 复制数组\n    if (labels.length <= 2) {\n        // 如果数量小于或等于 2 则直接返回\n        return false;\n    }\n    var hasHide = false;\n    var count = labels.length;\n    var first = labels[0];\n    var last = labels[count - 1];\n    var preLabel = first;\n    // 按照先保存第一个的逻辑循环一遍，最后一个不参与循环\n    for (var i = 1; i < count - 1; i++) {\n        var label = labels[i];\n        var curBBox = label.getBBox();\n        // 废弃 isOutLimit(isVertical, label, limitLength) ||\n        var isHide = isOverlap(isVertical, preLabel, label, minGap);\n        if (isHide) {\n            label.hide();\n            hasHide = true;\n        }\n        else {\n            preLabel = label;\n        }\n    }\n    var overlap = isOverlap(isVertical, preLabel, last, minGap);\n    if (overlap) {\n        // 发生冲突，则隐藏前一个保留后一个\n        preLabel.hide();\n        hasHide = true;\n    }\n    return hasHide;\n}\n/**\n * 保证 label 均匀显示 和 不出现重叠，主要解决文本层叠的问题，对于 limitLength 不处理\n * @param {boolean} isVertical  是否垂直\n * @param {IGroup}  labelsGroup label 的分组\n * @param {number} limitLength 另一个方向的长度限制，autoHide 不关心\n * @param {AxisLabelAutoHideCfg} autoHideCfg autoHide overlap 的可选配置参数\n */\nexport function equidistance(isVertical, labelsGroup, limitLength, autoHideCfg) {\n    var hasHide = parityHide(isVertical, labelsGroup, autoHideCfg);\n    // 处理  timeCat 类型的 tick，在均匀的基础上，再次检查出现重叠的进行隐藏\n    if (reserveOne(isVertical, labelsGroup, false)) {\n        hasHide = true;\n    }\n    return hasHide;\n}\n/**\n * 同 equidistance， 首先会保证 labels 均匀显示，然后会保留首尾\n * @param isVertical\n * @param labelsGroup\n * @param {number} limitLength 另一个方向的长度限制，autoHide 不关心\n * @param {AxisLabelAutoHideCfg} autoHideCfg autoHide overlap 的可选配置参数\n */\nexport function equidistanceWithReverseBoth(isVertical, labelsGroup, limitLength, autoHideCfg) {\n    var labels = labelsGroup.getChildren().slice(); // 复制数组\n    var hasHide = parityHide(isVertical, labelsGroup, autoHideCfg);\n    if (labels.length > 2) {\n        var first = labels[0];\n        var last = labels[labels.length - 1];\n        // 如果第一个被隐藏了\n        if (!first.get('visible')) {\n            first.show();\n            if (reserveOne(isVertical, labelsGroup, false, autoHideCfg)) {\n                hasHide = true;\n            }\n        }\n        // 如果最后一个被隐藏了\n        if (!last.get('visible')) {\n            last.show();\n            if (reserveOne(isVertical, labelsGroup, true, autoHideCfg)) {\n                hasHide = true;\n            }\n        }\n    }\n    return hasHide;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}