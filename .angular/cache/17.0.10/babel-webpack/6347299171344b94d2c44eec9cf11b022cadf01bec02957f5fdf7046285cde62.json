{"ast":null,"code":"/**\n * @fileoverview 事件处理器\n * @author dxq613@gmail.com\n */\nimport GraphEvent from './graph-event';\nimport { each, isParent } from '../util/util';\nvar CLICK_OFFSET = 40;\nvar LEFT_BTN_CODE = 0;\nvar DELEGATION_SPLIT = ':';\nvar EVENTS = ['mousedown', 'mouseup', 'dblclick', 'mouseout', 'mouseover', 'mousemove', 'mouseleave', 'mouseenter', 'touchstart', 'touchmove', 'touchend', 'dragenter', 'dragover', 'dragleave', 'drop', 'contextmenu', 'mousewheel'];\n// 是否有委托事件监听\nfunction hasDelegation(events, type) {\n  for (var key in events) {\n    if (events.hasOwnProperty(key) && key.indexOf(DELEGATION_SPLIT + type) >= 0) {\n      return true;\n    }\n  }\n  return false;\n}\n// 触发目标事件，目标只能是 shape 或 canvas\nfunction emitTargetEvent(target, type, eventObj) {\n  eventObj.name = type;\n  eventObj.target = target;\n  eventObj.currentTarget = target;\n  eventObj.delegateTarget = target;\n  target.emit(type, eventObj);\n}\n// 事件冒泡, enter 和 leave 需要对 fromShape 和 toShape 进行判同\nfunction bubbleEvent(container, type, eventObj) {\n  if (eventObj.bubbles) {\n    var relativeShape = void 0;\n    var isOverEvent = false;\n    if (type === 'mouseenter') {\n      relativeShape = eventObj.fromShape;\n      isOverEvent = true;\n    } else if (type === 'mouseleave') {\n      isOverEvent = true;\n      relativeShape = eventObj.toShape;\n    }\n    // canvas 上的 mouseenter， mouseleave 事件，仅当进入或者移出 canvas 时触发\n    if (container.isCanvas() && isOverEvent) {\n      return;\n    }\n    // 如果相关图形同当前图形在同一个容器内，不触发事件\n    if (relativeShape && isParent(container, relativeShape)) {\n      // 阻止继续向上冒泡\n      eventObj.bubbles = false;\n      return;\n    }\n    // 事件名称可能在委托过程中被修改，因此事件冒泡时需要重新设置事件名称\n    eventObj.name = type;\n    eventObj.currentTarget = container;\n    eventObj.delegateTarget = container;\n    container.emit(type, eventObj);\n  }\n}\nvar EventController = /** @class */function () {\n  function EventController(cfg) {\n    var _this = this;\n    // 正在被拖拽的图形\n    this.draggingShape = null;\n    this.dragging = false;\n    // 当前鼠标/touch所在位置的图形\n    this.currentShape = null;\n    this.mousedownShape = null;\n    this.mousedownPoint = null;\n    // 统一处理所有的回调\n    this._eventCallback = function (ev) {\n      var type = ev.type;\n      _this._triggerEvent(type, ev);\n    };\n    // 在 document 处理拖拽到画布外的事件，处理从图形上移除画布未被捕捉的问题\n    this._onDocumentMove = function (ev) {\n      var canvas = _this.canvas;\n      var el = canvas.get('el');\n      if (el !== ev.target) {\n        // 不在 canvas 上移动\n        if (_this.dragging || _this.currentShape) {\n          var pointInfo = _this._getPointInfo(ev);\n          // 还在拖拽过程中\n          if (_this.dragging) {\n            _this._emitEvent('drag', ev, pointInfo, _this.draggingShape);\n          }\n          // 说明从某个图形直接移动到了画布外面，\n          // 修复了 mouseleave 的 bug 后不再出现这种情况\n          // if (this.currentShape) {\n          //   this._emitEvent('mouseleave', ev, pointInfo, this.currentShape, this.currentShape, null);\n          //   this.currentShape = null;\n          // }\n        }\n      }\n    };\n    // 在 document 上处理拖拽到外面，释放鼠标时触发 dragend\n    this._onDocumentMouseUp = function (ev) {\n      var canvas = _this.canvas;\n      var el = canvas.get('el');\n      if (el !== ev.target) {\n        // 不在 canvas 上移动\n        if (_this.dragging) {\n          var pointInfo = _this._getPointInfo(ev);\n          if (_this.draggingShape) {\n            // 如果存在拖拽的图形，则也触发 drop 事件\n            _this._emitEvent('drop', ev, pointInfo, null);\n          }\n          _this._emitEvent('dragend', ev, pointInfo, _this.draggingShape);\n          _this._afterDrag(_this.draggingShape, pointInfo, ev);\n        }\n      }\n    };\n    this.canvas = cfg.canvas;\n  }\n  EventController.prototype.init = function () {\n    this._bindEvents();\n  };\n  // 注册事件\n  EventController.prototype._bindEvents = function () {\n    var _this = this;\n    var el = this.canvas.get('el');\n    each(EVENTS, function (eventName) {\n      el.addEventListener(eventName, _this._eventCallback);\n    });\n    if (document) {\n      // 处理移动到外面没有触发 shape mouse leave 的事件\n      // 处理拖拽到外部的问题\n      document.addEventListener('mousemove', this._onDocumentMove);\n      // 处理拖拽过程中在外部释放鼠标的问题\n      document.addEventListener('mouseup', this._onDocumentMouseUp);\n    }\n  };\n  // 清理事件\n  EventController.prototype._clearEvents = function () {\n    var _this = this;\n    var el = this.canvas.get('el');\n    each(EVENTS, function (eventName) {\n      el.removeEventListener(eventName, _this._eventCallback);\n    });\n    if (document) {\n      document.removeEventListener('mousemove', this._onDocumentMove);\n      document.removeEventListener('mouseup', this._onDocumentMouseUp);\n    }\n  };\n  EventController.prototype._getEventObj = function (type, event, point, target, fromShape, toShape) {\n    var eventObj = new GraphEvent(type, event);\n    eventObj.fromShape = fromShape;\n    eventObj.toShape = toShape;\n    eventObj.x = point.x;\n    eventObj.y = point.y;\n    eventObj.clientX = point.clientX;\n    eventObj.clientY = point.clientY;\n    eventObj.propagationPath.push(target);\n    // 事件的x,y应该是基于画布左上角的，与canvas的matrix无关\n    return eventObj;\n  };\n  // 根据点获取图形，提取成独立方法，便于后续优化\n  EventController.prototype._getShape = function (point, ev) {\n    return this.canvas.getShape(point.x, point.y, ev);\n  };\n  // 获取事件的当前点的信息\n  EventController.prototype._getPointInfo = function (ev) {\n    var canvas = this.canvas;\n    var clientPoint = canvas.getClientByEvent(ev);\n    var point = canvas.getPointByEvent(ev);\n    return {\n      x: point.x,\n      y: point.y,\n      clientX: clientPoint.x,\n      clientY: clientPoint.y\n    };\n  };\n  // 触发事件\n  EventController.prototype._triggerEvent = function (type, ev) {\n    var pointInfo = this._getPointInfo(ev);\n    // 每次都获取图形有一定成本，后期可以考虑进行缓存策略\n    var shape = this._getShape(pointInfo, ev);\n    var method = this[\"_on\" + type];\n    var leaveCanvas = false;\n    if (method) {\n      method.call(this, pointInfo, shape, ev);\n    } else {\n      var preShape = this.currentShape;\n      // 如果进入、移出画布时存在图形，则要分别触发事件\n      if (type === 'mouseenter' || type === 'dragenter' || type === 'mouseover') {\n        this._emitEvent(type, ev, pointInfo, null, null, shape); // 先进入画布\n        if (shape) {\n          this._emitEvent(type, ev, pointInfo, shape, null, shape); // 再触发图形的事件\n        }\n\n        if (type === 'mouseenter' && this.draggingShape) {\n          // 如果正在拖拽图形, 则触发 dragleave\n          this._emitEvent('dragenter', ev, pointInfo, null);\n        }\n      } else if (type === 'mouseleave' || type === 'dragleave' || type === 'mouseout') {\n        leaveCanvas = true;\n        if (preShape) {\n          this._emitEvent(type, ev, pointInfo, preShape, preShape, null); // 先触发图形的事件\n        }\n\n        this._emitEvent(type, ev, pointInfo, null, preShape, null); // 再触发离开画布事件\n        if (type === 'mouseleave' && this.draggingShape) {\n          this._emitEvent('dragleave', ev, pointInfo, null);\n        }\n      } else {\n        this._emitEvent(type, ev, pointInfo, shape, null, null); // 一般事件中不需要考虑 from, to\n      }\n    }\n\n    if (!leaveCanvas) {\n      this.currentShape = shape;\n    }\n    // 当鼠标从画布移动到 shape 或者从 preShape 移动到 shape 时，应用 shape 上的鼠标样式\n    if (shape && !shape.get('destroyed')) {\n      var canvas = this.canvas;\n      var el = canvas.get('el');\n      el.style.cursor = shape.attr('cursor') || canvas.get('cursor');\n    }\n  };\n  // 记录下点击的位置、图形，便于拖拽事件、click 事件的判定\n  EventController.prototype._onmousedown = function (pointInfo, shape, event) {\n    // 只有鼠标左键的 mousedown 事件才会设置 mousedownShape 等属性，避免鼠标右键的 mousedown 事件引起其他事件发生\n    if (event.button === LEFT_BTN_CODE) {\n      this.mousedownShape = shape;\n      this.mousedownPoint = pointInfo;\n      this.mousedownTimeStamp = event.timeStamp;\n    }\n    this._emitEvent('mousedown', event, pointInfo, shape, null, null); // mousedown 不考虑fromShape, toShape\n  };\n  // mouseleave 和 mouseenter 都是成对存在的\n  // mouseenter 和 mouseover 同时触发\n  EventController.prototype._emitMouseoverEvents = function (event, pointInfo, fromShape, toShape) {\n    var el = this.canvas.get('el');\n    if (fromShape !== toShape) {\n      if (fromShape) {\n        this._emitEvent('mouseout', event, pointInfo, fromShape, fromShape, toShape);\n        this._emitEvent('mouseleave', event, pointInfo, fromShape, fromShape, toShape);\n        // 当鼠标从 fromShape 移动到画布上时，重置鼠标样式\n        if (!toShape || toShape.get('destroyed')) {\n          el.style.cursor = this.canvas.get('cursor');\n        }\n      }\n      if (toShape) {\n        this._emitEvent('mouseover', event, pointInfo, toShape, fromShape, toShape);\n        this._emitEvent('mouseenter', event, pointInfo, toShape, fromShape, toShape);\n      }\n    }\n  };\n  // dragover 不等同于 mouseover，而等同于 mousemove\n  EventController.prototype._emitDragoverEvents = function (event, pointInfo, fromShape, toShape, isCanvasEmit) {\n    if (toShape) {\n      if (toShape !== fromShape) {\n        if (fromShape) {\n          this._emitEvent('dragleave', event, pointInfo, fromShape, fromShape, toShape);\n        }\n        this._emitEvent('dragenter', event, pointInfo, toShape, fromShape, toShape);\n      }\n      if (!isCanvasEmit) {\n        this._emitEvent('dragover', event, pointInfo, toShape);\n      }\n    } else if (fromShape) {\n      // TODO: 此处判断有问题，当 drag 图形时，也会触发一次 dragleave 事件，因为此时 toShape 为 null，这不是所期望的\n      // 经过空白区域\n      this._emitEvent('dragleave', event, pointInfo, fromShape, fromShape, toShape);\n    }\n    if (isCanvasEmit) {\n      this._emitEvent('dragover', event, pointInfo, toShape);\n    }\n  };\n  // drag 完成后，需要做一些清理工作\n  EventController.prototype._afterDrag = function (draggingShape, pointInfo, event) {\n    if (draggingShape) {\n      draggingShape.set('capture', true); // 恢复可以拾取\n      this.draggingShape = null;\n    }\n    this.dragging = false;\n    // drag 完成后，有可能 draggingShape 已经移动到了当前位置，所以不能直接取当前图形\n    var shape = this._getShape(pointInfo, event);\n    // 拖拽完成后，进行 enter，leave 的判定\n    if (shape !== draggingShape) {\n      this._emitMouseoverEvents(event, pointInfo, draggingShape, shape);\n    }\n    this.currentShape = shape; // 更新当前 shape，如果不处理当前图形的 mouseleave 事件可能会出问题\n  };\n  // 按键抬起时，会终止拖拽、触发点击\n  EventController.prototype._onmouseup = function (pointInfo, shape, event) {\n    // eevent.button === 0 表示鼠标左键事件，此处加上判断主要是为了避免右键鼠标会触发 mouseup 和 click 事件\n    // ref: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n    if (event.button === LEFT_BTN_CODE) {\n      var draggingShape = this.draggingShape;\n      if (this.dragging) {\n        // 存在可以拖拽的图形，同时拖拽到其他图形上时触发 drag 事件\n        if (draggingShape) {\n          this._emitEvent('drop', event, pointInfo, shape);\n        }\n        this._emitEvent('dragend', event, pointInfo, draggingShape);\n        this._afterDrag(draggingShape, pointInfo, event);\n      } else {\n        this._emitEvent('mouseup', event, pointInfo, shape); // 先触发 mouseup 再触发 click\n        if (shape === this.mousedownShape) {\n          this._emitEvent('click', event, pointInfo, shape);\n        }\n        this.mousedownShape = null;\n        this.mousedownPoint = null;\n      }\n    }\n  };\n  // 当触发浏览器的 dragover 事件时，不会再触发 mousemove ，所以这时候的 dragenter, dragleave 事件需要重新处理\n  EventController.prototype._ondragover = function (pointInfo, shape, event) {\n    event.preventDefault(); // 如果不对 dragover 进行 preventDefault，则不会在 canvas 上触发 drop 事件\n    var preShape = this.currentShape;\n    this._emitDragoverEvents(event, pointInfo, preShape, shape, true);\n  };\n  // 大量的图形事件，都通过 mousemove 模拟\n  EventController.prototype._onmousemove = function (pointInfo, shape, event) {\n    var canvas = this.canvas;\n    var preShape = this.currentShape;\n    var draggingShape = this.draggingShape;\n    // 正在拖拽时\n    if (this.dragging) {\n      // 正在拖拽中\n      if (draggingShape) {\n        // 如果拖拽了 shape 会触发 dragenter, dragleave, dragover 和 drag 事件\n        this._emitDragoverEvents(event, pointInfo, preShape, shape, false);\n      }\n      // 如果存在 draggingShape 则会在 draggingShape 上触发 drag 事件，冒泡到 canvas 上\n      // 否则在 canvas 上触发 drag 事件\n      this._emitEvent('drag', event, pointInfo, draggingShape);\n    } else {\n      var mousedownPoint = this.mousedownPoint;\n      if (mousedownPoint) {\n        // 当鼠标点击下去，同时移动时，进行 drag 判定\n        var mousedownShape = this.mousedownShape;\n        var now = event.timeStamp;\n        var timeWindow = now - this.mousedownTimeStamp;\n        var dx = mousedownPoint.clientX - pointInfo.clientX;\n        var dy = mousedownPoint.clientY - pointInfo.clientY;\n        var dist = dx * dx + dy * dy;\n        if (timeWindow > 120 || dist > CLICK_OFFSET) {\n          if (mousedownShape && mousedownShape.get('draggable')) {\n            // 设置了 draggable 的 shape 才能触发 drag 相关的事件\n            draggingShape = this.mousedownShape; // 拖动鼠标点下时的 shape\n            draggingShape.set('capture', false); // 禁止继续拾取，否则无法进行 dragover,dragenter,dragleave,drop的判定\n            this.draggingShape = draggingShape;\n            this.dragging = true;\n            this._emitEvent('dragstart', event, pointInfo, draggingShape);\n            // 清理按下鼠标时缓存的值\n            this.mousedownShape = null;\n            this.mousedownPoint = null;\n          } else if (!mousedownShape && canvas.get('draggable')) {\n            // 设置了 draggable 的 canvas 才能触发 drag 相关的事件\n            this.dragging = true;\n            this._emitEvent('dragstart', event, pointInfo, null);\n            // 清理按下鼠标时缓存的值\n            this.mousedownShape = null;\n            this.mousedownPoint = null;\n          } else {\n            this._emitMouseoverEvents(event, pointInfo, preShape, shape);\n            this._emitEvent('mousemove', event, pointInfo, shape);\n          }\n        } else {\n          this._emitMouseoverEvents(event, pointInfo, preShape, shape);\n          this._emitEvent('mousemove', event, pointInfo, shape);\n        }\n      } else {\n        // 没有按键按下时，则直接触发 mouse over 相关的各种事件\n        this._emitMouseoverEvents(event, pointInfo, preShape, shape);\n        // 始终触发移动\n        this._emitEvent('mousemove', event, pointInfo, shape);\n      }\n    }\n  };\n  // 触发事件\n  EventController.prototype._emitEvent = function (type, event, pointInfo, shape, fromShape, toShape) {\n    var eventObj = this._getEventObj(type, event, pointInfo, shape, fromShape, toShape);\n    // 存在 shape 触发，则进行冒泡处理\n    if (shape) {\n      eventObj.shape = shape;\n      // 触发 shape 上的事件\n      emitTargetEvent(shape, type, eventObj);\n      var parent_1 = shape.getParent();\n      // 执行冒泡\n      while (parent_1) {\n        // 委托事件要先触发\n        parent_1.emitDelegation(type, eventObj);\n        // 事件冒泡停止，不能妨碍委托事件\n        if (!eventObj.propagationStopped) {\n          bubbleEvent(parent_1, type, eventObj);\n        }\n        eventObj.propagationPath.push(parent_1);\n        parent_1 = parent_1.getParent();\n      }\n    } else {\n      // 如果没有 shape 直接在 canvas 上触发\n      var canvas = this.canvas;\n      // 直接触发 canvas 上的事件\n      emitTargetEvent(canvas, type, eventObj);\n    }\n  };\n  EventController.prototype.destroy = function () {\n    // 清理事件\n    this._clearEvents();\n    // 清理缓存的对象\n    this.canvas = null;\n    this.currentShape = null;\n    this.draggingShape = null;\n    this.mousedownPoint = null;\n    this.mousedownShape = null;\n    this.mousedownTimeStamp = null;\n  };\n  return EventController;\n}();\nexport default EventController;","map":{"version":3,"names":["GraphEvent","each","isParent","CLICK_OFFSET","LEFT_BTN_CODE","DELEGATION_SPLIT","EVENTS","hasDelegation","events","type","key","hasOwnProperty","indexOf","emitTargetEvent","target","eventObj","name","currentTarget","delegateTarget","emit","bubbleEvent","container","bubbles","relativeShape","isOverEvent","fromShape","toShape","isCanvas","EventController","cfg","_this","draggingShape","dragging","currentShape","mousedownShape","mousedownPoint","_eventCallback","ev","_triggerEvent","_onDocumentMove","canvas","el","get","pointInfo","_getPointInfo","_emitEvent","_onDocumentMouseUp","_afterDrag","prototype","init","_bindEvents","eventName","addEventListener","document","_clearEvents","removeEventListener","_getEventObj","event","point","x","y","clientX","clientY","propagationPath","push","_getShape","getShape","clientPoint","getClientByEvent","getPointByEvent","shape","method","leaveCanvas","call","preShape","style","cursor","attr","_onmousedown","button","mousedownTimeStamp","timeStamp","_emitMouseoverEvents","_emitDragoverEvents","isCanvasEmit","set","_onmouseup","_ondragover","preventDefault","_onmousemove","now","timeWindow","dx","dy","dist","parent_1","getParent","emitDelegation","propagationStopped","destroy"],"sources":["/Users/obiechina/Documents/ridy-flutter-full-taxi-solution 2/node_modules/@antv/g-base/esm/event/event-contoller.js"],"sourcesContent":["/**\n * @fileoverview 事件处理器\n * @author dxq613@gmail.com\n */\nimport GraphEvent from './graph-event';\nimport { each, isParent } from '../util/util';\nvar CLICK_OFFSET = 40;\nvar LEFT_BTN_CODE = 0;\nvar DELEGATION_SPLIT = ':';\nvar EVENTS = [\n    'mousedown',\n    'mouseup',\n    'dblclick',\n    'mouseout',\n    'mouseover',\n    'mousemove',\n    'mouseleave',\n    'mouseenter',\n    'touchstart',\n    'touchmove',\n    'touchend',\n    'dragenter',\n    'dragover',\n    'dragleave',\n    'drop',\n    'contextmenu',\n    'mousewheel',\n];\n// 是否有委托事件监听\nfunction hasDelegation(events, type) {\n    for (var key in events) {\n        if (events.hasOwnProperty(key) && key.indexOf(DELEGATION_SPLIT + type) >= 0) {\n            return true;\n        }\n    }\n    return false;\n}\n// 触发目标事件，目标只能是 shape 或 canvas\nfunction emitTargetEvent(target, type, eventObj) {\n    eventObj.name = type;\n    eventObj.target = target;\n    eventObj.currentTarget = target;\n    eventObj.delegateTarget = target;\n    target.emit(type, eventObj);\n}\n// 事件冒泡, enter 和 leave 需要对 fromShape 和 toShape 进行判同\nfunction bubbleEvent(container, type, eventObj) {\n    if (eventObj.bubbles) {\n        var relativeShape = void 0;\n        var isOverEvent = false;\n        if (type === 'mouseenter') {\n            relativeShape = eventObj.fromShape;\n            isOverEvent = true;\n        }\n        else if (type === 'mouseleave') {\n            isOverEvent = true;\n            relativeShape = eventObj.toShape;\n        }\n        // canvas 上的 mouseenter， mouseleave 事件，仅当进入或者移出 canvas 时触发\n        if (container.isCanvas() && isOverEvent) {\n            return;\n        }\n        // 如果相关图形同当前图形在同一个容器内，不触发事件\n        if (relativeShape && isParent(container, relativeShape)) {\n            // 阻止继续向上冒泡\n            eventObj.bubbles = false;\n            return;\n        }\n        // 事件名称可能在委托过程中被修改，因此事件冒泡时需要重新设置事件名称\n        eventObj.name = type;\n        eventObj.currentTarget = container;\n        eventObj.delegateTarget = container;\n        container.emit(type, eventObj);\n    }\n}\nvar EventController = /** @class */ (function () {\n    function EventController(cfg) {\n        var _this = this;\n        // 正在被拖拽的图形\n        this.draggingShape = null;\n        this.dragging = false;\n        // 当前鼠标/touch所在位置的图形\n        this.currentShape = null;\n        this.mousedownShape = null;\n        this.mousedownPoint = null;\n        // 统一处理所有的回调\n        this._eventCallback = function (ev) {\n            var type = ev.type;\n            _this._triggerEvent(type, ev);\n        };\n        // 在 document 处理拖拽到画布外的事件，处理从图形上移除画布未被捕捉的问题\n        this._onDocumentMove = function (ev) {\n            var canvas = _this.canvas;\n            var el = canvas.get('el');\n            if (el !== ev.target) {\n                // 不在 canvas 上移动\n                if (_this.dragging || _this.currentShape) {\n                    var pointInfo = _this._getPointInfo(ev);\n                    // 还在拖拽过程中\n                    if (_this.dragging) {\n                        _this._emitEvent('drag', ev, pointInfo, _this.draggingShape);\n                    }\n                    // 说明从某个图形直接移动到了画布外面，\n                    // 修复了 mouseleave 的 bug 后不再出现这种情况\n                    // if (this.currentShape) {\n                    //   this._emitEvent('mouseleave', ev, pointInfo, this.currentShape, this.currentShape, null);\n                    //   this.currentShape = null;\n                    // }\n                }\n            }\n        };\n        // 在 document 上处理拖拽到外面，释放鼠标时触发 dragend\n        this._onDocumentMouseUp = function (ev) {\n            var canvas = _this.canvas;\n            var el = canvas.get('el');\n            if (el !== ev.target) {\n                // 不在 canvas 上移动\n                if (_this.dragging) {\n                    var pointInfo = _this._getPointInfo(ev);\n                    if (_this.draggingShape) {\n                        // 如果存在拖拽的图形，则也触发 drop 事件\n                        _this._emitEvent('drop', ev, pointInfo, null);\n                    }\n                    _this._emitEvent('dragend', ev, pointInfo, _this.draggingShape);\n                    _this._afterDrag(_this.draggingShape, pointInfo, ev);\n                }\n            }\n        };\n        this.canvas = cfg.canvas;\n    }\n    EventController.prototype.init = function () {\n        this._bindEvents();\n    };\n    // 注册事件\n    EventController.prototype._bindEvents = function () {\n        var _this = this;\n        var el = this.canvas.get('el');\n        each(EVENTS, function (eventName) {\n            el.addEventListener(eventName, _this._eventCallback);\n        });\n        if (document) {\n            // 处理移动到外面没有触发 shape mouse leave 的事件\n            // 处理拖拽到外部的问题\n            document.addEventListener('mousemove', this._onDocumentMove);\n            // 处理拖拽过程中在外部释放鼠标的问题\n            document.addEventListener('mouseup', this._onDocumentMouseUp);\n        }\n    };\n    // 清理事件\n    EventController.prototype._clearEvents = function () {\n        var _this = this;\n        var el = this.canvas.get('el');\n        each(EVENTS, function (eventName) {\n            el.removeEventListener(eventName, _this._eventCallback);\n        });\n        if (document) {\n            document.removeEventListener('mousemove', this._onDocumentMove);\n            document.removeEventListener('mouseup', this._onDocumentMouseUp);\n        }\n    };\n    EventController.prototype._getEventObj = function (type, event, point, target, fromShape, toShape) {\n        var eventObj = new GraphEvent(type, event);\n        eventObj.fromShape = fromShape;\n        eventObj.toShape = toShape;\n        eventObj.x = point.x;\n        eventObj.y = point.y;\n        eventObj.clientX = point.clientX;\n        eventObj.clientY = point.clientY;\n        eventObj.propagationPath.push(target);\n        // 事件的x,y应该是基于画布左上角的，与canvas的matrix无关\n        return eventObj;\n    };\n    // 根据点获取图形，提取成独立方法，便于后续优化\n    EventController.prototype._getShape = function (point, ev) {\n        return this.canvas.getShape(point.x, point.y, ev);\n    };\n    // 获取事件的当前点的信息\n    EventController.prototype._getPointInfo = function (ev) {\n        var canvas = this.canvas;\n        var clientPoint = canvas.getClientByEvent(ev);\n        var point = canvas.getPointByEvent(ev);\n        return {\n            x: point.x,\n            y: point.y,\n            clientX: clientPoint.x,\n            clientY: clientPoint.y,\n        };\n    };\n    // 触发事件\n    EventController.prototype._triggerEvent = function (type, ev) {\n        var pointInfo = this._getPointInfo(ev);\n        // 每次都获取图形有一定成本，后期可以考虑进行缓存策略\n        var shape = this._getShape(pointInfo, ev);\n        var method = this[\"_on\" + type];\n        var leaveCanvas = false;\n        if (method) {\n            method.call(this, pointInfo, shape, ev);\n        }\n        else {\n            var preShape = this.currentShape;\n            // 如果进入、移出画布时存在图形，则要分别触发事件\n            if (type === 'mouseenter' || type === 'dragenter' || type === 'mouseover') {\n                this._emitEvent(type, ev, pointInfo, null, null, shape); // 先进入画布\n                if (shape) {\n                    this._emitEvent(type, ev, pointInfo, shape, null, shape); // 再触发图形的事件\n                }\n                if (type === 'mouseenter' && this.draggingShape) {\n                    // 如果正在拖拽图形, 则触发 dragleave\n                    this._emitEvent('dragenter', ev, pointInfo, null);\n                }\n            }\n            else if (type === 'mouseleave' || type === 'dragleave' || type === 'mouseout') {\n                leaveCanvas = true;\n                if (preShape) {\n                    this._emitEvent(type, ev, pointInfo, preShape, preShape, null); // 先触发图形的事件\n                }\n                this._emitEvent(type, ev, pointInfo, null, preShape, null); // 再触发离开画布事件\n                if (type === 'mouseleave' && this.draggingShape) {\n                    this._emitEvent('dragleave', ev, pointInfo, null);\n                }\n            }\n            else {\n                this._emitEvent(type, ev, pointInfo, shape, null, null); // 一般事件中不需要考虑 from, to\n            }\n        }\n        if (!leaveCanvas) {\n            this.currentShape = shape;\n        }\n        // 当鼠标从画布移动到 shape 或者从 preShape 移动到 shape 时，应用 shape 上的鼠标样式\n        if (shape && !shape.get('destroyed')) {\n            var canvas = this.canvas;\n            var el = canvas.get('el');\n            el.style.cursor = shape.attr('cursor') || canvas.get('cursor');\n        }\n    };\n    // 记录下点击的位置、图形，便于拖拽事件、click 事件的判定\n    EventController.prototype._onmousedown = function (pointInfo, shape, event) {\n        // 只有鼠标左键的 mousedown 事件才会设置 mousedownShape 等属性，避免鼠标右键的 mousedown 事件引起其他事件发生\n        if (event.button === LEFT_BTN_CODE) {\n            this.mousedownShape = shape;\n            this.mousedownPoint = pointInfo;\n            this.mousedownTimeStamp = event.timeStamp;\n        }\n        this._emitEvent('mousedown', event, pointInfo, shape, null, null); // mousedown 不考虑fromShape, toShape\n    };\n    // mouseleave 和 mouseenter 都是成对存在的\n    // mouseenter 和 mouseover 同时触发\n    EventController.prototype._emitMouseoverEvents = function (event, pointInfo, fromShape, toShape) {\n        var el = this.canvas.get('el');\n        if (fromShape !== toShape) {\n            if (fromShape) {\n                this._emitEvent('mouseout', event, pointInfo, fromShape, fromShape, toShape);\n                this._emitEvent('mouseleave', event, pointInfo, fromShape, fromShape, toShape);\n                // 当鼠标从 fromShape 移动到画布上时，重置鼠标样式\n                if (!toShape || toShape.get('destroyed')) {\n                    el.style.cursor = this.canvas.get('cursor');\n                }\n            }\n            if (toShape) {\n                this._emitEvent('mouseover', event, pointInfo, toShape, fromShape, toShape);\n                this._emitEvent('mouseenter', event, pointInfo, toShape, fromShape, toShape);\n            }\n        }\n    };\n    // dragover 不等同于 mouseover，而等同于 mousemove\n    EventController.prototype._emitDragoverEvents = function (event, pointInfo, fromShape, toShape, isCanvasEmit) {\n        if (toShape) {\n            if (toShape !== fromShape) {\n                if (fromShape) {\n                    this._emitEvent('dragleave', event, pointInfo, fromShape, fromShape, toShape);\n                }\n                this._emitEvent('dragenter', event, pointInfo, toShape, fromShape, toShape);\n            }\n            if (!isCanvasEmit) {\n                this._emitEvent('dragover', event, pointInfo, toShape);\n            }\n        }\n        else if (fromShape) {\n            // TODO: 此处判断有问题，当 drag 图形时，也会触发一次 dragleave 事件，因为此时 toShape 为 null，这不是所期望的\n            // 经过空白区域\n            this._emitEvent('dragleave', event, pointInfo, fromShape, fromShape, toShape);\n        }\n        if (isCanvasEmit) {\n            this._emitEvent('dragover', event, pointInfo, toShape);\n        }\n    };\n    // drag 完成后，需要做一些清理工作\n    EventController.prototype._afterDrag = function (draggingShape, pointInfo, event) {\n        if (draggingShape) {\n            draggingShape.set('capture', true); // 恢复可以拾取\n            this.draggingShape = null;\n        }\n        this.dragging = false;\n        // drag 完成后，有可能 draggingShape 已经移动到了当前位置，所以不能直接取当前图形\n        var shape = this._getShape(pointInfo, event);\n        // 拖拽完成后，进行 enter，leave 的判定\n        if (shape !== draggingShape) {\n            this._emitMouseoverEvents(event, pointInfo, draggingShape, shape);\n        }\n        this.currentShape = shape; // 更新当前 shape，如果不处理当前图形的 mouseleave 事件可能会出问题\n    };\n    // 按键抬起时，会终止拖拽、触发点击\n    EventController.prototype._onmouseup = function (pointInfo, shape, event) {\n        // eevent.button === 0 表示鼠标左键事件，此处加上判断主要是为了避免右键鼠标会触发 mouseup 和 click 事件\n        // ref: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n        if (event.button === LEFT_BTN_CODE) {\n            var draggingShape = this.draggingShape;\n            if (this.dragging) {\n                // 存在可以拖拽的图形，同时拖拽到其他图形上时触发 drag 事件\n                if (draggingShape) {\n                    this._emitEvent('drop', event, pointInfo, shape);\n                }\n                this._emitEvent('dragend', event, pointInfo, draggingShape);\n                this._afterDrag(draggingShape, pointInfo, event);\n            }\n            else {\n                this._emitEvent('mouseup', event, pointInfo, shape); // 先触发 mouseup 再触发 click\n                if (shape === this.mousedownShape) {\n                    this._emitEvent('click', event, pointInfo, shape);\n                }\n                this.mousedownShape = null;\n                this.mousedownPoint = null;\n            }\n        }\n    };\n    // 当触发浏览器的 dragover 事件时，不会再触发 mousemove ，所以这时候的 dragenter, dragleave 事件需要重新处理\n    EventController.prototype._ondragover = function (pointInfo, shape, event) {\n        event.preventDefault(); // 如果不对 dragover 进行 preventDefault，则不会在 canvas 上触发 drop 事件\n        var preShape = this.currentShape;\n        this._emitDragoverEvents(event, pointInfo, preShape, shape, true);\n    };\n    // 大量的图形事件，都通过 mousemove 模拟\n    EventController.prototype._onmousemove = function (pointInfo, shape, event) {\n        var canvas = this.canvas;\n        var preShape = this.currentShape;\n        var draggingShape = this.draggingShape;\n        // 正在拖拽时\n        if (this.dragging) {\n            // 正在拖拽中\n            if (draggingShape) {\n                // 如果拖拽了 shape 会触发 dragenter, dragleave, dragover 和 drag 事件\n                this._emitDragoverEvents(event, pointInfo, preShape, shape, false);\n            }\n            // 如果存在 draggingShape 则会在 draggingShape 上触发 drag 事件，冒泡到 canvas 上\n            // 否则在 canvas 上触发 drag 事件\n            this._emitEvent('drag', event, pointInfo, draggingShape);\n        }\n        else {\n            var mousedownPoint = this.mousedownPoint;\n            if (mousedownPoint) {\n                // 当鼠标点击下去，同时移动时，进行 drag 判定\n                var mousedownShape = this.mousedownShape;\n                var now = event.timeStamp;\n                var timeWindow = now - this.mousedownTimeStamp;\n                var dx = mousedownPoint.clientX - pointInfo.clientX;\n                var dy = mousedownPoint.clientY - pointInfo.clientY;\n                var dist = dx * dx + dy * dy;\n                if (timeWindow > 120 || dist > CLICK_OFFSET) {\n                    if (mousedownShape && mousedownShape.get('draggable')) {\n                        // 设置了 draggable 的 shape 才能触发 drag 相关的事件\n                        draggingShape = this.mousedownShape; // 拖动鼠标点下时的 shape\n                        draggingShape.set('capture', false); // 禁止继续拾取，否则无法进行 dragover,dragenter,dragleave,drop的判定\n                        this.draggingShape = draggingShape;\n                        this.dragging = true;\n                        this._emitEvent('dragstart', event, pointInfo, draggingShape);\n                        // 清理按下鼠标时缓存的值\n                        this.mousedownShape = null;\n                        this.mousedownPoint = null;\n                    }\n                    else if (!mousedownShape && canvas.get('draggable')) {\n                        // 设置了 draggable 的 canvas 才能触发 drag 相关的事件\n                        this.dragging = true;\n                        this._emitEvent('dragstart', event, pointInfo, null);\n                        // 清理按下鼠标时缓存的值\n                        this.mousedownShape = null;\n                        this.mousedownPoint = null;\n                    }\n                    else {\n                        this._emitMouseoverEvents(event, pointInfo, preShape, shape);\n                        this._emitEvent('mousemove', event, pointInfo, shape);\n                    }\n                }\n                else {\n                    this._emitMouseoverEvents(event, pointInfo, preShape, shape);\n                    this._emitEvent('mousemove', event, pointInfo, shape);\n                }\n            }\n            else {\n                // 没有按键按下时，则直接触发 mouse over 相关的各种事件\n                this._emitMouseoverEvents(event, pointInfo, preShape, shape);\n                // 始终触发移动\n                this._emitEvent('mousemove', event, pointInfo, shape);\n            }\n        }\n    };\n    // 触发事件\n    EventController.prototype._emitEvent = function (type, event, pointInfo, shape, fromShape, toShape) {\n        var eventObj = this._getEventObj(type, event, pointInfo, shape, fromShape, toShape);\n        // 存在 shape 触发，则进行冒泡处理\n        if (shape) {\n            eventObj.shape = shape;\n            // 触发 shape 上的事件\n            emitTargetEvent(shape, type, eventObj);\n            var parent_1 = shape.getParent();\n            // 执行冒泡\n            while (parent_1) {\n                // 委托事件要先触发\n                parent_1.emitDelegation(type, eventObj);\n                // 事件冒泡停止，不能妨碍委托事件\n                if (!eventObj.propagationStopped) {\n                    bubbleEvent(parent_1, type, eventObj);\n                }\n                eventObj.propagationPath.push(parent_1);\n                parent_1 = parent_1.getParent();\n            }\n        }\n        else {\n            // 如果没有 shape 直接在 canvas 上触发\n            var canvas = this.canvas;\n            // 直接触发 canvas 上的事件\n            emitTargetEvent(canvas, type, eventObj);\n        }\n    };\n    EventController.prototype.destroy = function () {\n        // 清理事件\n        this._clearEvents();\n        // 清理缓存的对象\n        this.canvas = null;\n        this.currentShape = null;\n        this.draggingShape = null;\n        this.mousedownPoint = null;\n        this.mousedownShape = null;\n        this.mousedownTimeStamp = null;\n    };\n    return EventController;\n}());\nexport default EventController;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}