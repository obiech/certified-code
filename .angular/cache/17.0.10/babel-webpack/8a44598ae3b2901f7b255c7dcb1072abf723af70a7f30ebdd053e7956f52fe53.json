{"ast":null,"code":"import { each } from '@antv/util';\nimport { getPathPoints } from '../util/get-path-points';\nimport { getStyle } from '../util/get-style';\nimport { getLinePath, getSplinePath } from '../util/path';\nfunction getPath(points, isInCircle, smooth, registeredShape, constraint) {\n  var path = [];\n  if (points.length) {\n    var topLinePoints_1 = []; // area 区域上部分\n    var bottomLinePoints_1 = []; // area 区域下部分\n    for (var i = 0, len = points.length; i < len; i++) {\n      var point = points[i];\n      topLinePoints_1.push(point[1]);\n      bottomLinePoints_1.push(point[0]);\n    }\n    bottomLinePoints_1 = bottomLinePoints_1.reverse();\n    each([topLinePoints_1, bottomLinePoints_1], function (pointsData, index) {\n      var subPath = [];\n      var parsedPoints = registeredShape.parsePoints(pointsData);\n      var p1 = parsedPoints[0];\n      if (topLinePoints_1.length === 1 && bottomLinePoints_1.length === 1) {\n        // 都只有一个点，绘制一条竖线\n        subPath = index === 0 ? [['M', p1.x - 0.5, p1.y], ['L', p1.x + 0.5, p1.y]] : [['L', p1.x + 0.5, p1.y], ['L', p1.x - 0.5, p1.y]];\n      } else {\n        if (isInCircle) {\n          parsedPoints.push({\n            x: p1.x,\n            y: p1.y\n          });\n        }\n        if (smooth) {\n          subPath = getSplinePath(parsedPoints, false, constraint);\n        } else {\n          subPath = getLinePath(parsedPoints, false);\n        }\n        if (index > 0) {\n          subPath[0][0] = 'L';\n        }\n      }\n      path = path.concat(subPath);\n    });\n    path.push(['Z']);\n  }\n  return path;\n}\n/**\n * @ignore\n * Gets shape attrs\n * @param cfg\n * @param isStroke\n * @param smooth\n * @param registeredShape\n * @param [constraint]\n * @returns\n */\nexport function getShapeAttrs(cfg, isStroke, smooth, registeredShape, constraint) {\n  var attrs = getStyle(cfg, isStroke, !isStroke, 'lineWidth');\n  var connectNulls = cfg.connectNulls,\n    isInCircle = cfg.isInCircle,\n    points = cfg.points,\n    showSinglePoint = cfg.showSinglePoint;\n  var pathPoints = getPathPoints(points, connectNulls, showSinglePoint); // 根据 connectNulls 配置获取图形关键点\n  var path = [];\n  for (var i = 0, len = pathPoints.length; i < len; i++) {\n    var eachPoints = pathPoints[i];\n    path = path.concat(getPath(eachPoints, isInCircle, smooth, registeredShape, constraint));\n  }\n  attrs.path = path;\n  return attrs;\n}\n/**\n * @ignore\n * Gets constraint\n * @param coordinate\n * @returns constraint\n */\nexport function getConstraint(coordinate) {\n  var start = coordinate.start,\n    end = coordinate.end;\n  return [[start.x, end.y], [end.x, start.y]];\n}","map":{"version":3,"names":["each","getPathPoints","getStyle","getLinePath","getSplinePath","getPath","points","isInCircle","smooth","registeredShape","constraint","path","length","topLinePoints_1","bottomLinePoints_1","i","len","point","push","reverse","pointsData","index","subPath","parsedPoints","parsePoints","p1","x","y","concat","getShapeAttrs","cfg","isStroke","attrs","connectNulls","showSinglePoint","pathPoints","eachPoints","getConstraint","coordinate","start","end"],"sources":["/Users/obiechina/Documents/ridy-flutter-full-taxi-solution 2/node_modules/@antv/g2/esm/geometry/shape/area/util.js"],"sourcesContent":["import { each } from '@antv/util';\nimport { getPathPoints } from '../util/get-path-points';\nimport { getStyle } from '../util/get-style';\nimport { getLinePath, getSplinePath } from '../util/path';\nfunction getPath(points, isInCircle, smooth, registeredShape, constraint) {\n    var path = [];\n    if (points.length) {\n        var topLinePoints_1 = []; // area 区域上部分\n        var bottomLinePoints_1 = []; // area 区域下部分\n        for (var i = 0, len = points.length; i < len; i++) {\n            var point = points[i];\n            topLinePoints_1.push(point[1]);\n            bottomLinePoints_1.push(point[0]);\n        }\n        bottomLinePoints_1 = bottomLinePoints_1.reverse();\n        each([topLinePoints_1, bottomLinePoints_1], function (pointsData, index) {\n            var subPath = [];\n            var parsedPoints = registeredShape.parsePoints(pointsData);\n            var p1 = parsedPoints[0];\n            if (topLinePoints_1.length === 1 && bottomLinePoints_1.length === 1) {\n                // 都只有一个点，绘制一条竖线\n                subPath =\n                    index === 0\n                        ? [\n                            ['M', p1.x - 0.5, p1.y],\n                            ['L', p1.x + 0.5, p1.y],\n                        ]\n                        : [\n                            ['L', p1.x + 0.5, p1.y],\n                            ['L', p1.x - 0.5, p1.y],\n                        ];\n            }\n            else {\n                if (isInCircle) {\n                    parsedPoints.push({ x: p1.x, y: p1.y });\n                }\n                if (smooth) {\n                    subPath = getSplinePath(parsedPoints, false, constraint);\n                }\n                else {\n                    subPath = getLinePath(parsedPoints, false);\n                }\n                if (index > 0) {\n                    subPath[0][0] = 'L';\n                }\n            }\n            path = path.concat(subPath);\n        });\n        path.push(['Z']);\n    }\n    return path;\n}\n/**\n * @ignore\n * Gets shape attrs\n * @param cfg\n * @param isStroke\n * @param smooth\n * @param registeredShape\n * @param [constraint]\n * @returns\n */\nexport function getShapeAttrs(cfg, isStroke, smooth, registeredShape, constraint) {\n    var attrs = getStyle(cfg, isStroke, !isStroke, 'lineWidth');\n    var connectNulls = cfg.connectNulls, isInCircle = cfg.isInCircle, points = cfg.points, showSinglePoint = cfg.showSinglePoint;\n    var pathPoints = getPathPoints(points, connectNulls, showSinglePoint); // 根据 connectNulls 配置获取图形关键点\n    var path = [];\n    for (var i = 0, len = pathPoints.length; i < len; i++) {\n        var eachPoints = pathPoints[i];\n        path = path.concat(getPath(eachPoints, isInCircle, smooth, registeredShape, constraint));\n    }\n    attrs.path = path;\n    return attrs;\n}\n/**\n * @ignore\n * Gets constraint\n * @param coordinate\n * @returns constraint\n */\nexport function getConstraint(coordinate) {\n    var start = coordinate.start, end = coordinate.end;\n    return [\n        [start.x, end.y],\n        [end.x, start.y],\n    ];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}