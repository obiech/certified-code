{"ast":null,"code":"import { __read } from \"tslib\";\nimport { vec2 } from '@antv/matrix-util';\nimport { each } from '@antv/util';\nimport { getDistanceToCenter } from '../../../util/coordinate';\nfunction _points2path(points, isInCircle) {\n  var path = [];\n  if (points.length) {\n    path.push(['M', points[0].x, points[0].y]);\n    for (var i = 1, length_1 = points.length; i < length_1; i += 1) {\n      var item = points[i];\n      path.push(['L', item.x, item.y]);\n    }\n    if (isInCircle) {\n      path.push(['Z']);\n    }\n  }\n  return path;\n}\nfunction _convertArr(arr, coord) {\n  var tmp = [arr[0]];\n  for (var i = 1, len = arr.length; i < len; i = i + 2) {\n    var point = coord.convert({\n      x: arr[i],\n      y: arr[i + 1]\n    });\n    tmp.push(point.x, point.y);\n  }\n  return tmp;\n}\nfunction _convertArcPath(path, coord) {\n  var isTransposed = coord.isTransposed;\n  var r = path[1];\n  var x = path[6];\n  var y = path[7];\n  var point = coord.convert({\n    x: x,\n    y: y\n  });\n  var direction = isTransposed ? 0 : 1;\n  return ['A', r, r, 0, 0, direction, point.x, point.y];\n}\nfunction _convertPolarPath(pre, cur, coord) {\n  var isTransposed = coord.isTransposed,\n    startAngle = coord.startAngle,\n    endAngle = coord.endAngle;\n  var prePoint = pre[0].toLowerCase() === 'a' ? {\n    x: pre[6],\n    y: pre[7]\n  } : {\n    x: pre[1],\n    y: pre[2]\n  };\n  var curPoint = {\n    x: cur[1],\n    y: cur[2]\n  };\n  var rst = [];\n  var xDim = isTransposed ? 'y' : 'x';\n  var angleRange = Math.abs(curPoint[xDim] - prePoint[xDim]) * (endAngle - startAngle);\n  var direction = curPoint[xDim] >= prePoint[xDim] ? 1 : 0; // 圆弧的方向\n  var flag = angleRange > Math.PI ? 1 : 0; // 大弧还是小弧标志位\n  var convertPoint = coord.convert(curPoint);\n  var r = getDistanceToCenter(coord, convertPoint);\n  if (r >= 0.5) {\n    // 小于1像素的圆在图像上无法识别\n    if (angleRange === Math.PI * 2) {\n      var middlePoint = {\n        x: (curPoint.x + prePoint.x) / 2,\n        y: (curPoint.y + prePoint.y) / 2\n      };\n      var middleConvertPoint = coord.convert(middlePoint);\n      rst.push(['A', r, r, 0, flag, direction, middleConvertPoint.x, middleConvertPoint.y]);\n      rst.push(['A', r, r, 0, flag, direction, convertPoint.x, convertPoint.y]);\n    } else {\n      rst.push(['A', r, r, 0, flag, direction, convertPoint.x, convertPoint.y]);\n    }\n  }\n  return rst;\n}\n// 当存在整体的圆时，去除圆前面和后面的线，防止出现直线穿过整个圆的情形\nfunction _filterFullCirleLine(path) {\n  each(path, function (subPath, index) {\n    var cur = subPath;\n    if (cur[0].toLowerCase() === 'a') {\n      var pre = path[index - 1];\n      var next = path[index + 1];\n      if (next && next[0].toLowerCase() === 'a') {\n        if (pre && pre[0].toLowerCase() === 'l') {\n          pre[0] = 'M';\n        }\n      } else if (pre && pre[0].toLowerCase() === 'a') {\n        if (next && next[0].toLowerCase() === 'l') {\n          next[0] = 'M';\n        }\n      }\n    }\n  });\n}\n/**\n * @ignore\n * 计算光滑的贝塞尔曲线\n */\nexport var smoothBezier = function (points, smooth, isLoop, constraint) {\n  var _a;\n  var cps = [];\n  var hasConstraint = !!constraint;\n  var prevPoint;\n  var nextPoint;\n  var min;\n  var max;\n  var nextCp0;\n  var cp1;\n  var cp0;\n  if (hasConstraint) {\n    _a = __read(constraint, 2), min = _a[0], max = _a[1];\n    for (var i = 0, l = points.length; i < l; i++) {\n      var point = points[i];\n      min = vec2.min([0, 0], min, point);\n      max = vec2.max([0, 0], max, point);\n    }\n  }\n  for (var i = 0, len = points.length; i < len; i++) {\n    var point = points[i];\n    if (i === 0 && !isLoop) {\n      cp0 = point;\n    } else if (i === len - 1 && !isLoop) {\n      cp1 = point;\n      cps.push(cp0);\n      cps.push(cp1);\n    } else {\n      prevPoint = points[isLoop ? i ? i - 1 : len - 1 : i - 1];\n      nextPoint = points[isLoop ? (i + 1) % len : i + 1];\n      var v = [0, 0];\n      v = vec2.sub(v, nextPoint, prevPoint);\n      v = vec2.scale(v, v, smooth);\n      var d0 = vec2.distance(point, prevPoint);\n      var d1 = vec2.distance(point, nextPoint);\n      var sum = d0 + d1;\n      if (sum !== 0) {\n        d0 /= sum;\n        d1 /= sum;\n      }\n      var v1 = vec2.scale([0, 0], v, -d0);\n      var v2 = vec2.scale([0, 0], v, d1);\n      cp1 = vec2.add([0, 0], point, v1);\n      nextCp0 = vec2.add([0, 0], point, v2);\n      // 下一个控制点必须在这个点和下一个点之间\n      nextCp0 = vec2.min([0, 0], nextCp0, vec2.max([0, 0], nextPoint, point));\n      nextCp0 = vec2.max([0, 0], nextCp0, vec2.min([0, 0], nextPoint, point));\n      // 重新计算 cp1 的值\n      v1 = vec2.sub([0, 0], nextCp0, point);\n      v1 = vec2.scale([0, 0], v1, -d0 / d1);\n      cp1 = vec2.add([0, 0], point, v1);\n      // 上一个控制点必须要在上一个点和这一个点之间\n      cp1 = vec2.min([0, 0], cp1, vec2.max([0, 0], prevPoint, point));\n      cp1 = vec2.max([0, 0], cp1, vec2.min([0, 0], prevPoint, point));\n      // 重新计算 nextCp0 的值\n      v2 = vec2.sub([0, 0], point, cp1);\n      v2 = vec2.scale([0, 0], v2, d1 / d0);\n      nextCp0 = vec2.add([0, 0], point, v2);\n      if (hasConstraint) {\n        cp1 = vec2.max([0, 0], cp1, min);\n        cp1 = vec2.min([0, 0], cp1, max);\n        nextCp0 = vec2.max([0, 0], nextCp0, min);\n        nextCp0 = vec2.min([0, 0], nextCp0, max);\n      }\n      cps.push(cp0);\n      cps.push(cp1);\n      cp0 = nextCp0;\n    }\n  }\n  if (isLoop) {\n    cps.push(cps.shift());\n  }\n  return cps;\n};\n/**\n * @ignore\n * 贝塞尔曲线\n */\nexport function catmullRom2bezier(crp, z, constraint) {\n  var isLoop = !!z;\n  var pointList = [];\n  for (var i = 0, l = crp.length; i < l; i += 2) {\n    pointList.push([crp[i], crp[i + 1]]);\n  }\n  var controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);\n  var len = pointList.length;\n  var d1 = [];\n  var cp1;\n  var cp2;\n  var p;\n  for (var i = 0; i < len - 1; i++) {\n    cp1 = controlPointList[i * 2];\n    cp2 = controlPointList[i * 2 + 1];\n    p = pointList[i + 1];\n    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);\n  }\n  if (isLoop) {\n    cp1 = controlPointList[len];\n    cp2 = controlPointList[len + 1];\n    p = pointList[0];\n    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);\n  }\n  return d1;\n}\n/**\n * @ignore\n * 将点连接成路径 path\n */\nexport function getLinePath(points, isInCircle) {\n  return _points2path(points, isInCircle);\n}\n/**\n * @ignore\n * 根据关键点获取限定了范围的平滑线\n */\nexport function getSplinePath(points, isInCircle, constaint) {\n  var data = [];\n  var first = points[0];\n  var prePoint = null;\n  if (points.length <= 2) {\n    // 两点以内直接绘制成路径\n    return getLinePath(points, isInCircle);\n  }\n  for (var i = 0, len = points.length; i < len; i++) {\n    var point = points[i];\n    if (!prePoint || !(prePoint.x === point.x && prePoint.y === point.y)) {\n      data.push(point.x);\n      data.push(point.y);\n      prePoint = point;\n    }\n  }\n  var constraint = constaint || [\n  // 范围\n  [0, 0], [1, 1]];\n  var splinePath = catmullRom2bezier(data, isInCircle, constraint);\n  splinePath.unshift(['M', first.x, first.y]);\n  return splinePath;\n}\n/**\n * @ignore\n * 将归一化后的路径数据转换成坐标\n */\nexport function convertNormalPath(coord, path) {\n  var tmp = [];\n  each(path, function (subPath) {\n    var action = subPath[0];\n    switch (action.toLowerCase()) {\n      case 'm':\n      case 'l':\n      case 'c':\n        tmp.push(_convertArr(subPath, coord));\n        break;\n      case 'a':\n        tmp.push(_convertArcPath(subPath, coord));\n        break;\n      case 'z':\n      default:\n        tmp.push(subPath);\n        break;\n    }\n  });\n  return tmp;\n}\n/**\n * @ignore\n * 将路径转换为极坐标下的真实路径\n */\nexport function convertPolarPath(coord, path) {\n  var tmp = [];\n  var pre;\n  var cur;\n  var transposed;\n  var equals;\n  each(path, function (subPath, index) {\n    var action = subPath[0];\n    switch (action.toLowerCase()) {\n      case 'm':\n      case 'c':\n      case 'q':\n        tmp.push(_convertArr(subPath, coord));\n        break;\n      case 'l':\n        pre = path[index - 1];\n        cur = subPath;\n        transposed = coord.isTransposed;\n        // 是否半径相同，转换成圆弧\n        equals = transposed ? pre[pre.length - 2] === cur[1] : pre[pre.length - 1] === cur[2];\n        if (equals) {\n          tmp = tmp.concat(_convertPolarPath(pre, cur, coord));\n        } else {\n          // y 不相等，所以直接转换\n          tmp.push(_convertArr(subPath, coord));\n        }\n        break;\n      case 'a':\n        tmp.push(_convertArcPath(subPath, coord));\n        break;\n      case 'z':\n      default:\n        tmp.push(subPath);\n        break;\n    }\n  });\n  _filterFullCirleLine(tmp); // 过滤多余的直线\n  return tmp;\n}","map":{"version":3,"names":["__read","vec2","each","getDistanceToCenter","_points2path","points","isInCircle","path","length","push","x","y","i","length_1","item","_convertArr","arr","coord","tmp","len","point","convert","_convertArcPath","isTransposed","r","direction","_convertPolarPath","pre","cur","startAngle","endAngle","prePoint","toLowerCase","curPoint","rst","xDim","angleRange","Math","abs","flag","PI","convertPoint","middlePoint","middleConvertPoint","_filterFullCirleLine","subPath","index","next","smoothBezier","smooth","isLoop","constraint","_a","cps","hasConstraint","prevPoint","nextPoint","min","max","nextCp0","cp1","cp0","l","v","sub","scale","d0","distance","d1","sum","v1","v2","add","shift","catmullRom2bezier","crp","z","pointList","controlPointList","cp2","p","getLinePath","getSplinePath","constaint","data","first","splinePath","unshift","convertNormalPath","action","convertPolarPath","transposed","equals","concat"],"sources":["/Users/obiechina/Documents/ridy-flutter-full-taxi-solution 2/node_modules/@antv/g2/esm/geometry/shape/util/path.js"],"sourcesContent":["import { __read } from \"tslib\";\nimport { vec2 } from '@antv/matrix-util';\nimport { each } from '@antv/util';\nimport { getDistanceToCenter } from '../../../util/coordinate';\nfunction _points2path(points, isInCircle) {\n    var path = [];\n    if (points.length) {\n        path.push(['M', points[0].x, points[0].y]);\n        for (var i = 1, length_1 = points.length; i < length_1; i += 1) {\n            var item = points[i];\n            path.push(['L', item.x, item.y]);\n        }\n        if (isInCircle) {\n            path.push(['Z']);\n        }\n    }\n    return path;\n}\nfunction _convertArr(arr, coord) {\n    var tmp = [arr[0]];\n    for (var i = 1, len = arr.length; i < len; i = i + 2) {\n        var point = coord.convert({\n            x: arr[i],\n            y: arr[i + 1],\n        });\n        tmp.push(point.x, point.y);\n    }\n    return tmp;\n}\nfunction _convertArcPath(path, coord) {\n    var isTransposed = coord.isTransposed;\n    var r = path[1];\n    var x = path[6];\n    var y = path[7];\n    var point = coord.convert({ x: x, y: y });\n    var direction = isTransposed ? 0 : 1;\n    return ['A', r, r, 0, 0, direction, point.x, point.y];\n}\nfunction _convertPolarPath(pre, cur, coord) {\n    var isTransposed = coord.isTransposed, startAngle = coord.startAngle, endAngle = coord.endAngle;\n    var prePoint = pre[0].toLowerCase() === 'a'\n        ? {\n            x: pre[6],\n            y: pre[7],\n        }\n        : {\n            x: pre[1],\n            y: pre[2],\n        };\n    var curPoint = {\n        x: cur[1],\n        y: cur[2],\n    };\n    var rst = [];\n    var xDim = isTransposed ? 'y' : 'x';\n    var angleRange = Math.abs(curPoint[xDim] - prePoint[xDim]) * (endAngle - startAngle);\n    var direction = curPoint[xDim] >= prePoint[xDim] ? 1 : 0; // 圆弧的方向\n    var flag = angleRange > Math.PI ? 1 : 0; // 大弧还是小弧标志位\n    var convertPoint = coord.convert(curPoint);\n    var r = getDistanceToCenter(coord, convertPoint);\n    if (r >= 0.5) {\n        // 小于1像素的圆在图像上无法识别\n        if (angleRange === Math.PI * 2) {\n            var middlePoint = {\n                x: (curPoint.x + prePoint.x) / 2,\n                y: (curPoint.y + prePoint.y) / 2,\n            };\n            var middleConvertPoint = coord.convert(middlePoint);\n            rst.push(['A', r, r, 0, flag, direction, middleConvertPoint.x, middleConvertPoint.y]);\n            rst.push(['A', r, r, 0, flag, direction, convertPoint.x, convertPoint.y]);\n        }\n        else {\n            rst.push(['A', r, r, 0, flag, direction, convertPoint.x, convertPoint.y]);\n        }\n    }\n    return rst;\n}\n// 当存在整体的圆时，去除圆前面和后面的线，防止出现直线穿过整个圆的情形\nfunction _filterFullCirleLine(path) {\n    each(path, function (subPath, index) {\n        var cur = subPath;\n        if (cur[0].toLowerCase() === 'a') {\n            var pre = path[index - 1];\n            var next = path[index + 1];\n            if (next && next[0].toLowerCase() === 'a') {\n                if (pre && pre[0].toLowerCase() === 'l') {\n                    pre[0] = 'M';\n                }\n            }\n            else if (pre && pre[0].toLowerCase() === 'a') {\n                if (next && next[0].toLowerCase() === 'l') {\n                    next[0] = 'M';\n                }\n            }\n        }\n    });\n}\n/**\n * @ignore\n * 计算光滑的贝塞尔曲线\n */\nexport var smoothBezier = function (points, smooth, isLoop, constraint) {\n    var _a;\n    var cps = [];\n    var hasConstraint = !!constraint;\n    var prevPoint;\n    var nextPoint;\n    var min;\n    var max;\n    var nextCp0;\n    var cp1;\n    var cp0;\n    if (hasConstraint) {\n        _a = __read(constraint, 2), min = _a[0], max = _a[1];\n        for (var i = 0, l = points.length; i < l; i++) {\n            var point = points[i];\n            min = vec2.min([0, 0], min, point);\n            max = vec2.max([0, 0], max, point);\n        }\n    }\n    for (var i = 0, len = points.length; i < len; i++) {\n        var point = points[i];\n        if (i === 0 && !isLoop) {\n            cp0 = point;\n        }\n        else if (i === len - 1 && !isLoop) {\n            cp1 = point;\n            cps.push(cp0);\n            cps.push(cp1);\n        }\n        else {\n            prevPoint = points[isLoop ? (i ? i - 1 : len - 1) : i - 1];\n            nextPoint = points[isLoop ? (i + 1) % len : i + 1];\n            var v = [0, 0];\n            v = vec2.sub(v, nextPoint, prevPoint);\n            v = vec2.scale(v, v, smooth);\n            var d0 = vec2.distance(point, prevPoint);\n            var d1 = vec2.distance(point, nextPoint);\n            var sum = d0 + d1;\n            if (sum !== 0) {\n                d0 /= sum;\n                d1 /= sum;\n            }\n            var v1 = vec2.scale([0, 0], v, -d0);\n            var v2 = vec2.scale([0, 0], v, d1);\n            cp1 = vec2.add([0, 0], point, v1);\n            nextCp0 = vec2.add([0, 0], point, v2);\n            // 下一个控制点必须在这个点和下一个点之间\n            nextCp0 = vec2.min([0, 0], nextCp0, vec2.max([0, 0], nextPoint, point));\n            nextCp0 = vec2.max([0, 0], nextCp0, vec2.min([0, 0], nextPoint, point));\n            // 重新计算 cp1 的值\n            v1 = vec2.sub([0, 0], nextCp0, point);\n            v1 = vec2.scale([0, 0], v1, -d0 / d1);\n            cp1 = vec2.add([0, 0], point, v1);\n            // 上一个控制点必须要在上一个点和这一个点之间\n            cp1 = vec2.min([0, 0], cp1, vec2.max([0, 0], prevPoint, point));\n            cp1 = vec2.max([0, 0], cp1, vec2.min([0, 0], prevPoint, point));\n            // 重新计算 nextCp0 的值\n            v2 = vec2.sub([0, 0], point, cp1);\n            v2 = vec2.scale([0, 0], v2, d1 / d0);\n            nextCp0 = vec2.add([0, 0], point, v2);\n            if (hasConstraint) {\n                cp1 = vec2.max([0, 0], cp1, min);\n                cp1 = vec2.min([0, 0], cp1, max);\n                nextCp0 = vec2.max([0, 0], nextCp0, min);\n                nextCp0 = vec2.min([0, 0], nextCp0, max);\n            }\n            cps.push(cp0);\n            cps.push(cp1);\n            cp0 = nextCp0;\n        }\n    }\n    if (isLoop) {\n        cps.push(cps.shift());\n    }\n    return cps;\n};\n/**\n * @ignore\n * 贝塞尔曲线\n */\nexport function catmullRom2bezier(crp, z, constraint) {\n    var isLoop = !!z;\n    var pointList = [];\n    for (var i = 0, l = crp.length; i < l; i += 2) {\n        pointList.push([crp[i], crp[i + 1]]);\n    }\n    var controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);\n    var len = pointList.length;\n    var d1 = [];\n    var cp1;\n    var cp2;\n    var p;\n    for (var i = 0; i < len - 1; i++) {\n        cp1 = controlPointList[i * 2];\n        cp2 = controlPointList[i * 2 + 1];\n        p = pointList[i + 1];\n        d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);\n    }\n    if (isLoop) {\n        cp1 = controlPointList[len];\n        cp2 = controlPointList[len + 1];\n        p = pointList[0];\n        d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);\n    }\n    return d1;\n}\n/**\n * @ignore\n * 将点连接成路径 path\n */\nexport function getLinePath(points, isInCircle) {\n    return _points2path(points, isInCircle);\n}\n/**\n * @ignore\n * 根据关键点获取限定了范围的平滑线\n */\nexport function getSplinePath(points, isInCircle, constaint) {\n    var data = [];\n    var first = points[0];\n    var prePoint = null;\n    if (points.length <= 2) {\n        // 两点以内直接绘制成路径\n        return getLinePath(points, isInCircle);\n    }\n    for (var i = 0, len = points.length; i < len; i++) {\n        var point = points[i];\n        if (!prePoint || !(prePoint.x === point.x && prePoint.y === point.y)) {\n            data.push(point.x);\n            data.push(point.y);\n            prePoint = point;\n        }\n    }\n    var constraint = constaint || [\n        // 范围\n        [0, 0],\n        [1, 1],\n    ];\n    var splinePath = catmullRom2bezier(data, isInCircle, constraint);\n    splinePath.unshift(['M', first.x, first.y]);\n    return splinePath;\n}\n/**\n * @ignore\n * 将归一化后的路径数据转换成坐标\n */\nexport function convertNormalPath(coord, path) {\n    var tmp = [];\n    each(path, function (subPath) {\n        var action = subPath[0];\n        switch (action.toLowerCase()) {\n            case 'm':\n            case 'l':\n            case 'c':\n                tmp.push(_convertArr(subPath, coord));\n                break;\n            case 'a':\n                tmp.push(_convertArcPath(subPath, coord));\n                break;\n            case 'z':\n            default:\n                tmp.push(subPath);\n                break;\n        }\n    });\n    return tmp;\n}\n/**\n * @ignore\n * 将路径转换为极坐标下的真实路径\n */\nexport function convertPolarPath(coord, path) {\n    var tmp = [];\n    var pre;\n    var cur;\n    var transposed;\n    var equals;\n    each(path, function (subPath, index) {\n        var action = subPath[0];\n        switch (action.toLowerCase()) {\n            case 'm':\n            case 'c':\n            case 'q':\n                tmp.push(_convertArr(subPath, coord));\n                break;\n            case 'l':\n                pre = path[index - 1];\n                cur = subPath;\n                transposed = coord.isTransposed;\n                // 是否半径相同，转换成圆弧\n                equals = transposed ? pre[pre.length - 2] === cur[1] : pre[pre.length - 1] === cur[2];\n                if (equals) {\n                    tmp = tmp.concat(_convertPolarPath(pre, cur, coord));\n                }\n                else {\n                    // y 不相等，所以直接转换\n                    tmp.push(_convertArr(subPath, coord));\n                }\n                break;\n            case 'a':\n                tmp.push(_convertArcPath(subPath, coord));\n                break;\n            case 'z':\n            default:\n                tmp.push(subPath);\n                break;\n        }\n    });\n    _filterFullCirleLine(tmp); // 过滤多余的直线\n    return tmp;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}