{"ast":null,"code":"import _asyncToGenerator from \"/Users/obiechina/Documents/ridy-flutter-full-taxi-solution 2/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/**\n *\n * client\n *\n */\nvar __await = this && this.__await || function (v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n};\nvar __asyncGenerator = this && this.__asyncGenerator || function (thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []),\n    i,\n    q = [];\n  return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i;\n  function verb(n) {\n    if (g[n]) i[n] = function (v) {\n      return new Promise(function (a, b) {\n        q.push([n, v, a, b]) > 1 || resume(n, v);\n      });\n    };\n  }\n  function resume(n, v) {\n    try {\n      step(g[n](v));\n    } catch (e) {\n      settle(q[0][3], e);\n    }\n  }\n  function step(r) {\n    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n  }\n  function fulfill(value) {\n    resume(\"next\", value);\n  }\n  function reject(value) {\n    resume(\"throw\", value);\n  }\n  function settle(f, v) {\n    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n  }\n};\nimport { GRAPHQL_TRANSPORT_WS_PROTOCOL, CloseCode, MessageType, parseMessage, stringifyMessage } from './common.mjs';\nimport { isObject, limitCloseReason } from './utils.mjs';\n/** This file is the entry point for browsers, re-export common elements. */\nexport * from './common.mjs';\n/**\n * Creates a disposable GraphQL over WebSocket client.\n *\n * @category Client\n */\nexport function createClient(options) {\n  const {\n    url,\n    connectionParams,\n    lazy = true,\n    onNonLazyError = console.error,\n    lazyCloseTimeout: lazyCloseTimeoutMs = 0,\n    keepAlive = 0,\n    disablePong,\n    connectionAckWaitTimeout = 0,\n    retryAttempts = 5,\n    retryWait = /*#__PURE__*/function () {\n      var _randomisedExponentialBackoff = _asyncToGenerator(function* (retries) {\n        let retryDelay = 1000; // start with 1s delay\n        for (let i = 0; i < retries; i++) {\n          retryDelay *= 2;\n        }\n        yield new Promise(resolve => setTimeout(resolve, retryDelay +\n        // add random timeout from 300ms to 3s\n        Math.floor(Math.random() * (3000 - 300) + 300)));\n      });\n      function randomisedExponentialBackoff(_x) {\n        return _randomisedExponentialBackoff.apply(this, arguments);\n      }\n      return randomisedExponentialBackoff;\n    }(),\n    shouldRetry = isLikeCloseEvent,\n    isFatalConnectionProblem,\n    on,\n    webSocketImpl,\n    /**\n     * Generates a v4 UUID to be used as the ID using `Math`\n     * as the random number generator. Supply your own generator\n     * in case you need more uniqueness.\n     *\n     * Reference: https://gist.github.com/jed/982883\n     */\n    generateID = function generateUUID() {\n      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n        const r = Math.random() * 16 | 0,\n          v = c == 'x' ? r : r & 0x3 | 0x8;\n        return v.toString(16);\n      });\n    },\n    jsonMessageReplacer: replacer,\n    jsonMessageReviver: reviver\n  } = options;\n  let ws;\n  if (webSocketImpl) {\n    if (!isWebSocket(webSocketImpl)) {\n      throw new Error('Invalid WebSocket implementation provided');\n    }\n    ws = webSocketImpl;\n  } else if (typeof WebSocket !== 'undefined') {\n    ws = WebSocket;\n  } else if (typeof global !== 'undefined') {\n    ws = global.WebSocket ||\n    // @ts-expect-error: Support more browsers\n    global.MozWebSocket;\n  } else if (typeof window !== 'undefined') {\n    ws = window.WebSocket ||\n    // @ts-expect-error: Support more browsers\n    window.MozWebSocket;\n  }\n  if (!ws) throw new Error(\"WebSocket implementation missing; on Node you can `import WebSocket from 'ws';` and pass `webSocketImpl: WebSocket` to `createClient`\");\n  const WebSocketImpl = ws;\n  // websocket status emitter, subscriptions are handled differently\n  const emitter = (() => {\n    const message = (() => {\n      const listeners = {};\n      return {\n        on(id, listener) {\n          listeners[id] = listener;\n          return () => {\n            delete listeners[id];\n          };\n        },\n        emit(message) {\n          var _a;\n          if ('id' in message) (_a = listeners[message.id]) === null || _a === void 0 ? void 0 : _a.call(listeners, message);\n        }\n      };\n    })();\n    const listeners = {\n      connecting: (on === null || on === void 0 ? void 0 : on.connecting) ? [on.connecting] : [],\n      opened: (on === null || on === void 0 ? void 0 : on.opened) ? [on.opened] : [],\n      connected: (on === null || on === void 0 ? void 0 : on.connected) ? [on.connected] : [],\n      ping: (on === null || on === void 0 ? void 0 : on.ping) ? [on.ping] : [],\n      pong: (on === null || on === void 0 ? void 0 : on.pong) ? [on.pong] : [],\n      message: (on === null || on === void 0 ? void 0 : on.message) ? [message.emit, on.message] : [message.emit],\n      closed: (on === null || on === void 0 ? void 0 : on.closed) ? [on.closed] : [],\n      error: (on === null || on === void 0 ? void 0 : on.error) ? [on.error] : []\n    };\n    return {\n      onMessage: message.on,\n      on(event, listener) {\n        const l = listeners[event];\n        l.push(listener);\n        return () => {\n          l.splice(l.indexOf(listener), 1);\n        };\n      },\n      emit(event, ...args) {\n        // we copy the listeners so that unlistens dont \"pull the rug under our feet\"\n        for (const listener of [...listeners[event]]) {\n          // @ts-expect-error: The args should fit\n          listener(...args);\n        }\n      }\n    };\n  })();\n  // invokes the callback either when an error or closed event is emitted,\n  // first one that gets called prevails, other emissions are ignored\n  function errorOrClosed(cb) {\n    const listening = [\n    // errors are fatal and more critical than close events, throw them first\n    emitter.on('error', err => {\n      listening.forEach(unlisten => unlisten());\n      cb(err);\n    }),\n    // closes can be graceful and not fatal, throw them second (if error didnt throw)\n    emitter.on('closed', event => {\n      listening.forEach(unlisten => unlisten());\n      cb(event);\n    })];\n  }\n  let connecting,\n    locks = 0,\n    lazyCloseTimeout,\n    retrying = false,\n    retries = 0,\n    disposed = false;\n  function connect() {\n    return _connect.apply(this, arguments);\n  }\n  /**\n   * Checks the `connect` problem and evaluates if the client should retry.\n   */\n  function _connect() {\n    _connect = _asyncToGenerator(function* () {\n      // clear the lazy close timeout immediatelly so that close gets debounced\n      // see: https://github.com/enisdenjo/graphql-ws/issues/388\n      clearTimeout(lazyCloseTimeout);\n      const [socket, throwOnClose] = yield connecting !== null && connecting !== void 0 ? connecting : connecting = new Promise((connected, denied) => _asyncToGenerator(function* () {\n        if (retrying) {\n          yield retryWait(retries);\n          // subscriptions might complete while waiting for retry\n          if (!locks) {\n            connecting = undefined;\n            return denied({\n              code: 1000,\n              reason: 'All Subscriptions Gone'\n            });\n          }\n          retries++;\n        }\n        emitter.emit('connecting', retrying);\n        const socket = new WebSocketImpl(typeof url === 'function' ? yield url() : url, GRAPHQL_TRANSPORT_WS_PROTOCOL);\n        let connectionAckTimeout, queuedPing;\n        function enqueuePing() {\n          if (isFinite(keepAlive) && keepAlive > 0) {\n            clearTimeout(queuedPing); // in case where a pong was received before a ping (this is valid behaviour)\n            queuedPing = setTimeout(() => {\n              if (socket.readyState === WebSocketImpl.OPEN) {\n                socket.send(stringifyMessage({\n                  type: MessageType.Ping\n                }));\n                emitter.emit('ping', false, undefined);\n              }\n            }, keepAlive);\n          }\n        }\n        errorOrClosed(errOrEvent => {\n          connecting = undefined;\n          clearTimeout(connectionAckTimeout);\n          clearTimeout(queuedPing);\n          denied(errOrEvent);\n          if (errOrEvent instanceof TerminatedCloseEvent) {\n            socket.close(4499, 'Terminated'); // close event is artificial and emitted manually, see `Client.terminate()` below\n            socket.onerror = null;\n            socket.onclose = null;\n          }\n        });\n        socket.onerror = err => emitter.emit('error', err);\n        socket.onclose = event => emitter.emit('closed', event);\n        socket.onopen = /*#__PURE__*/_asyncToGenerator(function* () {\n          try {\n            emitter.emit('opened', socket);\n            const payload = typeof connectionParams === 'function' ? yield connectionParams() : connectionParams;\n            // connectionParams might take too long causing the server to kick off the client\n            // the necessary error/close event is already reported - simply stop execution\n            if (socket.readyState !== WebSocketImpl.OPEN) return;\n            socket.send(stringifyMessage(payload ? {\n              type: MessageType.ConnectionInit,\n              payload\n            } : {\n              type: MessageType.ConnectionInit\n              // payload is completely absent if not provided\n            }, replacer));\n            if (isFinite(connectionAckWaitTimeout) && connectionAckWaitTimeout > 0) {\n              connectionAckTimeout = setTimeout(() => {\n                socket.close(CloseCode.ConnectionAcknowledgementTimeout, 'Connection acknowledgement timeout');\n              }, connectionAckWaitTimeout);\n            }\n            enqueuePing(); // enqueue ping (noop if disabled)\n          } catch (err) {\n            emitter.emit('error', err);\n            socket.close(CloseCode.InternalClientError, limitCloseReason(err instanceof Error ? err.message : new Error(err).message, 'Internal client error'));\n          }\n        });\n        let acknowledged = false;\n        socket.onmessage = ({\n          data\n        }) => {\n          try {\n            const message = parseMessage(data, reviver);\n            emitter.emit('message', message);\n            if (message.type === 'ping' || message.type === 'pong') {\n              emitter.emit(message.type, true, message.payload); // received\n              if (message.type === 'pong') {\n                enqueuePing(); // enqueue next ping (noop if disabled)\n              } else if (!disablePong) {\n                // respond with pong on ping\n                socket.send(stringifyMessage(message.payload ? {\n                  type: MessageType.Pong,\n                  payload: message.payload\n                } : {\n                  type: MessageType.Pong\n                  // payload is completely absent if not provided\n                }));\n\n                emitter.emit('pong', false, message.payload);\n              }\n              return; // ping and pongs can be received whenever\n            }\n\n            if (acknowledged) return; // already connected and acknowledged\n            if (message.type !== MessageType.ConnectionAck) throw new Error(`First message cannot be of type ${message.type}`);\n            clearTimeout(connectionAckTimeout);\n            acknowledged = true;\n            emitter.emit('connected', socket, message.payload, retrying); // connected = socket opened + acknowledged\n            retrying = false; // future lazy connects are not retries\n            retries = 0; // reset the retries on connect\n            connected([socket, new Promise((_, reject) => errorOrClosed(reject))]);\n          } catch (err) {\n            socket.onmessage = null; // stop reading messages as soon as reading breaks once\n            emitter.emit('error', err);\n            socket.close(CloseCode.BadResponse, limitCloseReason(err instanceof Error ? err.message : new Error(err).message, 'Bad response'));\n          }\n        };\n      })());\n      // if the provided socket is in a closing state, wait for the throw on close\n      if (socket.readyState === WebSocketImpl.CLOSING) yield throwOnClose;\n      let release = () => {\n        // releases this connection\n      };\n      const released = new Promise(resolve => release = resolve);\n      return [socket, release, Promise.race([\n      // wait for\n      released.then(() => {\n        if (!locks) {\n          // and if no more locks are present, complete the connection\n          const complete = () => socket.close(1000, 'Normal Closure');\n          if (isFinite(lazyCloseTimeoutMs) && lazyCloseTimeoutMs > 0) {\n            // if the keepalive is set, allow for the specified calmdown time and\n            // then complete if the socket is still open.\n            lazyCloseTimeout = setTimeout(() => {\n              if (socket.readyState === WebSocketImpl.OPEN) complete();\n            }, lazyCloseTimeoutMs);\n          } else {\n            // otherwise complete immediately\n            complete();\n          }\n        }\n      }),\n      // or\n      throwOnClose])];\n    });\n    return _connect.apply(this, arguments);\n  }\n  function shouldRetryConnectOrThrow(errOrCloseEvent) {\n    // some close codes are worth reporting immediately\n    if (isLikeCloseEvent(errOrCloseEvent) && (isFatalInternalCloseCode(errOrCloseEvent.code) || [CloseCode.InternalServerError, CloseCode.InternalClientError, CloseCode.BadRequest, CloseCode.BadResponse, CloseCode.Unauthorized,\n    // CloseCode.Forbidden, might grant access out after retry\n    CloseCode.SubprotocolNotAcceptable,\n    // CloseCode.ConnectionInitialisationTimeout, might not time out after retry\n    // CloseCode.ConnectionAcknowledgementTimeout, might not time out after retry\n    CloseCode.SubscriberAlreadyExists, CloseCode.TooManyInitialisationRequests\n    // 4499, // Terminated, probably because the socket froze, we want to retry\n    ].includes(errOrCloseEvent.code))) throw errOrCloseEvent;\n    // client was disposed, no retries should proceed regardless\n    if (disposed) return false;\n    // normal closure (possibly all subscriptions have completed)\n    // if no locks were acquired in the meantime, shouldnt try again\n    if (isLikeCloseEvent(errOrCloseEvent) && errOrCloseEvent.code === 1000) return locks > 0;\n    // retries are not allowed or we tried to many times, report error\n    if (!retryAttempts || retries >= retryAttempts) throw errOrCloseEvent;\n    // throw non-retryable connection problems\n    if (!shouldRetry(errOrCloseEvent)) throw errOrCloseEvent;\n    // @deprecated throw fatal connection problems immediately\n    if (isFatalConnectionProblem === null || isFatalConnectionProblem === void 0 ? void 0 : isFatalConnectionProblem(errOrCloseEvent)) throw errOrCloseEvent;\n    // looks good, start retrying\n    return retrying = true;\n  }\n  // in non-lazy (hot?) mode always hold one connection lock to persist the socket\n  if (!lazy) {\n    _asyncToGenerator(function* () {\n      locks++;\n      for (;;) {\n        try {\n          const [,, throwOnClose] = yield connect();\n          yield throwOnClose; // will always throw because releaser is not used\n        } catch (errOrCloseEvent) {\n          try {\n            if (!shouldRetryConnectOrThrow(errOrCloseEvent)) return;\n          } catch (errOrCloseEvent) {\n            // report thrown error, no further retries\n            return onNonLazyError === null || onNonLazyError === void 0 ? void 0 : onNonLazyError(errOrCloseEvent);\n          }\n        }\n      }\n    })();\n  }\n  function subscribe(payload, sink) {\n    const id = generateID(payload);\n    let done = false,\n      errored = false,\n      releaser = () => {\n        // for handling completions before connect\n        locks--;\n        done = true;\n      };\n    _asyncToGenerator(function* () {\n      locks++;\n      for (;;) {\n        try {\n          const [socket, release, waitForReleaseOrThrowOnClose] = yield connect();\n          // if done while waiting for connect, release the connection lock right away\n          if (done) return release();\n          const unlisten = emitter.onMessage(id, message => {\n            switch (message.type) {\n              case MessageType.Next:\n                {\n                  // eslint-disable-next-line @typescript-eslint/no-explicit-any -- payload will fit type\n                  sink.next(message.payload);\n                  return;\n                }\n              case MessageType.Error:\n                {\n                  errored = true, done = true;\n                  sink.error(message.payload);\n                  releaser();\n                  return;\n                }\n              case MessageType.Complete:\n                {\n                  done = true;\n                  releaser(); // release completes the sink\n                  return;\n                }\n            }\n          });\n          socket.send(stringifyMessage({\n            id,\n            type: MessageType.Subscribe,\n            payload\n          }, replacer));\n          releaser = () => {\n            if (!done && socket.readyState === WebSocketImpl.OPEN)\n              // if not completed already and socket is open, send complete message to server on release\n              socket.send(stringifyMessage({\n                id,\n                type: MessageType.Complete\n              }, replacer));\n            locks--;\n            done = true;\n            release();\n          };\n          // either the releaser will be called, connection completed and\n          // the promise resolved or the socket closed and the promise rejected.\n          // whatever happens though, we want to stop listening for messages\n          yield waitForReleaseOrThrowOnClose.finally(unlisten);\n          return; // completed, shouldnt try again\n        } catch (errOrCloseEvent) {\n          if (!shouldRetryConnectOrThrow(errOrCloseEvent)) return;\n        }\n      }\n    })().then(() => {\n      // delivering either an error or a complete terminates the sequence\n      if (!errored) sink.complete();\n    }) // resolves on release or normal closure\n    .catch(err => {\n      sink.error(err);\n    }); // rejects on close events and errors\n    return () => {\n      // dispose only of active subscriptions\n      if (!done) releaser();\n    };\n  }\n  return {\n    on: emitter.on,\n    subscribe,\n    iterate(request) {\n      const pending = [];\n      const deferred = {\n        done: false,\n        error: null,\n        resolve: () => {\n          // noop\n        }\n      };\n      const dispose = subscribe(request, {\n        next(val) {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          pending.push(val);\n          deferred.resolve();\n        },\n        error(err) {\n          deferred.done = true;\n          deferred.error = err;\n          deferred.resolve();\n        },\n        complete() {\n          deferred.done = true;\n          deferred.resolve();\n        }\n      });\n      const iterator = function iterator() {\n        return __asyncGenerator(this, arguments, function* iterator_1() {\n          for (;;) {\n            if (!pending.length) {\n              // only wait if there are no pending messages available\n              yield __await(new Promise(resolve => deferred.resolve = resolve));\n            }\n            // first flush\n            while (pending.length) {\n              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n              yield yield __await(pending.shift());\n            }\n            // then error\n            if (deferred.error) {\n              throw deferred.error;\n            }\n            // or complete\n            if (deferred.done) {\n              return yield __await(void 0);\n            }\n          }\n        });\n      }();\n      iterator.throw = /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator(function* (err) {\n          if (!deferred.done) {\n            deferred.done = true;\n            deferred.error = err;\n            deferred.resolve();\n          }\n          return {\n            done: true,\n            value: undefined\n          };\n        });\n        return function (_x2) {\n          return _ref3.apply(this, arguments);\n        };\n      }();\n      iterator.return = /*#__PURE__*/_asyncToGenerator(function* () {\n        dispose();\n        return {\n          done: true,\n          value: undefined\n        };\n      });\n      return iterator;\n    },\n    dispose() {\n      return _asyncToGenerator(function* () {\n        disposed = true;\n        if (connecting) {\n          // if there is a connection, close it\n          const [socket] = yield connecting;\n          socket.close(1000, 'Normal Closure');\n        }\n      })();\n    },\n    terminate() {\n      if (connecting) {\n        // only if there is a connection\n        emitter.emit('closed', new TerminatedCloseEvent());\n      }\n    }\n  };\n}\n/**\n * A syntetic close event `4499: Terminated` is issued to the current to immediately\n * close the connection without waiting for the one coming from `WebSocket.onclose`.\n *\n * Terminating is not considered fatal and a connection retry will occur as expected.\n *\n * Useful in cases where the WebSocket is stuck and not emitting any events;\n * can happen on iOS Safari, see: https://github.com/enisdenjo/graphql-ws/discussions/290.\n */\nexport class TerminatedCloseEvent extends Error {\n  constructor() {\n    super(...arguments);\n    this.name = 'TerminatedCloseEvent';\n    this.message = '4499: Terminated';\n    this.code = 4499;\n    this.reason = 'Terminated';\n    this.wasClean = false;\n  }\n}\nfunction isLikeCloseEvent(val) {\n  return isObject(val) && 'code' in val && 'reason' in val;\n}\nfunction isFatalInternalCloseCode(code) {\n  if ([1000, 1001, 1006, 1005, 1012, 1013, 1014 // Bad Gateway\n  ].includes(code)) return false;\n  // all other internal errors are fatal\n  return code >= 1000 && code <= 1999;\n}\nfunction isWebSocket(val) {\n  return typeof val === 'function' && 'constructor' in val && 'CLOSED' in val && 'CLOSING' in val && 'CONNECTING' in val && 'OPEN' in val;\n}","map":{"version":3,"names":["__await","v","__asyncGenerator","thisArg","_arguments","generator","Symbol","asyncIterator","TypeError","g","apply","i","q","verb","n","Promise","a","b","push","resume","step","e","settle","r","value","resolve","then","fulfill","reject","f","shift","length","GRAPHQL_TRANSPORT_WS_PROTOCOL","CloseCode","MessageType","parseMessage","stringifyMessage","isObject","limitCloseReason","createClient","options","url","connectionParams","lazy","onNonLazyError","console","error","lazyCloseTimeout","lazyCloseTimeoutMs","keepAlive","disablePong","connectionAckWaitTimeout","retryAttempts","retryWait","_randomisedExponentialBackoff","_asyncToGenerator","retries","retryDelay","setTimeout","Math","floor","random","randomisedExponentialBackoff","_x","arguments","shouldRetry","isLikeCloseEvent","isFatalConnectionProblem","on","webSocketImpl","generateID","generateUUID","replace","c","toString","jsonMessageReplacer","replacer","jsonMessageReviver","reviver","ws","isWebSocket","Error","WebSocket","global","MozWebSocket","window","WebSocketImpl","emitter","message","listeners","id","listener","emit","_a","call","connecting","opened","connected","ping","pong","closed","onMessage","event","l","splice","indexOf","args","errorOrClosed","cb","listening","err","forEach","unlisten","locks","retrying","disposed","connect","_connect","clearTimeout","socket","throwOnClose","denied","undefined","code","reason","connectionAckTimeout","queuedPing","enqueuePing","isFinite","readyState","OPEN","send","type","Ping","errOrEvent","TerminatedCloseEvent","close","onerror","onclose","onopen","payload","ConnectionInit","ConnectionAcknowledgementTimeout","InternalClientError","acknowledged","onmessage","data","Pong","ConnectionAck","_","BadResponse","CLOSING","release","released","race","complete","shouldRetryConnectOrThrow","errOrCloseEvent","isFatalInternalCloseCode","InternalServerError","BadRequest","Unauthorized","SubprotocolNotAcceptable","SubscriberAlreadyExists","TooManyInitialisationRequests","includes","subscribe","sink","done","errored","releaser","waitForReleaseOrThrowOnClose","Next","next","Complete","Subscribe","finally","catch","iterate","request","pending","deferred","dispose","val","iterator","iterator_1","throw","_ref3","_x2","return","terminate","constructor","name","wasClean"],"sources":["/Users/obiechina/Documents/ridy-flutter-full-taxi-solution 2/node_modules/graphql-ws/lib/client.mjs"],"sourcesContent":["/**\n *\n * client\n *\n */\nvar __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nimport { GRAPHQL_TRANSPORT_WS_PROTOCOL, CloseCode, MessageType, parseMessage, stringifyMessage, } from './common.mjs';\nimport { isObject, limitCloseReason } from './utils.mjs';\n/** This file is the entry point for browsers, re-export common elements. */\nexport * from './common.mjs';\n/**\n * Creates a disposable GraphQL over WebSocket client.\n *\n * @category Client\n */\nexport function createClient(options) {\n    const { url, connectionParams, lazy = true, onNonLazyError = console.error, lazyCloseTimeout: lazyCloseTimeoutMs = 0, keepAlive = 0, disablePong, connectionAckWaitTimeout = 0, retryAttempts = 5, retryWait = async function randomisedExponentialBackoff(retries) {\n        let retryDelay = 1000; // start with 1s delay\n        for (let i = 0; i < retries; i++) {\n            retryDelay *= 2;\n        }\n        await new Promise((resolve) => setTimeout(resolve, retryDelay +\n            // add random timeout from 300ms to 3s\n            Math.floor(Math.random() * (3000 - 300) + 300)));\n    }, shouldRetry = isLikeCloseEvent, isFatalConnectionProblem, on, webSocketImpl, \n    /**\n     * Generates a v4 UUID to be used as the ID using `Math`\n     * as the random number generator. Supply your own generator\n     * in case you need more uniqueness.\n     *\n     * Reference: https://gist.github.com/jed/982883\n     */\n    generateID = function generateUUID() {\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n            const r = (Math.random() * 16) | 0, v = c == 'x' ? r : (r & 0x3) | 0x8;\n            return v.toString(16);\n        });\n    }, jsonMessageReplacer: replacer, jsonMessageReviver: reviver, } = options;\n    let ws;\n    if (webSocketImpl) {\n        if (!isWebSocket(webSocketImpl)) {\n            throw new Error('Invalid WebSocket implementation provided');\n        }\n        ws = webSocketImpl;\n    }\n    else if (typeof WebSocket !== 'undefined') {\n        ws = WebSocket;\n    }\n    else if (typeof global !== 'undefined') {\n        ws =\n            global.WebSocket ||\n                // @ts-expect-error: Support more browsers\n                global.MozWebSocket;\n    }\n    else if (typeof window !== 'undefined') {\n        ws =\n            window.WebSocket ||\n                // @ts-expect-error: Support more browsers\n                window.MozWebSocket;\n    }\n    if (!ws)\n        throw new Error(\"WebSocket implementation missing; on Node you can `import WebSocket from 'ws';` and pass `webSocketImpl: WebSocket` to `createClient`\");\n    const WebSocketImpl = ws;\n    // websocket status emitter, subscriptions are handled differently\n    const emitter = (() => {\n        const message = (() => {\n            const listeners = {};\n            return {\n                on(id, listener) {\n                    listeners[id] = listener;\n                    return () => {\n                        delete listeners[id];\n                    };\n                },\n                emit(message) {\n                    var _a;\n                    if ('id' in message)\n                        (_a = listeners[message.id]) === null || _a === void 0 ? void 0 : _a.call(listeners, message);\n                },\n            };\n        })();\n        const listeners = {\n            connecting: (on === null || on === void 0 ? void 0 : on.connecting) ? [on.connecting] : [],\n            opened: (on === null || on === void 0 ? void 0 : on.opened) ? [on.opened] : [],\n            connected: (on === null || on === void 0 ? void 0 : on.connected) ? [on.connected] : [],\n            ping: (on === null || on === void 0 ? void 0 : on.ping) ? [on.ping] : [],\n            pong: (on === null || on === void 0 ? void 0 : on.pong) ? [on.pong] : [],\n            message: (on === null || on === void 0 ? void 0 : on.message) ? [message.emit, on.message] : [message.emit],\n            closed: (on === null || on === void 0 ? void 0 : on.closed) ? [on.closed] : [],\n            error: (on === null || on === void 0 ? void 0 : on.error) ? [on.error] : [],\n        };\n        return {\n            onMessage: message.on,\n            on(event, listener) {\n                const l = listeners[event];\n                l.push(listener);\n                return () => {\n                    l.splice(l.indexOf(listener), 1);\n                };\n            },\n            emit(event, ...args) {\n                // we copy the listeners so that unlistens dont \"pull the rug under our feet\"\n                for (const listener of [...listeners[event]]) {\n                    // @ts-expect-error: The args should fit\n                    listener(...args);\n                }\n            },\n        };\n    })();\n    // invokes the callback either when an error or closed event is emitted,\n    // first one that gets called prevails, other emissions are ignored\n    function errorOrClosed(cb) {\n        const listening = [\n            // errors are fatal and more critical than close events, throw them first\n            emitter.on('error', (err) => {\n                listening.forEach((unlisten) => unlisten());\n                cb(err);\n            }),\n            // closes can be graceful and not fatal, throw them second (if error didnt throw)\n            emitter.on('closed', (event) => {\n                listening.forEach((unlisten) => unlisten());\n                cb(event);\n            }),\n        ];\n    }\n    let connecting, locks = 0, lazyCloseTimeout, retrying = false, retries = 0, disposed = false;\n    async function connect() {\n        // clear the lazy close timeout immediatelly so that close gets debounced\n        // see: https://github.com/enisdenjo/graphql-ws/issues/388\n        clearTimeout(lazyCloseTimeout);\n        const [socket, throwOnClose] = await (connecting !== null && connecting !== void 0 ? connecting : (connecting = new Promise((connected, denied) => (async () => {\n            if (retrying) {\n                await retryWait(retries);\n                // subscriptions might complete while waiting for retry\n                if (!locks) {\n                    connecting = undefined;\n                    return denied({ code: 1000, reason: 'All Subscriptions Gone' });\n                }\n                retries++;\n            }\n            emitter.emit('connecting', retrying);\n            const socket = new WebSocketImpl(typeof url === 'function' ? await url() : url, GRAPHQL_TRANSPORT_WS_PROTOCOL);\n            let connectionAckTimeout, queuedPing;\n            function enqueuePing() {\n                if (isFinite(keepAlive) && keepAlive > 0) {\n                    clearTimeout(queuedPing); // in case where a pong was received before a ping (this is valid behaviour)\n                    queuedPing = setTimeout(() => {\n                        if (socket.readyState === WebSocketImpl.OPEN) {\n                            socket.send(stringifyMessage({ type: MessageType.Ping }));\n                            emitter.emit('ping', false, undefined);\n                        }\n                    }, keepAlive);\n                }\n            }\n            errorOrClosed((errOrEvent) => {\n                connecting = undefined;\n                clearTimeout(connectionAckTimeout);\n                clearTimeout(queuedPing);\n                denied(errOrEvent);\n                if (errOrEvent instanceof TerminatedCloseEvent) {\n                    socket.close(4499, 'Terminated'); // close event is artificial and emitted manually, see `Client.terminate()` below\n                    socket.onerror = null;\n                    socket.onclose = null;\n                }\n            });\n            socket.onerror = (err) => emitter.emit('error', err);\n            socket.onclose = (event) => emitter.emit('closed', event);\n            socket.onopen = async () => {\n                try {\n                    emitter.emit('opened', socket);\n                    const payload = typeof connectionParams === 'function'\n                        ? await connectionParams()\n                        : connectionParams;\n                    // connectionParams might take too long causing the server to kick off the client\n                    // the necessary error/close event is already reported - simply stop execution\n                    if (socket.readyState !== WebSocketImpl.OPEN)\n                        return;\n                    socket.send(stringifyMessage(payload\n                        ? {\n                            type: MessageType.ConnectionInit,\n                            payload,\n                        }\n                        : {\n                            type: MessageType.ConnectionInit,\n                            // payload is completely absent if not provided\n                        }, replacer));\n                    if (isFinite(connectionAckWaitTimeout) &&\n                        connectionAckWaitTimeout > 0) {\n                        connectionAckTimeout = setTimeout(() => {\n                            socket.close(CloseCode.ConnectionAcknowledgementTimeout, 'Connection acknowledgement timeout');\n                        }, connectionAckWaitTimeout);\n                    }\n                    enqueuePing(); // enqueue ping (noop if disabled)\n                }\n                catch (err) {\n                    emitter.emit('error', err);\n                    socket.close(CloseCode.InternalClientError, limitCloseReason(err instanceof Error ? err.message : new Error(err).message, 'Internal client error'));\n                }\n            };\n            let acknowledged = false;\n            socket.onmessage = ({ data }) => {\n                try {\n                    const message = parseMessage(data, reviver);\n                    emitter.emit('message', message);\n                    if (message.type === 'ping' || message.type === 'pong') {\n                        emitter.emit(message.type, true, message.payload); // received\n                        if (message.type === 'pong') {\n                            enqueuePing(); // enqueue next ping (noop if disabled)\n                        }\n                        else if (!disablePong) {\n                            // respond with pong on ping\n                            socket.send(stringifyMessage(message.payload\n                                ? {\n                                    type: MessageType.Pong,\n                                    payload: message.payload,\n                                }\n                                : {\n                                    type: MessageType.Pong,\n                                    // payload is completely absent if not provided\n                                }));\n                            emitter.emit('pong', false, message.payload);\n                        }\n                        return; // ping and pongs can be received whenever\n                    }\n                    if (acknowledged)\n                        return; // already connected and acknowledged\n                    if (message.type !== MessageType.ConnectionAck)\n                        throw new Error(`First message cannot be of type ${message.type}`);\n                    clearTimeout(connectionAckTimeout);\n                    acknowledged = true;\n                    emitter.emit('connected', socket, message.payload, retrying); // connected = socket opened + acknowledged\n                    retrying = false; // future lazy connects are not retries\n                    retries = 0; // reset the retries on connect\n                    connected([\n                        socket,\n                        new Promise((_, reject) => errorOrClosed(reject)),\n                    ]);\n                }\n                catch (err) {\n                    socket.onmessage = null; // stop reading messages as soon as reading breaks once\n                    emitter.emit('error', err);\n                    socket.close(CloseCode.BadResponse, limitCloseReason(err instanceof Error ? err.message : new Error(err).message, 'Bad response'));\n                }\n            };\n        })())));\n        // if the provided socket is in a closing state, wait for the throw on close\n        if (socket.readyState === WebSocketImpl.CLOSING)\n            await throwOnClose;\n        let release = () => {\n            // releases this connection\n        };\n        const released = new Promise((resolve) => (release = resolve));\n        return [\n            socket,\n            release,\n            Promise.race([\n                // wait for\n                released.then(() => {\n                    if (!locks) {\n                        // and if no more locks are present, complete the connection\n                        const complete = () => socket.close(1000, 'Normal Closure');\n                        if (isFinite(lazyCloseTimeoutMs) && lazyCloseTimeoutMs > 0) {\n                            // if the keepalive is set, allow for the specified calmdown time and\n                            // then complete if the socket is still open.\n                            lazyCloseTimeout = setTimeout(() => {\n                                if (socket.readyState === WebSocketImpl.OPEN)\n                                    complete();\n                            }, lazyCloseTimeoutMs);\n                        }\n                        else {\n                            // otherwise complete immediately\n                            complete();\n                        }\n                    }\n                }),\n                // or\n                throwOnClose,\n            ]),\n        ];\n    }\n    /**\n     * Checks the `connect` problem and evaluates if the client should retry.\n     */\n    function shouldRetryConnectOrThrow(errOrCloseEvent) {\n        // some close codes are worth reporting immediately\n        if (isLikeCloseEvent(errOrCloseEvent) &&\n            (isFatalInternalCloseCode(errOrCloseEvent.code) ||\n                [\n                    CloseCode.InternalServerError,\n                    CloseCode.InternalClientError,\n                    CloseCode.BadRequest,\n                    CloseCode.BadResponse,\n                    CloseCode.Unauthorized,\n                    // CloseCode.Forbidden, might grant access out after retry\n                    CloseCode.SubprotocolNotAcceptable,\n                    // CloseCode.ConnectionInitialisationTimeout, might not time out after retry\n                    // CloseCode.ConnectionAcknowledgementTimeout, might not time out after retry\n                    CloseCode.SubscriberAlreadyExists,\n                    CloseCode.TooManyInitialisationRequests,\n                    // 4499, // Terminated, probably because the socket froze, we want to retry\n                ].includes(errOrCloseEvent.code)))\n            throw errOrCloseEvent;\n        // client was disposed, no retries should proceed regardless\n        if (disposed)\n            return false;\n        // normal closure (possibly all subscriptions have completed)\n        // if no locks were acquired in the meantime, shouldnt try again\n        if (isLikeCloseEvent(errOrCloseEvent) && errOrCloseEvent.code === 1000)\n            return locks > 0;\n        // retries are not allowed or we tried to many times, report error\n        if (!retryAttempts || retries >= retryAttempts)\n            throw errOrCloseEvent;\n        // throw non-retryable connection problems\n        if (!shouldRetry(errOrCloseEvent))\n            throw errOrCloseEvent;\n        // @deprecated throw fatal connection problems immediately\n        if (isFatalConnectionProblem === null || isFatalConnectionProblem === void 0 ? void 0 : isFatalConnectionProblem(errOrCloseEvent))\n            throw errOrCloseEvent;\n        // looks good, start retrying\n        return (retrying = true);\n    }\n    // in non-lazy (hot?) mode always hold one connection lock to persist the socket\n    if (!lazy) {\n        (async () => {\n            locks++;\n            for (;;) {\n                try {\n                    const [, , throwOnClose] = await connect();\n                    await throwOnClose; // will always throw because releaser is not used\n                }\n                catch (errOrCloseEvent) {\n                    try {\n                        if (!shouldRetryConnectOrThrow(errOrCloseEvent))\n                            return;\n                    }\n                    catch (errOrCloseEvent) {\n                        // report thrown error, no further retries\n                        return onNonLazyError === null || onNonLazyError === void 0 ? void 0 : onNonLazyError(errOrCloseEvent);\n                    }\n                }\n            }\n        })();\n    }\n    function subscribe(payload, sink) {\n        const id = generateID(payload);\n        let done = false, errored = false, releaser = () => {\n            // for handling completions before connect\n            locks--;\n            done = true;\n        };\n        (async () => {\n            locks++;\n            for (;;) {\n                try {\n                    const [socket, release, waitForReleaseOrThrowOnClose] = await connect();\n                    // if done while waiting for connect, release the connection lock right away\n                    if (done)\n                        return release();\n                    const unlisten = emitter.onMessage(id, (message) => {\n                        switch (message.type) {\n                            case MessageType.Next: {\n                                // eslint-disable-next-line @typescript-eslint/no-explicit-any -- payload will fit type\n                                sink.next(message.payload);\n                                return;\n                            }\n                            case MessageType.Error: {\n                                (errored = true), (done = true);\n                                sink.error(message.payload);\n                                releaser();\n                                return;\n                            }\n                            case MessageType.Complete: {\n                                done = true;\n                                releaser(); // release completes the sink\n                                return;\n                            }\n                        }\n                    });\n                    socket.send(stringifyMessage({\n                        id,\n                        type: MessageType.Subscribe,\n                        payload,\n                    }, replacer));\n                    releaser = () => {\n                        if (!done && socket.readyState === WebSocketImpl.OPEN)\n                            // if not completed already and socket is open, send complete message to server on release\n                            socket.send(stringifyMessage({\n                                id,\n                                type: MessageType.Complete,\n                            }, replacer));\n                        locks--;\n                        done = true;\n                        release();\n                    };\n                    // either the releaser will be called, connection completed and\n                    // the promise resolved or the socket closed and the promise rejected.\n                    // whatever happens though, we want to stop listening for messages\n                    await waitForReleaseOrThrowOnClose.finally(unlisten);\n                    return; // completed, shouldnt try again\n                }\n                catch (errOrCloseEvent) {\n                    if (!shouldRetryConnectOrThrow(errOrCloseEvent))\n                        return;\n                }\n            }\n        })()\n            .then(() => {\n            // delivering either an error or a complete terminates the sequence\n            if (!errored)\n                sink.complete();\n        }) // resolves on release or normal closure\n            .catch((err) => {\n            sink.error(err);\n        }); // rejects on close events and errors\n        return () => {\n            // dispose only of active subscriptions\n            if (!done)\n                releaser();\n        };\n    }\n    return {\n        on: emitter.on,\n        subscribe,\n        iterate(request) {\n            const pending = [];\n            const deferred = {\n                done: false,\n                error: null,\n                resolve: () => {\n                    // noop\n                },\n            };\n            const dispose = subscribe(request, {\n                next(val) {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    pending.push(val);\n                    deferred.resolve();\n                },\n                error(err) {\n                    deferred.done = true;\n                    deferred.error = err;\n                    deferred.resolve();\n                },\n                complete() {\n                    deferred.done = true;\n                    deferred.resolve();\n                },\n            });\n            const iterator = (function iterator() {\n                return __asyncGenerator(this, arguments, function* iterator_1() {\n                    for (;;) {\n                        if (!pending.length) {\n                            // only wait if there are no pending messages available\n                            yield __await(new Promise((resolve) => (deferred.resolve = resolve)));\n                        }\n                        // first flush\n                        while (pending.length) {\n                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                            yield yield __await(pending.shift());\n                        }\n                        // then error\n                        if (deferred.error) {\n                            throw deferred.error;\n                        }\n                        // or complete\n                        if (deferred.done) {\n                            return yield __await(void 0);\n                        }\n                    }\n                });\n            })();\n            iterator.throw = async (err) => {\n                if (!deferred.done) {\n                    deferred.done = true;\n                    deferred.error = err;\n                    deferred.resolve();\n                }\n                return { done: true, value: undefined };\n            };\n            iterator.return = async () => {\n                dispose();\n                return { done: true, value: undefined };\n            };\n            return iterator;\n        },\n        async dispose() {\n            disposed = true;\n            if (connecting) {\n                // if there is a connection, close it\n                const [socket] = await connecting;\n                socket.close(1000, 'Normal Closure');\n            }\n        },\n        terminate() {\n            if (connecting) {\n                // only if there is a connection\n                emitter.emit('closed', new TerminatedCloseEvent());\n            }\n        },\n    };\n}\n/**\n * A syntetic close event `4499: Terminated` is issued to the current to immediately\n * close the connection without waiting for the one coming from `WebSocket.onclose`.\n *\n * Terminating is not considered fatal and a connection retry will occur as expected.\n *\n * Useful in cases where the WebSocket is stuck and not emitting any events;\n * can happen on iOS Safari, see: https://github.com/enisdenjo/graphql-ws/discussions/290.\n */\nexport class TerminatedCloseEvent extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'TerminatedCloseEvent';\n        this.message = '4499: Terminated';\n        this.code = 4499;\n        this.reason = 'Terminated';\n        this.wasClean = false;\n    }\n}\nfunction isLikeCloseEvent(val) {\n    return isObject(val) && 'code' in val && 'reason' in val;\n}\nfunction isFatalInternalCloseCode(code) {\n    if ([\n        1000,\n        1001,\n        1006,\n        1005,\n        1012,\n        1013,\n        1014, // Bad Gateway\n    ].includes(code))\n        return false;\n    // all other internal errors are fatal\n    return code >= 1000 && code <= 1999;\n}\nfunction isWebSocket(val) {\n    return (typeof val === 'function' &&\n        'constructor' in val &&\n        'CLOSED' in val &&\n        'CLOSING' in val &&\n        'CONNECTING' in val &&\n        'OPEN' in val);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}