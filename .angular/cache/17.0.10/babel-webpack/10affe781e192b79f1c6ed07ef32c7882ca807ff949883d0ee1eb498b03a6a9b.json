{"ast":null,"code":"/**\n * 碰撞检测算法\n */\nexport function antiCollision(items, labelHeight, plotRange) {\n  var labels = items.filter(function (item) {\n    return !item.invisible;\n  });\n  // sorted by y, mutable\n  labels.sort(function (a, b) {\n    return a.y - b.y;\n  });\n  // adjust y position of labels to avoid overlapping\n  var overlapping = true;\n  var startY = plotRange.minY;\n  var endY = plotRange.maxY;\n  var totalHeight = Math.abs(startY - endY);\n  var i;\n  var maxY = 0;\n  var minY = Number.MIN_VALUE;\n  var boxes = labels.map(function (label) {\n    if (label.y > maxY) {\n      maxY = label.y;\n    }\n    if (label.y < minY) {\n      minY = label.y;\n    }\n    return {\n      content: label.content,\n      size: labelHeight,\n      targets: [label.y - startY],\n      pos: null\n    };\n  });\n  minY -= startY;\n  if (maxY - startY > totalHeight) {\n    totalHeight = maxY - startY;\n  }\n  while (overlapping) {\n    /* eslint no-loop-func: 0 */\n    boxes.forEach(function (box) {\n      var target = (Math.min.apply(minY, box.targets) + Math.max.apply(minY, box.targets)) / 2;\n      box.pos = Math.min(Math.max(minY, target - box.size / 2), totalHeight - box.size);\n      box.pos = Math.max(0, box.pos);\n    });\n    // detect overlapping and join boxes\n    overlapping = false;\n    i = boxes.length;\n    while (i--) {\n      if (i > 0) {\n        var previousBox = boxes[i - 1];\n        var box = boxes[i];\n        if (previousBox.pos + previousBox.size > box.pos) {\n          // overlapping\n          previousBox.size += box.size;\n          previousBox.targets = previousBox.targets.concat(box.targets);\n          // overflow, shift up\n          if (previousBox.pos + previousBox.size > totalHeight) {\n            previousBox.pos = totalHeight - previousBox.size;\n          }\n          boxes.splice(i, 1); // removing box\n          overlapping = true;\n        }\n      }\n    }\n  }\n  i = 0;\n  // step 4: normalize y and adjust x\n  boxes.forEach(function (b) {\n    var posInCompositeBox = startY + labelHeight / 2; // middle of the label\n    b.targets.forEach(function () {\n      labels[i].y = b.pos + posInCompositeBox;\n      posInCompositeBox += labelHeight;\n      i++;\n    });\n  });\n}","map":{"version":3,"names":["antiCollision","items","labelHeight","plotRange","labels","filter","item","invisible","sort","a","b","y","overlapping","startY","minY","endY","maxY","totalHeight","Math","abs","i","Number","MIN_VALUE","boxes","map","label","content","size","targets","pos","forEach","box","target","min","apply","max","length","previousBox","concat","splice","posInCompositeBox"],"sources":["/Users/obiechina/Documents/ridy-flutter-full-taxi-solution 2/node_modules/@antv/g2/esm/geometry/label/layout/pie/util.js"],"sourcesContent":["/**\n * 碰撞检测算法\n */\nexport function antiCollision(items, labelHeight, plotRange) {\n    var labels = items.filter(function (item) { return !item.invisible; });\n    // sorted by y, mutable\n    labels.sort(function (a, b) { return a.y - b.y; });\n    // adjust y position of labels to avoid overlapping\n    var overlapping = true;\n    var startY = plotRange.minY;\n    var endY = plotRange.maxY;\n    var totalHeight = Math.abs(startY - endY);\n    var i;\n    var maxY = 0;\n    var minY = Number.MIN_VALUE;\n    var boxes = labels.map(function (label) {\n        if (label.y > maxY) {\n            maxY = label.y;\n        }\n        if (label.y < minY) {\n            minY = label.y;\n        }\n        return {\n            content: label.content,\n            size: labelHeight,\n            targets: [label.y - startY],\n            pos: null,\n        };\n    });\n    minY -= startY;\n    if (maxY - startY > totalHeight) {\n        totalHeight = maxY - startY;\n    }\n    while (overlapping) {\n        /* eslint no-loop-func: 0 */\n        boxes.forEach(function (box) {\n            var target = (Math.min.apply(minY, box.targets) + Math.max.apply(minY, box.targets)) / 2;\n            box.pos = Math.min(Math.max(minY, target - box.size / 2), totalHeight - box.size);\n            box.pos = Math.max(0, box.pos);\n        });\n        // detect overlapping and join boxes\n        overlapping = false;\n        i = boxes.length;\n        while (i--) {\n            if (i > 0) {\n                var previousBox = boxes[i - 1];\n                var box = boxes[i];\n                if (previousBox.pos + previousBox.size > box.pos) {\n                    // overlapping\n                    previousBox.size += box.size;\n                    previousBox.targets = previousBox.targets.concat(box.targets);\n                    // overflow, shift up\n                    if (previousBox.pos + previousBox.size > totalHeight) {\n                        previousBox.pos = totalHeight - previousBox.size;\n                    }\n                    boxes.splice(i, 1); // removing box\n                    overlapping = true;\n                }\n            }\n        }\n    }\n    i = 0;\n    // step 4: normalize y and adjust x\n    boxes.forEach(function (b) {\n        var posInCompositeBox = startY + labelHeight / 2; // middle of the label\n        b.targets.forEach(function () {\n            labels[i].y = b.pos + posInCompositeBox;\n            posInCompositeBox += labelHeight;\n            i++;\n        });\n    });\n}\n"],"mappings":"AAAA;AACA;AACA;AACA,OAAO,SAASA,aAAaA,CAACC,KAAK,EAAEC,WAAW,EAAEC,SAAS,EAAE;EACzD,IAAIC,MAAM,GAAGH,KAAK,CAACI,MAAM,CAAC,UAAUC,IAAI,EAAE;IAAE,OAAO,CAACA,IAAI,CAACC,SAAS;EAAE,CAAC,CAAC;EACtE;EACAH,MAAM,CAACI,IAAI,CAAC,UAAUC,CAAC,EAAEC,CAAC,EAAE;IAAE,OAAOD,CAAC,CAACE,CAAC,GAAGD,CAAC,CAACC,CAAC;EAAE,CAAC,CAAC;EAClD;EACA,IAAIC,WAAW,GAAG,IAAI;EACtB,IAAIC,MAAM,GAAGV,SAAS,CAACW,IAAI;EAC3B,IAAIC,IAAI,GAAGZ,SAAS,CAACa,IAAI;EACzB,IAAIC,WAAW,GAAGC,IAAI,CAACC,GAAG,CAACN,MAAM,GAAGE,IAAI,CAAC;EACzC,IAAIK,CAAC;EACL,IAAIJ,IAAI,GAAG,CAAC;EACZ,IAAIF,IAAI,GAAGO,MAAM,CAACC,SAAS;EAC3B,IAAIC,KAAK,GAAGnB,MAAM,CAACoB,GAAG,CAAC,UAAUC,KAAK,EAAE;IACpC,IAAIA,KAAK,CAACd,CAAC,GAAGK,IAAI,EAAE;MAChBA,IAAI,GAAGS,KAAK,CAACd,CAAC;IAClB;IACA,IAAIc,KAAK,CAACd,CAAC,GAAGG,IAAI,EAAE;MAChBA,IAAI,GAAGW,KAAK,CAACd,CAAC;IAClB;IACA,OAAO;MACHe,OAAO,EAAED,KAAK,CAACC,OAAO;MACtBC,IAAI,EAAEzB,WAAW;MACjB0B,OAAO,EAAE,CAACH,KAAK,CAACd,CAAC,GAAGE,MAAM,CAAC;MAC3BgB,GAAG,EAAE;IACT,CAAC;EACL,CAAC,CAAC;EACFf,IAAI,IAAID,MAAM;EACd,IAAIG,IAAI,GAAGH,MAAM,GAAGI,WAAW,EAAE;IAC7BA,WAAW,GAAGD,IAAI,GAAGH,MAAM;EAC/B;EACA,OAAOD,WAAW,EAAE;IAChB;IACAW,KAAK,CAACO,OAAO,CAAC,UAAUC,GAAG,EAAE;MACzB,IAAIC,MAAM,GAAG,CAACd,IAAI,CAACe,GAAG,CAACC,KAAK,CAACpB,IAAI,EAAEiB,GAAG,CAACH,OAAO,CAAC,GAAGV,IAAI,CAACiB,GAAG,CAACD,KAAK,CAACpB,IAAI,EAAEiB,GAAG,CAACH,OAAO,CAAC,IAAI,CAAC;MACxFG,GAAG,CAACF,GAAG,GAAGX,IAAI,CAACe,GAAG,CAACf,IAAI,CAACiB,GAAG,CAACrB,IAAI,EAAEkB,MAAM,GAAGD,GAAG,CAACJ,IAAI,GAAG,CAAC,CAAC,EAAEV,WAAW,GAAGc,GAAG,CAACJ,IAAI,CAAC;MACjFI,GAAG,CAACF,GAAG,GAAGX,IAAI,CAACiB,GAAG,CAAC,CAAC,EAAEJ,GAAG,CAACF,GAAG,CAAC;IAClC,CAAC,CAAC;IACF;IACAjB,WAAW,GAAG,KAAK;IACnBQ,CAAC,GAAGG,KAAK,CAACa,MAAM;IAChB,OAAOhB,CAAC,EAAE,EAAE;MACR,IAAIA,CAAC,GAAG,CAAC,EAAE;QACP,IAAIiB,WAAW,GAAGd,KAAK,CAACH,CAAC,GAAG,CAAC,CAAC;QAC9B,IAAIW,GAAG,GAAGR,KAAK,CAACH,CAAC,CAAC;QAClB,IAAIiB,WAAW,CAACR,GAAG,GAAGQ,WAAW,CAACV,IAAI,GAAGI,GAAG,CAACF,GAAG,EAAE;UAC9C;UACAQ,WAAW,CAACV,IAAI,IAAII,GAAG,CAACJ,IAAI;UAC5BU,WAAW,CAACT,OAAO,GAAGS,WAAW,CAACT,OAAO,CAACU,MAAM,CAACP,GAAG,CAACH,OAAO,CAAC;UAC7D;UACA,IAAIS,WAAW,CAACR,GAAG,GAAGQ,WAAW,CAACV,IAAI,GAAGV,WAAW,EAAE;YAClDoB,WAAW,CAACR,GAAG,GAAGZ,WAAW,GAAGoB,WAAW,CAACV,IAAI;UACpD;UACAJ,KAAK,CAACgB,MAAM,CAACnB,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;UACpBR,WAAW,GAAG,IAAI;QACtB;MACJ;IACJ;EACJ;EACAQ,CAAC,GAAG,CAAC;EACL;EACAG,KAAK,CAACO,OAAO,CAAC,UAAUpB,CAAC,EAAE;IACvB,IAAI8B,iBAAiB,GAAG3B,MAAM,GAAGX,WAAW,GAAG,CAAC,CAAC,CAAC;IAClDQ,CAAC,CAACkB,OAAO,CAACE,OAAO,CAAC,YAAY;MAC1B1B,MAAM,CAACgB,CAAC,CAAC,CAACT,CAAC,GAAGD,CAAC,CAACmB,GAAG,GAAGW,iBAAiB;MACvCA,iBAAiB,IAAItC,WAAW;MAChCkB,CAAC,EAAE;IACP,CAAC,CAAC;EACN,CAAC,CAAC;AACN","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}