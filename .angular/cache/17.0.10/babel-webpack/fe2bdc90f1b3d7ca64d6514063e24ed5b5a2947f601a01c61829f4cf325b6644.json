{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { getCirclePoint } from '../util/util';\nimport CrosshairBase from './base';\nvar LineCrosshair = /** @class */function (_super) {\n  __extends(LineCrosshair, _super);\n  function LineCrosshair() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  LineCrosshair.prototype.getDefaultCfg = function () {\n    var cfg = _super.prototype.getDefaultCfg.call(this);\n    return __assign(__assign({}, cfg), {\n      type: 'circle',\n      locationType: 'circle',\n      center: null,\n      radius: 100,\n      startAngle: -Math.PI / 2,\n      endAngle: Math.PI * 3 / 2\n    });\n  };\n  LineCrosshair.prototype.getRotateAngle = function () {\n    var _a = this.getLocation(),\n      startAngle = _a.startAngle,\n      endAngle = _a.endAngle;\n    var position = this.get('text').position;\n    var tangentAngle = position === 'start' ? startAngle + Math.PI / 2 : endAngle - Math.PI / 2;\n    return tangentAngle;\n  };\n  LineCrosshair.prototype.getTextPoint = function () {\n    var text = this.get('text');\n    var position = text.position,\n      offset = text.offset;\n    var _a = this.getLocation(),\n      center = _a.center,\n      radius = _a.radius,\n      startAngle = _a.startAngle,\n      endAngle = _a.endAngle;\n    var angle = position === 'start' ? startAngle : endAngle;\n    var tangentAngle = this.getRotateAngle() - Math.PI;\n    var point = getCirclePoint(center, radius, angle);\n    // 这个地方其实应该求切线向量然后在乘以 offset，但是太啰嗦了，直接给出结果\n    // const tangent = [Math.cos(tangentAngle), Math.sin(tangentAngle)];\n    // const offsetVector = vec2.scale([], tangent, offset);\n    var offsetX = Math.cos(tangentAngle) * offset;\n    var offsetY = Math.sin(tangentAngle) * offset;\n    return {\n      x: point.x + offsetX,\n      y: point.y + offsetY\n    };\n  };\n  LineCrosshair.prototype.getLinePath = function () {\n    var _a = this.getLocation(),\n      center = _a.center,\n      radius = _a.radius,\n      startAngle = _a.startAngle,\n      endAngle = _a.endAngle;\n    var path = null;\n    if (endAngle - startAngle === Math.PI * 2) {\n      // 整圆\n      var x = center.x,\n        y = center.y;\n      path = [['M', x, y - radius], ['A', radius, radius, 0, 1, 1, x, y + radius], ['A', radius, radius, 0, 1, 1, x, y - radius], ['Z']];\n    } else {\n      var startPoint = getCirclePoint(center, radius, startAngle);\n      var endPoint = getCirclePoint(center, radius, endAngle);\n      var large = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;\n      var sweep = startAngle > endAngle ? 0 : 1;\n      path = [['M', startPoint.x, startPoint.y], ['A', radius, radius, 0, large, sweep, endPoint.x, endPoint.y]];\n    }\n    return path;\n  };\n  return LineCrosshair;\n}(CrosshairBase);\nexport default LineCrosshair;","map":{"version":3,"names":["__assign","__extends","getCirclePoint","CrosshairBase","LineCrosshair","_super","apply","arguments","prototype","getDefaultCfg","cfg","call","type","locationType","center","radius","startAngle","Math","PI","endAngle","getRotateAngle","_a","getLocation","position","get","tangentAngle","getTextPoint","text","offset","angle","point","offsetX","cos","offsetY","sin","x","y","getLinePath","path","startPoint","endPoint","large","abs","sweep"],"sources":["/Users/obiechina/Documents/ridy-flutter-full-taxi-solution 2/node_modules/@antv/component/esm/crosshair/circle.js"],"sourcesContent":["import { __assign, __extends } from \"tslib\";\nimport { getCirclePoint } from '../util/util';\nimport CrosshairBase from './base';\nvar LineCrosshair = /** @class */ (function (_super) {\n    __extends(LineCrosshair, _super);\n    function LineCrosshair() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    LineCrosshair.prototype.getDefaultCfg = function () {\n        var cfg = _super.prototype.getDefaultCfg.call(this);\n        return __assign(__assign({}, cfg), { type: 'circle', locationType: 'circle', center: null, radius: 100, startAngle: -Math.PI / 2, endAngle: (Math.PI * 3) / 2 });\n    };\n    LineCrosshair.prototype.getRotateAngle = function () {\n        var _a = this.getLocation(), startAngle = _a.startAngle, endAngle = _a.endAngle;\n        var position = this.get('text').position;\n        var tangentAngle = position === 'start' ? startAngle + Math.PI / 2 : endAngle - Math.PI / 2;\n        return tangentAngle;\n    };\n    LineCrosshair.prototype.getTextPoint = function () {\n        var text = this.get('text');\n        var position = text.position, offset = text.offset;\n        var _a = this.getLocation(), center = _a.center, radius = _a.radius, startAngle = _a.startAngle, endAngle = _a.endAngle;\n        var angle = position === 'start' ? startAngle : endAngle;\n        var tangentAngle = this.getRotateAngle() - Math.PI;\n        var point = getCirclePoint(center, radius, angle);\n        // 这个地方其实应该求切线向量然后在乘以 offset，但是太啰嗦了，直接给出结果\n        // const tangent = [Math.cos(tangentAngle), Math.sin(tangentAngle)];\n        // const offsetVector = vec2.scale([], tangent, offset);\n        var offsetX = Math.cos(tangentAngle) * offset;\n        var offsetY = Math.sin(tangentAngle) * offset;\n        return {\n            x: point.x + offsetX,\n            y: point.y + offsetY,\n        };\n    };\n    LineCrosshair.prototype.getLinePath = function () {\n        var _a = this.getLocation(), center = _a.center, radius = _a.radius, startAngle = _a.startAngle, endAngle = _a.endAngle;\n        var path = null;\n        if (endAngle - startAngle === Math.PI * 2) {\n            // 整圆\n            var x = center.x, y = center.y;\n            path = [\n                ['M', x, y - radius],\n                ['A', radius, radius, 0, 1, 1, x, y + radius],\n                ['A', radius, radius, 0, 1, 1, x, y - radius],\n                ['Z'],\n            ];\n        }\n        else {\n            var startPoint = getCirclePoint(center, radius, startAngle);\n            var endPoint = getCirclePoint(center, radius, endAngle);\n            var large = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;\n            var sweep = startAngle > endAngle ? 0 : 1;\n            path = [\n                ['M', startPoint.x, startPoint.y],\n                ['A', radius, radius, 0, large, sweep, endPoint.x, endPoint.y],\n            ];\n        }\n        return path;\n    };\n    return LineCrosshair;\n}(CrosshairBase));\nexport default LineCrosshair;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}