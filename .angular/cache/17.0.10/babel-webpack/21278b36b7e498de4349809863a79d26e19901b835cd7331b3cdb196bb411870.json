{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { get, deepMix, isArray } from '@antv/util';\nimport GeometryLabel from './base';\n/**\n * 柱状图 label\n */\nvar IntervalLabel = /** @class */function (_super) {\n  __extends(IntervalLabel, _super);\n  function IntervalLabel() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * 获取 interval label 的方向，取决于 value 的值是正还是负\n   * @param labelCfg\n   */\n  IntervalLabel.prototype.getLabelValueDir = function (mappingData) {\n    // points 中的 x/y 和 transpose 无关\n    var dim = 'y';\n    var points = mappingData.points;\n    return points[0][dim] <= points[2][dim] ? 1 : -1;\n  };\n  /**\n   * 重载：根据 interval 值的正负来调整 label 偏移量\n   * @param labelCfg\n   * @param index\n   * @param total\n   */\n  IntervalLabel.prototype.getLabelOffsetPoint = function (labelCfg, index, total, position) {\n    var _a;\n    var point = _super.prototype.getLabelOffsetPoint.call(this, labelCfg, index, total);\n    var coordinate = this.getCoordinate();\n    var transposed = coordinate.isTransposed;\n    var dim = transposed ? 'x' : 'y';\n    var dir = this.getLabelValueDir(labelCfg.mappingData);\n    point = __assign(__assign({}, point), (_a = {}, _a[dim] = point[dim] * dir, _a));\n    if (coordinate.isReflect('x')) {\n      point = __assign(__assign({}, point), {\n        x: point.x * -1\n      });\n    }\n    if (coordinate.isReflect('y')) {\n      point = __assign(__assign({}, point), {\n        y: point.y * -1\n      });\n    }\n    return point;\n  };\n  /**\n   * 重载：定制 interval label 的默认主题配置\n   * @param labelCfg\n   */\n  IntervalLabel.prototype.getThemedLabelCfg = function (labelCfg) {\n    var geometry = this.geometry;\n    var defaultLabelCfg = this.getDefaultLabelCfg();\n    var theme = geometry.theme;\n    // 如果 interval label position 设置为 middle，则将主题中的 offset 覆盖为 0\n    return deepMix({}, defaultLabelCfg, theme.labels, labelCfg.position === 'middle' ? {\n      offset: 0\n    } : {}, labelCfg);\n  };\n  IntervalLabel.prototype.setLabelPosition = function (labelPointCfg, mappingData, index, position) {\n    var coordinate = this.getCoordinate();\n    var transposed = coordinate.isTransposed;\n    var shapePoints = mappingData.points;\n    var point0 = coordinate.convert(shapePoints[0]);\n    var point2 = coordinate.convert(shapePoints[2]);\n    var dir = this.getLabelValueDir(mappingData);\n    var top;\n    var right;\n    var bottom;\n    var left;\n    var shape = isArray(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;\n    if (shape === 'funnel' || shape === 'pyramid') {\n      // 处理漏斗图\n      var nextPoints = get(mappingData, 'nextPoints');\n      var points = get(mappingData, 'points');\n      if (nextPoints) {\n        // 非漏斗图底部\n        var p0 = coordinate.convert(points[0]);\n        var p1 = coordinate.convert(points[1]);\n        var nextP0 = coordinate.convert(nextPoints[0]);\n        var nextP1 = coordinate.convert(nextPoints[1]);\n        // TODO: 使用包围盒的计算方法\n        if (transposed) {\n          top = Math.min(nextP0.y, p0.y);\n          bottom = Math.max(nextP0.y, p0.y);\n          right = (p1.x + nextP1.x) / 2;\n          left = (p0.x + nextP0.x) / 2;\n        } else {\n          top = Math.min((p1.y + nextP1.y) / 2, (p0.y + nextP0.y) / 2);\n          bottom = Math.max((p1.y + nextP1.y) / 2, (p0.y + nextP0.y) / 2);\n          right = nextP1.x;\n          left = p0.x;\n        }\n      } else {\n        top = Math.min(point2.y, point0.y);\n        bottom = Math.max(point2.y, point0.y);\n        right = point2.x;\n        left = point0.x;\n      }\n    } else {\n      top = Math.min(point2.y, point0.y);\n      bottom = Math.max(point2.y, point0.y);\n      right = point2.x;\n      left = point0.x;\n    }\n    switch (position) {\n      case 'right':\n        labelPointCfg.x = right;\n        labelPointCfg.y = (top + bottom) / 2;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', dir > 0 ? 'left' : 'right');\n        break;\n      case 'left':\n        labelPointCfg.x = left;\n        labelPointCfg.y = (top + bottom) / 2;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', dir > 0 ? 'left' : 'right');\n        break;\n      case 'bottom':\n        if (transposed) {\n          labelPointCfg.x = (right + left) / 2;\n        }\n        labelPointCfg.y = bottom;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', 'center');\n        labelPointCfg.textBaseline = get(labelPointCfg, 'textBaseline', dir > 0 ? 'bottom' : 'top');\n        break;\n      case 'middle':\n        if (transposed) {\n          labelPointCfg.x = (right + left) / 2;\n        }\n        labelPointCfg.y = (top + bottom) / 2;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', 'center');\n        labelPointCfg.textBaseline = get(labelPointCfg, 'textBaseline', 'middle');\n        break;\n      case 'top':\n        if (transposed) {\n          labelPointCfg.x = (right + left) / 2;\n        }\n        labelPointCfg.y = top;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', 'center');\n        labelPointCfg.textBaseline = get(labelPointCfg, 'textBaseline', dir > 0 ? 'bottom' : 'top');\n        break;\n      default:\n        break;\n    }\n  };\n  return IntervalLabel;\n}(GeometryLabel);\nexport default IntervalLabel;","map":{"version":3,"names":["__assign","__extends","get","deepMix","isArray","GeometryLabel","IntervalLabel","_super","apply","arguments","prototype","getLabelValueDir","mappingData","dim","points","getLabelOffsetPoint","labelCfg","index","total","position","_a","point","call","coordinate","getCoordinate","transposed","isTransposed","dir","isReflect","x","y","getThemedLabelCfg","geometry","defaultLabelCfg","getDefaultLabelCfg","theme","labels","offset","setLabelPosition","labelPointCfg","shapePoints","point0","convert","point2","top","right","bottom","left","shape","nextPoints","p0","p1","nextP0","nextP1","Math","min","max","textAlign","textBaseline"],"sources":["/Users/obiechina/Documents/ridy-flutter-full-taxi-solution 2/node_modules/@antv/g2/esm/geometry/label/interval.js"],"sourcesContent":["import { __assign, __extends } from \"tslib\";\nimport { get, deepMix, isArray } from '@antv/util';\nimport GeometryLabel from './base';\n/**\n * 柱状图 label\n */\nvar IntervalLabel = /** @class */ (function (_super) {\n    __extends(IntervalLabel, _super);\n    function IntervalLabel() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * 获取 interval label 的方向，取决于 value 的值是正还是负\n     * @param labelCfg\n     */\n    IntervalLabel.prototype.getLabelValueDir = function (mappingData) {\n        // points 中的 x/y 和 transpose 无关\n        var dim = 'y';\n        var points = mappingData.points;\n        return points[0][dim] <= points[2][dim] ? 1 : -1;\n    };\n    /**\n     * 重载：根据 interval 值的正负来调整 label 偏移量\n     * @param labelCfg\n     * @param index\n     * @param total\n     */\n    IntervalLabel.prototype.getLabelOffsetPoint = function (labelCfg, index, total, position) {\n        var _a;\n        var point = _super.prototype.getLabelOffsetPoint.call(this, labelCfg, index, total);\n        var coordinate = this.getCoordinate();\n        var transposed = coordinate.isTransposed;\n        var dim = transposed ? 'x' : 'y';\n        var dir = this.getLabelValueDir(labelCfg.mappingData);\n        point = __assign(__assign({}, point), (_a = {}, _a[dim] = point[dim] * dir, _a));\n        if (coordinate.isReflect('x')) {\n            point = __assign(__assign({}, point), { x: point.x * -1 });\n        }\n        if (coordinate.isReflect('y')) {\n            point = __assign(__assign({}, point), { y: point.y * -1 });\n        }\n        return point;\n    };\n    /**\n     * 重载：定制 interval label 的默认主题配置\n     * @param labelCfg\n     */\n    IntervalLabel.prototype.getThemedLabelCfg = function (labelCfg) {\n        var geometry = this.geometry;\n        var defaultLabelCfg = this.getDefaultLabelCfg();\n        var theme = geometry.theme;\n        // 如果 interval label position 设置为 middle，则将主题中的 offset 覆盖为 0\n        return deepMix({}, defaultLabelCfg, theme.labels, labelCfg.position === 'middle' ? { offset: 0 } : {}, labelCfg);\n    };\n    IntervalLabel.prototype.setLabelPosition = function (labelPointCfg, mappingData, index, position) {\n        var coordinate = this.getCoordinate();\n        var transposed = coordinate.isTransposed;\n        var shapePoints = mappingData.points;\n        var point0 = coordinate.convert(shapePoints[0]);\n        var point2 = coordinate.convert(shapePoints[2]);\n        var dir = this.getLabelValueDir(mappingData);\n        var top;\n        var right;\n        var bottom;\n        var left;\n        var shape = isArray(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;\n        if (shape === 'funnel' || shape === 'pyramid') {\n            // 处理漏斗图\n            var nextPoints = get(mappingData, 'nextPoints');\n            var points = get(mappingData, 'points');\n            if (nextPoints) {\n                // 非漏斗图底部\n                var p0 = coordinate.convert(points[0]);\n                var p1 = coordinate.convert(points[1]);\n                var nextP0 = coordinate.convert(nextPoints[0]);\n                var nextP1 = coordinate.convert(nextPoints[1]);\n                // TODO: 使用包围盒的计算方法\n                if (transposed) {\n                    top = Math.min(nextP0.y, p0.y);\n                    bottom = Math.max(nextP0.y, p0.y);\n                    right = (p1.x + nextP1.x) / 2;\n                    left = (p0.x + nextP0.x) / 2;\n                }\n                else {\n                    top = Math.min((p1.y + nextP1.y) / 2, (p0.y + nextP0.y) / 2);\n                    bottom = Math.max((p1.y + nextP1.y) / 2, (p0.y + nextP0.y) / 2);\n                    right = nextP1.x;\n                    left = p0.x;\n                }\n            }\n            else {\n                top = Math.min(point2.y, point0.y);\n                bottom = Math.max(point2.y, point0.y);\n                right = point2.x;\n                left = point0.x;\n            }\n        }\n        else {\n            top = Math.min(point2.y, point0.y);\n            bottom = Math.max(point2.y, point0.y);\n            right = point2.x;\n            left = point0.x;\n        }\n        switch (position) {\n            case 'right':\n                labelPointCfg.x = right;\n                labelPointCfg.y = (top + bottom) / 2;\n                labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', dir > 0 ? 'left' : 'right');\n                break;\n            case 'left':\n                labelPointCfg.x = left;\n                labelPointCfg.y = (top + bottom) / 2;\n                labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', dir > 0 ? 'left' : 'right');\n                break;\n            case 'bottom':\n                if (transposed) {\n                    labelPointCfg.x = (right + left) / 2;\n                }\n                labelPointCfg.y = bottom;\n                labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', 'center');\n                labelPointCfg.textBaseline = get(labelPointCfg, 'textBaseline', dir > 0 ? 'bottom' : 'top');\n                break;\n            case 'middle':\n                if (transposed) {\n                    labelPointCfg.x = (right + left) / 2;\n                }\n                labelPointCfg.y = (top + bottom) / 2;\n                labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', 'center');\n                labelPointCfg.textBaseline = get(labelPointCfg, 'textBaseline', 'middle');\n                break;\n            case 'top':\n                if (transposed) {\n                    labelPointCfg.x = (right + left) / 2;\n                }\n                labelPointCfg.y = top;\n                labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', 'center');\n                labelPointCfg.textBaseline = get(labelPointCfg, 'textBaseline', dir > 0 ? 'bottom' : 'top');\n                break;\n            default:\n                break;\n        }\n    };\n    return IntervalLabel;\n}(GeometryLabel));\nexport default IntervalLabel;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}