{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { each, isArray, isFunction, isString, debounce, throttle } from '@antv/util';\nimport { createAction, createCallbackAction } from './action/register';\nimport InteractionContext from './context';\nimport Interaction from './interaction';\n// 将字符串转换成 action\nexport function parseAction(actionStr, context, arg) {\n  var arr = actionStr.split(':');\n  var actionName = arr[0];\n  // 如果已经初始化过 action ，则直接引用之前的 action\n  var action = context.getAction(actionName) || createAction(actionName, context);\n  if (!action) {\n    throw new Error(\"There is no action named \".concat(actionName));\n  }\n  var methodName = arr[1];\n  return {\n    action: action,\n    methodName: methodName,\n    arg: arg\n  };\n}\n// 执行 Action\nfunction executeAction(actionObject) {\n  var action = actionObject.action,\n    methodName = actionObject.methodName,\n    arg = actionObject.arg;\n  if (action[methodName]) {\n    action[methodName](arg);\n  } else {\n    throw new Error(\"Action(\".concat(action.name, \") doesn't have a method called \").concat(methodName));\n  }\n}\nvar STEP_NAMES = {\n  START: 'start',\n  SHOW_ENABLE: 'showEnable',\n  END: 'end',\n  ROLLBACK: 'rollback',\n  PROCESSING: 'processing'\n};\n/**\n * 支持语法的交互类\n */\nvar GrammarInteraction = /** @class */function (_super) {\n  __extends(GrammarInteraction, _super);\n  function GrammarInteraction(view, steps) {\n    var _this = _super.call(this, view, steps) || this;\n    _this.callbackCaches = {};\n    // 某个触发和反馈在本环节是否执行或\n    _this.emitCaches = {};\n    _this.steps = steps;\n    return _this;\n  }\n  /**\n   * 初始化\n   */\n  GrammarInteraction.prototype.init = function () {\n    this.initContext();\n    _super.prototype.init.call(this);\n  };\n  /**\n   * 清理资源\n   */\n  GrammarInteraction.prototype.destroy = function () {\n    _super.prototype.destroy.call(this); // 先清理事件\n    this.steps = null;\n    if (this.context) {\n      this.context.destroy();\n      this.context = null;\n    }\n    this.callbackCaches = null;\n    this.view = null;\n  };\n  /**\n   * 绑定事件\n   */\n  GrammarInteraction.prototype.initEvents = function () {\n    var _this = this;\n    each(this.steps, function (stepArr, stepName) {\n      each(stepArr, function (step) {\n        var callback = _this.getActionCallback(stepName, step);\n        if (callback) {\n          // 如果存在 callback，才绑定，有时候会出现无 callback 的情况\n          _this.bindEvent(step.trigger, callback);\n        }\n      });\n    });\n  };\n  /**\n   * 清理绑定的事件\n   */\n  GrammarInteraction.prototype.clearEvents = function () {\n    var _this = this;\n    each(this.steps, function (stepArr, stepName) {\n      each(stepArr, function (step) {\n        var callback = _this.getActionCallback(stepName, step);\n        if (callback) {\n          _this.offEvent(step.trigger, callback);\n        }\n      });\n    });\n  };\n  // 初始化上下文，并初始化 action\n  GrammarInteraction.prototype.initContext = function () {\n    var view = this.view;\n    var context = new InteractionContext(view);\n    this.context = context;\n    var steps = this.steps;\n    // 生成具体的 Action\n    each(steps, function (subSteps) {\n      each(subSteps, function (step) {\n        if (isFunction(step.action)) {\n          // 如果传入回调函数，则直接生成 CallbackAction\n          step.actionObject = {\n            action: createCallbackAction(step.action, context),\n            methodName: 'execute'\n          };\n        } else if (isString(step.action)) {\n          // 如果是字符串\n          step.actionObject = parseAction(step.action, context, step.arg);\n        } else if (isArray(step.action)) {\n          // 如果是数组\n          var actionArr = step.action;\n          var argArr_1 = isArray(step.arg) ? step.arg : [step.arg];\n          step.actionObject = [];\n          each(actionArr, function (actionStr, idx) {\n            step.actionObject.push(parseAction(actionStr, context, argArr_1[idx]));\n          });\n        }\n        // 如果 action 既不是字符串，也不是函数，则不会生成 actionObject\n      });\n    });\n  };\n  // 是否允许指定阶段名称执行\n  GrammarInteraction.prototype.isAllowStep = function (stepName) {\n    var currentStepName = this.currentStepName;\n    var steps = this.steps;\n    // 相同的阶段允许同时执行\n    if (currentStepName === stepName) {\n      return true;\n    }\n    if (stepName === STEP_NAMES.SHOW_ENABLE) {\n      // 示能在整个过程中都可用\n      return true;\n    }\n    if (stepName === STEP_NAMES.PROCESSING) {\n      // 只有当前是 start 时，才允许 processing\n      return currentStepName === STEP_NAMES.START;\n    }\n    if (stepName === STEP_NAMES.START) {\n      // 如果当前是 processing，则无法 start，必须等待 end 后才能执行\n      return currentStepName !== STEP_NAMES.PROCESSING;\n    }\n    if (stepName === STEP_NAMES.END) {\n      return currentStepName === STEP_NAMES.PROCESSING || currentStepName === STEP_NAMES.START;\n    }\n    if (stepName === STEP_NAMES.ROLLBACK) {\n      if (steps[STEP_NAMES.END]) {\n        // 如果定义了 end, 只有 end 时才允许回滚\n        return currentStepName === STEP_NAMES.END;\n      } else if (currentStepName === STEP_NAMES.START) {\n        // 如果未定义 end, 则判断是否是开始\n        return true;\n      }\n    }\n    return false;\n  };\n  // 具体的指定阶段是否允许执行\n  GrammarInteraction.prototype.isAllowExecute = function (stepName, step) {\n    if (this.isAllowStep(stepName)) {\n      var key = this.getKey(stepName, step);\n      // 如果是在本环节内仅允许触发一次，同时已经触发过，则不允许再触发\n      if (step.once && this.emitCaches[key]) {\n        return false;\n      }\n      // 如果是允许的阶段，则验证 isEnable 方法\n      if (step.isEnable) {\n        return step.isEnable(this.context);\n      }\n      return true; // 如果没有 isEnable 则允许执行\n    }\n\n    return false;\n  };\n  GrammarInteraction.prototype.enterStep = function (stepName) {\n    this.currentStepName = stepName;\n    this.emitCaches = {}; // 清除所有本环节触发的缓存\n  };\n  // 执行完某个触发和反馈（子环节）\n  GrammarInteraction.prototype.afterExecute = function (stepName, step) {\n    // show enable 不计入正常的流程，其他情况则设置当前的 step\n    if (stepName !== STEP_NAMES.SHOW_ENABLE && this.currentStepName !== stepName) {\n      this.enterStep(stepName);\n    }\n    var key = this.getKey(stepName, step);\n    // 一旦执行，则缓存标记为，一直保持到跳出改环节\n    this.emitCaches[key] = true;\n  };\n  // 获取某个环节的唯一的键值\n  GrammarInteraction.prototype.getKey = function (stepName, step) {\n    return stepName + step.trigger + step.action;\n  };\n  // 获取 step 的回调函数，如果已经生成，则直接返回，如果未生成，则创建\n  GrammarInteraction.prototype.getActionCallback = function (stepName, step) {\n    var _this = this;\n    var context = this.context;\n    var callbackCaches = this.callbackCaches;\n    var actionObject = step.actionObject;\n    if (step.action && actionObject) {\n      var key = this.getKey(stepName, step);\n      if (!callbackCaches[key]) {\n        // 动态生成执行的方法，执行对应 action 的名称\n        var actionCallback = function (event) {\n          context.event = event; // 保证检测时的 event\n          if (_this.isAllowExecute(stepName, step)) {\n            // 如果是数组时，则依次执行\n            if (isArray(actionObject)) {\n              each(actionObject, function (obj) {\n                context.event = event; // 可能触发新的事件，保证执行前的 context.event 是正确的\n                executeAction(obj);\n              });\n            } else {\n              context.event = event; // 保证执行前的 context.event 是正确的\n              executeAction(actionObject);\n            }\n            _this.afterExecute(stepName, step);\n            if (step.callback) {\n              context.event = event; // 保证执行前的 context.event 是正确的\n              step.callback(context);\n            }\n          } else {\n            // 如果未通过验证，则事件不要绑定在上面\n            context.event = null;\n          }\n        };\n        // 如果设置了 debounce\n        if (step.debounce) {\n          callbackCaches[key] = debounce(actionCallback, step.debounce.wait, step.debounce.immediate);\n        } else if (step.throttle) {\n          // 设置 throttle\n          callbackCaches[key] = throttle(actionCallback, step.throttle.wait, {\n            leading: step.throttle.leading,\n            trailing: step.throttle.trailing\n          });\n        } else {\n          // 直接设置\n          callbackCaches[key] = actionCallback;\n        }\n      }\n      return callbackCaches[key];\n    }\n    return null;\n  };\n  GrammarInteraction.prototype.bindEvent = function (eventName, callback) {\n    var nameArr = eventName.split(':');\n    if (nameArr[0] === 'window') {\n      window.addEventListener(nameArr[1], callback);\n    } else if (nameArr[0] === 'document') {\n      document.addEventListener(nameArr[1], callback);\n    } else {\n      this.view.on(eventName, callback);\n    }\n  };\n  GrammarInteraction.prototype.offEvent = function (eventName, callback) {\n    var nameArr = eventName.split(':');\n    if (nameArr[0] === 'window') {\n      window.removeEventListener(nameArr[1], callback);\n    } else if (nameArr[0] === 'document') {\n      document.removeEventListener(nameArr[1], callback);\n    } else {\n      this.view.off(eventName, callback);\n    }\n  };\n  return GrammarInteraction;\n}(Interaction);\nexport default GrammarInteraction;","map":{"version":3,"names":["__extends","each","isArray","isFunction","isString","debounce","throttle","createAction","createCallbackAction","InteractionContext","Interaction","parseAction","actionStr","context","arg","arr","split","actionName","action","getAction","Error","concat","methodName","executeAction","actionObject","name","STEP_NAMES","START","SHOW_ENABLE","END","ROLLBACK","PROCESSING","GrammarInteraction","_super","view","steps","_this","call","callbackCaches","emitCaches","prototype","init","initContext","destroy","initEvents","stepArr","stepName","step","callback","getActionCallback","bindEvent","trigger","clearEvents","offEvent","subSteps","actionArr","argArr_1","idx","push","isAllowStep","currentStepName","isAllowExecute","key","getKey","once","isEnable","enterStep","afterExecute","actionCallback","event","obj","wait","immediate","leading","trailing","eventName","nameArr","window","addEventListener","document","on","removeEventListener","off"],"sources":["/Users/obiechina/Documents/ridy-flutter-full-taxi-solution 2/node_modules/@antv/g2/esm/interaction/grammar-interaction.js"],"sourcesContent":["import { __extends } from \"tslib\";\nimport { each, isArray, isFunction, isString, debounce, throttle } from '@antv/util';\nimport { createAction, createCallbackAction } from './action/register';\nimport InteractionContext from './context';\nimport Interaction from './interaction';\n// 将字符串转换成 action\nexport function parseAction(actionStr, context, arg) {\n    var arr = actionStr.split(':');\n    var actionName = arr[0];\n    // 如果已经初始化过 action ，则直接引用之前的 action\n    var action = context.getAction(actionName) || createAction(actionName, context);\n    if (!action) {\n        throw new Error(\"There is no action named \".concat(actionName));\n    }\n    var methodName = arr[1];\n    return {\n        action: action,\n        methodName: methodName,\n        arg: arg,\n    };\n}\n// 执行 Action\nfunction executeAction(actionObject) {\n    var action = actionObject.action, methodName = actionObject.methodName, arg = actionObject.arg;\n    if (action[methodName]) {\n        action[methodName](arg);\n    }\n    else {\n        throw new Error(\"Action(\".concat(action.name, \") doesn't have a method called \").concat(methodName));\n    }\n}\nvar STEP_NAMES = {\n    START: 'start',\n    SHOW_ENABLE: 'showEnable',\n    END: 'end',\n    ROLLBACK: 'rollback',\n    PROCESSING: 'processing',\n};\n/**\n * 支持语法的交互类\n */\nvar GrammarInteraction = /** @class */ (function (_super) {\n    __extends(GrammarInteraction, _super);\n    function GrammarInteraction(view, steps) {\n        var _this = _super.call(this, view, steps) || this;\n        _this.callbackCaches = {};\n        // 某个触发和反馈在本环节是否执行或\n        _this.emitCaches = {};\n        _this.steps = steps;\n        return _this;\n    }\n    /**\n     * 初始化\n     */\n    GrammarInteraction.prototype.init = function () {\n        this.initContext();\n        _super.prototype.init.call(this);\n    };\n    /**\n     * 清理资源\n     */\n    GrammarInteraction.prototype.destroy = function () {\n        _super.prototype.destroy.call(this); // 先清理事件\n        this.steps = null;\n        if (this.context) {\n            this.context.destroy();\n            this.context = null;\n        }\n        this.callbackCaches = null;\n        this.view = null;\n    };\n    /**\n     * 绑定事件\n     */\n    GrammarInteraction.prototype.initEvents = function () {\n        var _this = this;\n        each(this.steps, function (stepArr, stepName) {\n            each(stepArr, function (step) {\n                var callback = _this.getActionCallback(stepName, step);\n                if (callback) {\n                    // 如果存在 callback，才绑定，有时候会出现无 callback 的情况\n                    _this.bindEvent(step.trigger, callback);\n                }\n            });\n        });\n    };\n    /**\n     * 清理绑定的事件\n     */\n    GrammarInteraction.prototype.clearEvents = function () {\n        var _this = this;\n        each(this.steps, function (stepArr, stepName) {\n            each(stepArr, function (step) {\n                var callback = _this.getActionCallback(stepName, step);\n                if (callback) {\n                    _this.offEvent(step.trigger, callback);\n                }\n            });\n        });\n    };\n    // 初始化上下文，并初始化 action\n    GrammarInteraction.prototype.initContext = function () {\n        var view = this.view;\n        var context = new InteractionContext(view);\n        this.context = context;\n        var steps = this.steps;\n        // 生成具体的 Action\n        each(steps, function (subSteps) {\n            each(subSteps, function (step) {\n                if (isFunction(step.action)) {\n                    // 如果传入回调函数，则直接生成 CallbackAction\n                    step.actionObject = {\n                        action: createCallbackAction(step.action, context),\n                        methodName: 'execute',\n                    };\n                }\n                else if (isString(step.action)) {\n                    // 如果是字符串\n                    step.actionObject = parseAction(step.action, context, step.arg);\n                }\n                else if (isArray(step.action)) {\n                    // 如果是数组\n                    var actionArr = step.action;\n                    var argArr_1 = isArray(step.arg) ? step.arg : [step.arg];\n                    step.actionObject = [];\n                    each(actionArr, function (actionStr, idx) {\n                        step.actionObject.push(parseAction(actionStr, context, argArr_1[idx]));\n                    });\n                }\n                // 如果 action 既不是字符串，也不是函数，则不会生成 actionObject\n            });\n        });\n    };\n    // 是否允许指定阶段名称执行\n    GrammarInteraction.prototype.isAllowStep = function (stepName) {\n        var currentStepName = this.currentStepName;\n        var steps = this.steps;\n        // 相同的阶段允许同时执行\n        if (currentStepName === stepName) {\n            return true;\n        }\n        if (stepName === STEP_NAMES.SHOW_ENABLE) {\n            // 示能在整个过程中都可用\n            return true;\n        }\n        if (stepName === STEP_NAMES.PROCESSING) {\n            // 只有当前是 start 时，才允许 processing\n            return currentStepName === STEP_NAMES.START;\n        }\n        if (stepName === STEP_NAMES.START) {\n            // 如果当前是 processing，则无法 start，必须等待 end 后才能执行\n            return currentStepName !== STEP_NAMES.PROCESSING;\n        }\n        if (stepName === STEP_NAMES.END) {\n            return currentStepName === STEP_NAMES.PROCESSING || currentStepName === STEP_NAMES.START;\n        }\n        if (stepName === STEP_NAMES.ROLLBACK) {\n            if (steps[STEP_NAMES.END]) {\n                // 如果定义了 end, 只有 end 时才允许回滚\n                return currentStepName === STEP_NAMES.END;\n            }\n            else if (currentStepName === STEP_NAMES.START) {\n                // 如果未定义 end, 则判断是否是开始\n                return true;\n            }\n        }\n        return false;\n    };\n    // 具体的指定阶段是否允许执行\n    GrammarInteraction.prototype.isAllowExecute = function (stepName, step) {\n        if (this.isAllowStep(stepName)) {\n            var key = this.getKey(stepName, step);\n            // 如果是在本环节内仅允许触发一次，同时已经触发过，则不允许再触发\n            if (step.once && this.emitCaches[key]) {\n                return false;\n            }\n            // 如果是允许的阶段，则验证 isEnable 方法\n            if (step.isEnable) {\n                return step.isEnable(this.context);\n            }\n            return true; // 如果没有 isEnable 则允许执行\n        }\n        return false;\n    };\n    GrammarInteraction.prototype.enterStep = function (stepName) {\n        this.currentStepName = stepName;\n        this.emitCaches = {}; // 清除所有本环节触发的缓存\n    };\n    // 执行完某个触发和反馈（子环节）\n    GrammarInteraction.prototype.afterExecute = function (stepName, step) {\n        // show enable 不计入正常的流程，其他情况则设置当前的 step\n        if (stepName !== STEP_NAMES.SHOW_ENABLE && this.currentStepName !== stepName) {\n            this.enterStep(stepName);\n        }\n        var key = this.getKey(stepName, step);\n        // 一旦执行，则缓存标记为，一直保持到跳出改环节\n        this.emitCaches[key] = true;\n    };\n    // 获取某个环节的唯一的键值\n    GrammarInteraction.prototype.getKey = function (stepName, step) {\n        return stepName + step.trigger + step.action;\n    };\n    // 获取 step 的回调函数，如果已经生成，则直接返回，如果未生成，则创建\n    GrammarInteraction.prototype.getActionCallback = function (stepName, step) {\n        var _this = this;\n        var context = this.context;\n        var callbackCaches = this.callbackCaches;\n        var actionObject = step.actionObject;\n        if (step.action && actionObject) {\n            var key = this.getKey(stepName, step);\n            if (!callbackCaches[key]) {\n                // 动态生成执行的方法，执行对应 action 的名称\n                var actionCallback = function (event) {\n                    context.event = event; // 保证检测时的 event\n                    if (_this.isAllowExecute(stepName, step)) {\n                        // 如果是数组时，则依次执行\n                        if (isArray(actionObject)) {\n                            each(actionObject, function (obj) {\n                                context.event = event; // 可能触发新的事件，保证执行前的 context.event 是正确的\n                                executeAction(obj);\n                            });\n                        }\n                        else {\n                            context.event = event; // 保证执行前的 context.event 是正确的\n                            executeAction(actionObject);\n                        }\n                        _this.afterExecute(stepName, step);\n                        if (step.callback) {\n                            context.event = event; // 保证执行前的 context.event 是正确的\n                            step.callback(context);\n                        }\n                    }\n                    else {\n                        // 如果未通过验证，则事件不要绑定在上面\n                        context.event = null;\n                    }\n                };\n                // 如果设置了 debounce\n                if (step.debounce) {\n                    callbackCaches[key] = debounce(actionCallback, step.debounce.wait, step.debounce.immediate);\n                }\n                else if (step.throttle) {\n                    // 设置 throttle\n                    callbackCaches[key] = throttle(actionCallback, step.throttle.wait, {\n                        leading: step.throttle.leading,\n                        trailing: step.throttle.trailing,\n                    });\n                }\n                else {\n                    // 直接设置\n                    callbackCaches[key] = actionCallback;\n                }\n            }\n            return callbackCaches[key];\n        }\n        return null;\n    };\n    GrammarInteraction.prototype.bindEvent = function (eventName, callback) {\n        var nameArr = eventName.split(':');\n        if (nameArr[0] === 'window') {\n            window.addEventListener(nameArr[1], callback);\n        }\n        else if (nameArr[0] === 'document') {\n            document.addEventListener(nameArr[1], callback);\n        }\n        else {\n            this.view.on(eventName, callback);\n        }\n    };\n    GrammarInteraction.prototype.offEvent = function (eventName, callback) {\n        var nameArr = eventName.split(':');\n        if (nameArr[0] === 'window') {\n            window.removeEventListener(nameArr[1], callback);\n        }\n        else if (nameArr[0] === 'document') {\n            document.removeEventListener(nameArr[1], callback);\n        }\n        else {\n            this.view.off(eventName, callback);\n        }\n    };\n    return GrammarInteraction;\n}(Interaction));\nexport default GrammarInteraction;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}