{"ast":null,"code":"import getArcParams from './get-arc-params';\nimport { isSamePoint } from './get-arc-params';\nimport parsePath from './parse-path';\n// 点对称\nfunction toSymmetry(point, center) {\n  return [center[0] + (center[0] - point[0]), center[1] + (center[1] - point[1])];\n}\nexport default function getSegments(path) {\n  path = parsePath(path);\n  var segments = [];\n  var currentPoint = null; // 当前图形\n  var nextParams = null; // 下一节点的 path 参数\n  var startMovePoint = null; // 开始 M 的点，可能会有多个\n  var lastStartMovePointIndex = 0; // 最近一个开始点 M 的索引\n  var count = path.length;\n  for (var i = 0; i < count; i++) {\n    var params = path[i];\n    nextParams = path[i + 1];\n    var command = params[0];\n    // 数学定义上的参数，便于后面的计算\n    var segment = {\n      command: command,\n      prePoint: currentPoint,\n      params: params,\n      startTangent: null,\n      endTangent: null\n    };\n    switch (command) {\n      case 'M':\n        startMovePoint = [params[1], params[2]];\n        lastStartMovePointIndex = i;\n        break;\n      case 'A':\n        var arcParams = getArcParams(currentPoint, params);\n        segment['arcParams'] = arcParams;\n        break;\n      default:\n        break;\n    }\n    if (command === 'Z') {\n      // 有了 Z 后，当前节点从开始 M 的点开始\n      currentPoint = startMovePoint;\n      // 如果当前点的命令为 Z，相当于当前点为最近一个 M 点，则下一个点直接指向最近一个 M 点的下一个点\n      nextParams = path[lastStartMovePointIndex + 1];\n    } else {\n      var len = params.length;\n      currentPoint = [params[len - 2], params[len - 1]];\n    }\n    if (nextParams && nextParams[0] === 'Z') {\n      // 如果下一个点的命令为 Z，则下一个点直接指向最近一个 M 点\n      nextParams = path[lastStartMovePointIndex];\n      if (segments[lastStartMovePointIndex]) {\n        // 如果下一个点的命令为 Z，则最近一个 M 点的前一个点为当前点\n        segments[lastStartMovePointIndex].prePoint = currentPoint;\n      }\n    }\n    segment['currentPoint'] = currentPoint;\n    // 如果当前点与最近一个 M 点相同，则最近一个 M 点的前一个点为当前点的前一个点\n    if (segments[lastStartMovePointIndex] && isSamePoint(currentPoint, segments[lastStartMovePointIndex].currentPoint)) {\n      segments[lastStartMovePointIndex].prePoint = segment.prePoint;\n    }\n    var nextPoint = nextParams ? [nextParams[nextParams.length - 2], nextParams[nextParams.length - 1]] : null;\n    segment['nextPoint'] = nextPoint;\n    // Add startTangent and endTangent\n    var prePoint = segment.prePoint;\n    if (['L', 'H', 'V'].includes(command)) {\n      segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];\n      segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];\n    } else if (command === 'Q') {\n      // 二次贝塞尔曲线只有一个控制点\n      var cp = [params[1], params[2]];\n      // 二次贝塞尔曲线的终点为 currentPoint\n      segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];\n      segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];\n    } else if (command === 'T') {\n      var preSegment = segments[i - 1];\n      var cp = toSymmetry(preSegment.currentPoint, prePoint);\n      if (preSegment.command === 'Q') {\n        segment.command = 'Q';\n        segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];\n        segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];\n      } else {\n        segment.command = 'TL';\n        segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];\n        segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];\n      }\n    } else if (command === 'C') {\n      // 三次贝塞尔曲线有两个控制点\n      var cp1 = [params[1], params[2]];\n      var cp2 = [params[3], params[4]];\n      segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];\n      segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];\n      // horizontal line, eg. ['C', 100, 100, 100, 100, 200, 200]\n      if (segment.startTangent[0] === 0 && segment.startTangent[1] === 0) {\n        segment.startTangent = [cp1[0] - cp2[0], cp1[1] - cp2[1]];\n      }\n      if (segment.endTangent[0] === 0 && segment.endTangent[1] === 0) {\n        segment.endTangent = [cp2[0] - cp1[0], cp2[1] - cp1[1]];\n      }\n    } else if (command === 'S') {\n      var preSegment = segments[i - 1];\n      var cp1 = toSymmetry(preSegment.currentPoint, prePoint);\n      var cp2 = [params[1], params[2]];\n      if (preSegment.command === 'C') {\n        segment.command = 'C'; // 将 S 命令变换为 C 命令\n        segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];\n        segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];\n      } else {\n        segment.command = 'SQ'; // 将 S 命令变换为 SQ 命令\n        segment.startTangent = [prePoint[0] - cp2[0], prePoint[1] - cp2[1]];\n        segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];\n      }\n    } else if (command === 'A') {\n      var d = 0.001;\n      var _a = segment['arcParams'] || {},\n        _b = _a.cx,\n        cx = _b === void 0 ? 0 : _b,\n        _c = _a.cy,\n        cy = _c === void 0 ? 0 : _c,\n        _d = _a.rx,\n        rx = _d === void 0 ? 0 : _d,\n        _e = _a.ry,\n        ry = _e === void 0 ? 0 : _e,\n        _f = _a.sweepFlag,\n        sweepFlag = _f === void 0 ? 0 : _f,\n        _g = _a.startAngle,\n        startAngle = _g === void 0 ? 0 : _g,\n        _h = _a.endAngle,\n        endAngle = _h === void 0 ? 0 : _h;\n      if (sweepFlag === 0) {\n        d *= -1;\n      }\n      var dx1 = rx * Math.cos(startAngle - d) + cx;\n      var dy1 = ry * Math.sin(startAngle - d) + cy;\n      segment.startTangent = [dx1 - startMovePoint[0], dy1 - startMovePoint[1]];\n      var dx2 = rx * Math.cos(startAngle + endAngle + d) + cx;\n      var dy2 = ry * Math.sin(startAngle + endAngle - d) + cy;\n      segment.endTangent = [prePoint[0] - dx2, prePoint[1] - dy2];\n    }\n    segments.push(segment);\n  }\n  return segments;\n}","map":{"version":3,"names":["getArcParams","isSamePoint","parsePath","toSymmetry","point","center","getSegments","path","segments","currentPoint","nextParams","startMovePoint","lastStartMovePointIndex","count","length","i","params","command","segment","prePoint","startTangent","endTangent","arcParams","len","nextPoint","includes","cp","preSegment","cp1","cp2","d","_a","_b","cx","_c","cy","_d","rx","_e","ry","_f","sweepFlag","_g","startAngle","_h","endAngle","dx1","Math","cos","dy1","sin","dx2","dy2","push"],"sources":["/Users/obiechina/Documents/ridy-flutter-full-taxi-solution 2/node_modules/@antv/path-util/esm/path-2-segments.js"],"sourcesContent":["import getArcParams from './get-arc-params';\nimport { isSamePoint } from './get-arc-params';\nimport parsePath from './parse-path';\n// 点对称\nfunction toSymmetry(point, center) {\n    return [center[0] + (center[0] - point[0]), center[1] + (center[1] - point[1])];\n}\nexport default function getSegments(path) {\n    path = parsePath(path);\n    var segments = [];\n    var currentPoint = null; // 当前图形\n    var nextParams = null; // 下一节点的 path 参数\n    var startMovePoint = null; // 开始 M 的点，可能会有多个\n    var lastStartMovePointIndex = 0; // 最近一个开始点 M 的索引\n    var count = path.length;\n    for (var i = 0; i < count; i++) {\n        var params = path[i];\n        nextParams = path[i + 1];\n        var command = params[0];\n        // 数学定义上的参数，便于后面的计算\n        var segment = {\n            command: command,\n            prePoint: currentPoint,\n            params: params,\n            startTangent: null,\n            endTangent: null,\n        };\n        switch (command) {\n            case 'M':\n                startMovePoint = [params[1], params[2]];\n                lastStartMovePointIndex = i;\n                break;\n            case 'A':\n                var arcParams = getArcParams(currentPoint, params);\n                segment['arcParams'] = arcParams;\n                break;\n            default:\n                break;\n        }\n        if (command === 'Z') {\n            // 有了 Z 后，当前节点从开始 M 的点开始\n            currentPoint = startMovePoint;\n            // 如果当前点的命令为 Z，相当于当前点为最近一个 M 点，则下一个点直接指向最近一个 M 点的下一个点\n            nextParams = path[lastStartMovePointIndex + 1];\n        }\n        else {\n            var len = params.length;\n            currentPoint = [params[len - 2], params[len - 1]];\n        }\n        if (nextParams && nextParams[0] === 'Z') {\n            // 如果下一个点的命令为 Z，则下一个点直接指向最近一个 M 点\n            nextParams = path[lastStartMovePointIndex];\n            if (segments[lastStartMovePointIndex]) {\n                // 如果下一个点的命令为 Z，则最近一个 M 点的前一个点为当前点\n                segments[lastStartMovePointIndex].prePoint = currentPoint;\n            }\n        }\n        segment['currentPoint'] = currentPoint;\n        // 如果当前点与最近一个 M 点相同，则最近一个 M 点的前一个点为当前点的前一个点\n        if (segments[lastStartMovePointIndex] &&\n            isSamePoint(currentPoint, segments[lastStartMovePointIndex].currentPoint)) {\n            segments[lastStartMovePointIndex].prePoint = segment.prePoint;\n        }\n        var nextPoint = nextParams ? [nextParams[nextParams.length - 2], nextParams[nextParams.length - 1]] : null;\n        segment['nextPoint'] = nextPoint;\n        // Add startTangent and endTangent\n        var prePoint = segment.prePoint;\n        if (['L', 'H', 'V'].includes(command)) {\n            segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];\n            segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];\n        }\n        else if (command === 'Q') {\n            // 二次贝塞尔曲线只有一个控制点\n            var cp = [params[1], params[2]];\n            // 二次贝塞尔曲线的终点为 currentPoint\n            segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];\n            segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];\n        }\n        else if (command === 'T') {\n            var preSegment = segments[i - 1];\n            var cp = toSymmetry(preSegment.currentPoint, prePoint);\n            if (preSegment.command === 'Q') {\n                segment.command = 'Q';\n                segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];\n                segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];\n            }\n            else {\n                segment.command = 'TL';\n                segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];\n                segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];\n            }\n        }\n        else if (command === 'C') {\n            // 三次贝塞尔曲线有两个控制点\n            var cp1 = [params[1], params[2]];\n            var cp2 = [params[3], params[4]];\n            segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];\n            segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];\n            // horizontal line, eg. ['C', 100, 100, 100, 100, 200, 200]\n            if (segment.startTangent[0] === 0 && segment.startTangent[1] === 0) {\n                segment.startTangent = [cp1[0] - cp2[0], cp1[1] - cp2[1]];\n            }\n            if (segment.endTangent[0] === 0 && segment.endTangent[1] === 0) {\n                segment.endTangent = [cp2[0] - cp1[0], cp2[1] - cp1[1]];\n            }\n        }\n        else if (command === 'S') {\n            var preSegment = segments[i - 1];\n            var cp1 = toSymmetry(preSegment.currentPoint, prePoint);\n            var cp2 = [params[1], params[2]];\n            if (preSegment.command === 'C') {\n                segment.command = 'C'; // 将 S 命令变换为 C 命令\n                segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];\n                segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];\n            }\n            else {\n                segment.command = 'SQ'; // 将 S 命令变换为 SQ 命令\n                segment.startTangent = [prePoint[0] - cp2[0], prePoint[1] - cp2[1]];\n                segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];\n            }\n        }\n        else if (command === 'A') {\n            var d = 0.001;\n            var _a = segment['arcParams'] || {}, _b = _a.cx, cx = _b === void 0 ? 0 : _b, _c = _a.cy, cy = _c === void 0 ? 0 : _c, _d = _a.rx, rx = _d === void 0 ? 0 : _d, _e = _a.ry, ry = _e === void 0 ? 0 : _e, _f = _a.sweepFlag, sweepFlag = _f === void 0 ? 0 : _f, _g = _a.startAngle, startAngle = _g === void 0 ? 0 : _g, _h = _a.endAngle, endAngle = _h === void 0 ? 0 : _h;\n            if (sweepFlag === 0) {\n                d *= -1;\n            }\n            var dx1 = rx * Math.cos(startAngle - d) + cx;\n            var dy1 = ry * Math.sin(startAngle - d) + cy;\n            segment.startTangent = [dx1 - startMovePoint[0], dy1 - startMovePoint[1]];\n            var dx2 = rx * Math.cos(startAngle + endAngle + d) + cx;\n            var dy2 = ry * Math.sin(startAngle + endAngle - d) + cy;\n            segment.endTangent = [prePoint[0] - dx2, prePoint[1] - dy2];\n        }\n        segments.push(segment);\n    }\n    return segments;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}