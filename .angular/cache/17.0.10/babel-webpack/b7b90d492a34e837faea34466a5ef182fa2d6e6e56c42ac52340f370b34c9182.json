{"ast":null,"code":"var onmessage = function (e) {\n  // Copy from src/util/collision-detect.ts\n  function generateUtils() {\n    function dot(a, b) {\n      return (a[0] || 0) * (b[0] || 0) + (a[1] || 0) * (b[1] || 0) + (a[2] || 0) * (b[2] || 0);\n    }\n    /**\n     * 1. 获取投影轴\n     */\n    function getAxes(points /** 多边形的关键点 */) {\n      // 目前先处理 平行矩形 的场景, 其他多边形不处理\n      if (points.length > 4) {\n        return [];\n      }\n      // 获取向量\n      var vector = function (start, end) {\n        return [end.x - start.x, end.y - start.y];\n      };\n      // 由于 矩形的平行原理，所以只有 2 条投影轴: A -> B, B -> C\n      var AB = vector(points[0], points[1]);\n      var BC = vector(points[1], points[2]);\n      return [AB, BC];\n    }\n    /**\n     * 绕指定点顺时针旋转后的点坐标\n     * 默认绕原点旋转\n     */\n    function rotateAtPoint(point, deg, origin) {\n      if (deg === void 0) {\n        deg = 0;\n      }\n      if (origin === void 0) {\n        origin = {\n          x: 0,\n          y: 0\n        };\n      }\n      var x = point.x,\n        y = point.y;\n      return {\n        x: (x - origin.x) * Math.cos(-deg) + (y - origin.y) * Math.sin(-deg) + origin.x,\n        y: (origin.x - x) * Math.sin(-deg) + (y - origin.y) * Math.cos(-deg) + origin.y\n      };\n    }\n    /**\n     * @private\n     * 转化为顶点坐标数组\n     *\n     * @param {Object} box\n     */\n    function getRectPoints(box) {\n      var points = [{\n        x: box.x,\n        y: box.y\n      }, {\n        x: box.x + box.width,\n        y: box.y\n      }, {\n        x: box.x + box.width,\n        y: box.y + box.height\n      }, {\n        x: box.x,\n        y: box.y + box.height\n      }];\n      var rotation = box.rotation;\n      if (rotation) {\n        return [rotateAtPoint(points[0], rotation, points[0]), rotateAtPoint(points[1], rotation, points[0]), rotateAtPoint(points[2], rotation, points[0]), rotateAtPoint(points[3], rotation, points[0])];\n      }\n      return points;\n    }\n    /**\n     * 2. 获取多边形在投影轴上的投影\n     *\n     * 向量的点积的其中一个几何含义是：一个向量在平行于另一个向量方向上的投影的数值乘积。\n     * 由于投影轴是单位向量（长度为1），投影的长度为 x1 * x2 + y1 * y2\n     */\n    function getProjection(points /** 多边形的关键点 */, axis) {\n      // 目前先处理矩形的场景\n      if (points.length > 4) {\n        return {\n          min: 0,\n          max: 0\n        };\n      }\n      var scalars = [];\n      points.forEach(function (point) {\n        scalars.push(dot([point.x, point.y], axis));\n      });\n      return {\n        min: Math.min.apply(null, scalars),\n        max: Math.max.apply(null, scalars)\n      };\n    }\n    function isProjectionOverlap(projection1, projection2) {\n      return projection1.max > projection2.min && projection1.min < projection2.max;\n    }\n    function isValidNumber(d) {\n      return typeof d === 'number' && !Number.isNaN(d) && d !== Infinity && d !== -Infinity;\n    }\n    function isValidBox(box) {\n      return ['x', 'y', 'width', 'height'].every(function (attr) {\n        return isValidNumber(box[attr]);\n      });\n    }\n    function isIntersectRect(box1, box2, margin) {\n      if (margin === void 0) {\n        margin = 0;\n      }\n      return !(box2.x > box1.x + box1.width + margin || box2.x + box2.width < box1.x - margin || box2.y > box1.y + box1.height + margin || box2.y + box2.height < box1.y - margin);\n    }\n    function intersect(box1, box2, margin) {\n      if (margin === void 0) {\n        margin = 0;\n      }\n      if (!isValidBox(box1) || !isValidBox(box2)) return false;\n      // Quick detect, if rotation is null or zero.\n      if (!box1.rotation && !box2.rotation) {\n        return isIntersectRect(box1, box2, margin);\n      }\n      // 分别获取 4 个关键点\n      var rect1Points = getRectPoints(box1);\n      var rect2Points = getRectPoints(box2);\n      // 获取所有投影轴\n      var axes = getAxes(rect1Points).concat(getAxes(rect2Points));\n      for (var i = 0; i < axes.length; i++) {\n        var axis = axes[i];\n        var projection1 = getProjection(rect1Points, axis);\n        var projection2 = getProjection(rect2Points, axis);\n        if (!isProjectionOverlap(projection1, projection2)) return false;\n      }\n      return true;\n    }\n    return {\n      intersect: intersect\n    };\n  }\n  var intersect = generateUtils().intersect;\n  // Label layouts.\n  function hideOverlap(items) {\n    var boxes = items.slice();\n    for (var i = 0; i < boxes.length; i++) {\n      var box1 = boxes[i];\n      if (box1.visible) {\n        for (var j = i + 1; j < boxes.length; j++) {\n          var box2 = boxes[j];\n          if (box1 !== box2 && box2.visible) {\n            if (intersect(box1, box2)) {\n              box2.visible = false;\n            }\n          }\n        }\n      }\n    }\n    return boxes;\n  }\n  var methods = {\n    'hide-overlap': hideOverlap\n  };\n  // Main\n  try {\n    var eventData = JSON.parse(e.data);\n    if (!eventData || !eventData.type || !methods[eventData.type]) return;\n    var type = eventData.type,\n      items = eventData.items;\n    var result = methods[type](items);\n    self.postMessage(result);\n  } catch (e) {\n    throw e;\n  }\n};\nvar code = \"\\n   self.onmessage = \".concat(onmessage.toString(), \"\\n\");\nexport { code };","map":{"version":3,"names":["onmessage","e","generateUtils","dot","a","b","getAxes","points","length","vector","start","end","x","y","AB","BC","rotateAtPoint","point","deg","origin","Math","cos","sin","getRectPoints","box","width","height","rotation","getProjection","axis","min","max","scalars","forEach","push","apply","isProjectionOverlap","projection1","projection2","isValidNumber","d","Number","isNaN","Infinity","isValidBox","every","attr","isIntersectRect","box1","box2","margin","intersect","rect1Points","rect2Points","axes","concat","i","hideOverlap","items","boxes","slice","visible","j","methods","eventData","JSON","parse","data","type","result","self","postMessage","code","toString"],"sources":["/Users/obiechina/Documents/ridy-flutter-full-taxi-solution 2/node_modules/@antv/g2/esm/geometry/label/layout/worker/hide-overlap.js"],"sourcesContent":["var onmessage = function (e) {\n    // Copy from src/util/collision-detect.ts\n    function generateUtils() {\n        function dot(a, b) {\n            return (a[0] || 0) * (b[0] || 0) + (a[1] || 0) * (b[1] || 0) + (a[2] || 0) * (b[2] || 0);\n        }\n        /**\n         * 1. 获取投影轴\n         */\n        function getAxes(points /** 多边形的关键点 */) {\n            // 目前先处理 平行矩形 的场景, 其他多边形不处理\n            if (points.length > 4) {\n                return [];\n            }\n            // 获取向量\n            var vector = function (start, end) {\n                return [end.x - start.x, end.y - start.y];\n            };\n            // 由于 矩形的平行原理，所以只有 2 条投影轴: A -> B, B -> C\n            var AB = vector(points[0], points[1]);\n            var BC = vector(points[1], points[2]);\n            return [AB, BC];\n        }\n        /**\n         * 绕指定点顺时针旋转后的点坐标\n         * 默认绕原点旋转\n         */\n        function rotateAtPoint(point, deg, origin) {\n            if (deg === void 0) { deg = 0; }\n            if (origin === void 0) { origin = { x: 0, y: 0 }; }\n            var x = point.x, y = point.y;\n            return {\n                x: (x - origin.x) * Math.cos(-deg) + (y - origin.y) * Math.sin(-deg) + origin.x,\n                y: (origin.x - x) * Math.sin(-deg) + (y - origin.y) * Math.cos(-deg) + origin.y,\n            };\n        }\n        /**\n         * @private\n         * 转化为顶点坐标数组\n         *\n         * @param {Object} box\n         */\n        function getRectPoints(box) {\n            var points = [\n                { x: box.x, y: box.y },\n                { x: box.x + box.width, y: box.y },\n                { x: box.x + box.width, y: box.y + box.height },\n                { x: box.x, y: box.y + box.height },\n            ];\n            var rotation = box.rotation;\n            if (rotation) {\n                return [\n                    rotateAtPoint(points[0], rotation, points[0]),\n                    rotateAtPoint(points[1], rotation, points[0]),\n                    rotateAtPoint(points[2], rotation, points[0]),\n                    rotateAtPoint(points[3], rotation, points[0]),\n                ];\n            }\n            return points;\n        }\n        /**\n         * 2. 获取多边形在投影轴上的投影\n         *\n         * 向量的点积的其中一个几何含义是：一个向量在平行于另一个向量方向上的投影的数值乘积。\n         * 由于投影轴是单位向量（长度为1），投影的长度为 x1 * x2 + y1 * y2\n         */\n        function getProjection(points /** 多边形的关键点 */, axis) {\n            // 目前先处理矩形的场景\n            if (points.length > 4) {\n                return { min: 0, max: 0 };\n            }\n            var scalars = [];\n            points.forEach(function (point) {\n                scalars.push(dot([point.x, point.y], axis));\n            });\n            return { min: Math.min.apply(null, scalars), max: Math.max.apply(null, scalars) };\n        }\n        function isProjectionOverlap(projection1, projection2) {\n            return projection1.max > projection2.min && projection1.min < projection2.max;\n        }\n        function isValidNumber(d) {\n            return typeof d === 'number' && !Number.isNaN(d) && d !== Infinity && d !== -Infinity;\n        }\n        function isValidBox(box) {\n            return ['x', 'y', 'width', 'height'].every(function (attr) { return isValidNumber(box[attr]); });\n        }\n        function isIntersectRect(box1, box2, margin) {\n            if (margin === void 0) { margin = 0; }\n            return !(box2.x > box1.x + box1.width + margin ||\n                box2.x + box2.width < box1.x - margin ||\n                box2.y > box1.y + box1.height + margin ||\n                box2.y + box2.height < box1.y - margin);\n        }\n        function intersect(box1, box2, margin) {\n            if (margin === void 0) { margin = 0; }\n            if (!isValidBox(box1) || !isValidBox(box2))\n                return false;\n            // Quick detect, if rotation is null or zero.\n            if (!box1.rotation && !box2.rotation) {\n                return isIntersectRect(box1, box2, margin);\n            }\n            // 分别获取 4 个关键点\n            var rect1Points = getRectPoints(box1);\n            var rect2Points = getRectPoints(box2);\n            // 获取所有投影轴\n            var axes = getAxes(rect1Points).concat(getAxes(rect2Points));\n            for (var i = 0; i < axes.length; i++) {\n                var axis = axes[i];\n                var projection1 = getProjection(rect1Points, axis);\n                var projection2 = getProjection(rect2Points, axis);\n                if (!isProjectionOverlap(projection1, projection2))\n                    return false;\n            }\n            return true;\n        }\n        return { intersect: intersect };\n    }\n    var intersect = generateUtils().intersect;\n    // Label layouts.\n    function hideOverlap(items) {\n        var boxes = items.slice();\n        for (var i = 0; i < boxes.length; i++) {\n            var box1 = boxes[i];\n            if (box1.visible) {\n                for (var j = i + 1; j < boxes.length; j++) {\n                    var box2 = boxes[j];\n                    if (box1 !== box2 && box2.visible) {\n                        if (intersect(box1, box2)) {\n                            box2.visible = false;\n                        }\n                    }\n                }\n            }\n        }\n        return boxes;\n    }\n    var methods = {\n        'hide-overlap': hideOverlap,\n    };\n    // Main\n    try {\n        var eventData = JSON.parse(e.data);\n        if (!eventData || !eventData.type || !methods[eventData.type])\n            return;\n        var type = eventData.type, items = eventData.items;\n        var result = methods[type](items);\n        self.postMessage(result);\n    }\n    catch (e) {\n        throw e;\n    }\n};\nvar code = \"\\n   self.onmessage = \".concat(onmessage.toString(), \"\\n\");\nexport { code };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}