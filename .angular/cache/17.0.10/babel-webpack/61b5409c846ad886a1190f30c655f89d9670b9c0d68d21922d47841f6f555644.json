{"ast":null,"code":"import { __values } from \"tslib\";\nimport { isObject, each, find, get } from '@antv/util';\nimport { polarToCartesian } from '../../../../util/graphics';\n/** label text和line距离 4px */\nvar MARGIN = 4;\nfunction antiCollision(labelShapes, labels, lineHeight, plotRange, center, isRight) {\n  var e_1, _a;\n  // adjust y position of labels to avoid overlapping\n  var overlapping = true;\n  var start = plotRange.start;\n  var end = plotRange.end;\n  var startY = Math.min(start.y, end.y);\n  var totalHeight = Math.abs(start.y - end.y);\n  var i;\n  var maxY = 0;\n  var minY = Number.MIN_VALUE;\n  var boxes = labels.map(function (label) {\n    if (label.y > maxY) {\n      maxY = label.y;\n    }\n    if (label.y < minY) {\n      minY = label.y;\n    }\n    return {\n      size: lineHeight,\n      targets: [label.y - startY]\n    };\n  });\n  minY -= startY;\n  if (maxY - startY > totalHeight) {\n    totalHeight = maxY - startY;\n  }\n  while (overlapping) {\n    /* eslint no-loop-func: 0 */\n    boxes.forEach(function (box) {\n      var target = (Math.min.apply(minY, box.targets) + Math.max.apply(minY, box.targets)) / 2;\n      box.pos = Math.min(Math.max(minY, target - box.size / 2), totalHeight - box.size);\n      // box.pos = Math.max(0, target - box.size / 2);\n    });\n    // detect overlapping and join boxes\n    overlapping = false;\n    i = boxes.length;\n    while (i--) {\n      if (i > 0) {\n        var previousBox = boxes[i - 1];\n        var box = boxes[i];\n        if (previousBox.pos + previousBox.size > box.pos) {\n          // overlapping\n          previousBox.size += box.size;\n          previousBox.targets = previousBox.targets.concat(box.targets);\n          // overflow, shift up\n          if (previousBox.pos + previousBox.size > totalHeight) {\n            previousBox.pos = totalHeight - previousBox.size;\n          }\n          boxes.splice(i, 1); // removing box\n          overlapping = true;\n        }\n      }\n    }\n  }\n  i = 0;\n  // step 4: normalize y and adjust x\n  boxes.forEach(function (b) {\n    var posInCompositeBox = startY + lineHeight / 2; // middle of the label\n    b.targets.forEach(function () {\n      labels[i].y = b.pos + posInCompositeBox;\n      posInCompositeBox += lineHeight;\n      i++;\n    });\n  });\n  var labelsMap = {};\n  try {\n    for (var labelShapes_1 = __values(labelShapes), labelShapes_1_1 = labelShapes_1.next(); !labelShapes_1_1.done; labelShapes_1_1 = labelShapes_1.next()) {\n      var labelShape = labelShapes_1_1.value;\n      labelsMap[labelShape.get('id')] = labelShape;\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (labelShapes_1_1 && !labelShapes_1_1.done && (_a = labelShapes_1.return)) _a.call(labelShapes_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n  // (x - cx)^2 + (y - cy)^2 = totalR^2\n  labels.forEach(function (label) {\n    var rPow2 = label.r * label.r;\n    var dyPow2 = Math.pow(Math.abs(label.y - center.y), 2);\n    if (rPow2 < dyPow2) {\n      label.x = center.x;\n    } else {\n      var dx = Math.sqrt(rPow2 - dyPow2);\n      if (!isRight) {\n        // left\n        label.x = center.x - dx;\n      } else {\n        // right\n        label.x = center.x + dx;\n      }\n    }\n    // adjust labelShape\n    var labelShape = labelsMap[label.id];\n    labelShape.attr('x', label.x);\n    labelShape.attr('y', label.y);\n    // because group could not effect text-shape, should set text-shape position manually\n    var textShape = find(labelShape.getChildren(), function (ele) {\n      return ele.get('type') === 'text';\n    });\n    // @ts-ignore\n    if (textShape) {\n      textShape.attr('y', label.y);\n      textShape.attr('x', label.x);\n    }\n  });\n}\nexport function distribute(items, labels, shapes, region) {\n  if (!items.length || !labels.length) {\n    return;\n  }\n  var offset = items[0] ? items[0].offset : 0;\n  var coordinate = labels[0].get('coordinate');\n  var radius = coordinate.getRadius();\n  var center = coordinate.getCenter();\n  if (offset > 0) {\n    // const lineHeight = get(this.geometry.theme, ['pieLabels', 'labelHeight'], 14);\n    var lineHeight_1 = 14; // TODO\n    var totalR = radius + offset;\n    var totalHeight_1 = totalR * 2 + lineHeight_1 * 2;\n    var plotRange_1 = {\n      start: coordinate.start,\n      end: coordinate.end\n    };\n    // step 1: separate labels\n    var halves_1 = [[], [] // right\n    ];\n\n    items.forEach(function (labelItem) {\n      if (!labelItem) {\n        return;\n      }\n      if (labelItem.textAlign === 'right') {\n        // left\n        halves_1[0].push(labelItem);\n      } else {\n        // right or center will be put on the right side\n        halves_1[1].push(labelItem);\n      }\n    });\n    halves_1.forEach(function (half, index) {\n      // step 2: reduce labels\n      var maxLabelsCountForOneSide = totalHeight_1 / lineHeight_1;\n      if (half.length > maxLabelsCountForOneSide) {\n        half.sort(function (a, b) {\n          // sort by percentage DESC\n          return b['..percent'] - a['..percent'];\n        });\n        half.splice(maxLabelsCountForOneSide, half.length - maxLabelsCountForOneSide);\n      }\n      // step 3: distribute position (x and y)\n      half.sort(function (a, b) {\n        // sort by y ASC\n        return a.y - b.y;\n      });\n      antiCollision(labels, half, lineHeight_1, plotRange_1, center, index);\n    });\n  }\n  // 配置 labelLine\n  each(items, function (item) {\n    if (item && item.labelLine) {\n      var distance = item.offset;\n      var angle = item.angle;\n      // 贴近圆周\n      var startPoint = polarToCartesian(center.x, center.y, radius, angle);\n      var innerPoint = polarToCartesian(center.x, center.y, radius + distance / 2, angle);\n      var itemX = item.x + get(item, 'offsetX', 0);\n      var itemY = item.y + get(item, 'offsetY', 0);\n      var endPoint = {\n        x: itemX - Math.cos(angle) * MARGIN,\n        y: itemY - Math.sin(angle) * MARGIN\n      };\n      if (!isObject(item.labelLine)) {\n        // labelLine: true\n        item.labelLine = {};\n      }\n      item.labelLine.path = [\"M \".concat(startPoint.x), \"\".concat(startPoint.y, \" Q\").concat(innerPoint.x), \"\".concat(innerPoint.y, \" \").concat(endPoint.x), endPoint.y].join(',');\n    }\n  });\n}","map":{"version":3,"names":["__values","isObject","each","find","get","polarToCartesian","MARGIN","antiCollision","labelShapes","labels","lineHeight","plotRange","center","isRight","e_1","_a","overlapping","start","end","startY","Math","min","y","totalHeight","abs","i","maxY","minY","Number","MIN_VALUE","boxes","map","label","size","targets","forEach","box","target","apply","max","pos","length","previousBox","concat","splice","b","posInCompositeBox","labelsMap","labelShapes_1","labelShapes_1_1","next","done","labelShape","value","e_1_1","error","return","call","rPow2","r","dyPow2","pow","x","dx","sqrt","id","attr","textShape","getChildren","ele","distribute","items","shapes","region","offset","coordinate","radius","getRadius","getCenter","lineHeight_1","totalR","totalHeight_1","plotRange_1","halves_1","labelItem","textAlign","push","half","index","maxLabelsCountForOneSide","sort","a","item","labelLine","distance","angle","startPoint","innerPoint","itemX","itemY","endPoint","cos","sin","path","join"],"sources":["/Users/obiechina/Documents/ridy-flutter-full-taxi-solution 2/node_modules/@antv/g2/esm/geometry/label/layout/pie/distribute.js"],"sourcesContent":["import { __values } from \"tslib\";\nimport { isObject, each, find, get } from '@antv/util';\nimport { polarToCartesian } from '../../../../util/graphics';\n/** label text和line距离 4px */\nvar MARGIN = 4;\nfunction antiCollision(labelShapes, labels, lineHeight, plotRange, center, isRight) {\n    var e_1, _a;\n    // adjust y position of labels to avoid overlapping\n    var overlapping = true;\n    var start = plotRange.start;\n    var end = plotRange.end;\n    var startY = Math.min(start.y, end.y);\n    var totalHeight = Math.abs(start.y - end.y);\n    var i;\n    var maxY = 0;\n    var minY = Number.MIN_VALUE;\n    var boxes = labels.map(function (label) {\n        if (label.y > maxY) {\n            maxY = label.y;\n        }\n        if (label.y < minY) {\n            minY = label.y;\n        }\n        return {\n            size: lineHeight,\n            targets: [label.y - startY],\n        };\n    });\n    minY -= startY;\n    if (maxY - startY > totalHeight) {\n        totalHeight = maxY - startY;\n    }\n    while (overlapping) {\n        /* eslint no-loop-func: 0 */\n        boxes.forEach(function (box) {\n            var target = (Math.min.apply(minY, box.targets) + Math.max.apply(minY, box.targets)) / 2;\n            box.pos = Math.min(Math.max(minY, target - box.size / 2), totalHeight - box.size);\n            // box.pos = Math.max(0, target - box.size / 2);\n        });\n        // detect overlapping and join boxes\n        overlapping = false;\n        i = boxes.length;\n        while (i--) {\n            if (i > 0) {\n                var previousBox = boxes[i - 1];\n                var box = boxes[i];\n                if (previousBox.pos + previousBox.size > box.pos) {\n                    // overlapping\n                    previousBox.size += box.size;\n                    previousBox.targets = previousBox.targets.concat(box.targets);\n                    // overflow, shift up\n                    if (previousBox.pos + previousBox.size > totalHeight) {\n                        previousBox.pos = totalHeight - previousBox.size;\n                    }\n                    boxes.splice(i, 1); // removing box\n                    overlapping = true;\n                }\n            }\n        }\n    }\n    i = 0;\n    // step 4: normalize y and adjust x\n    boxes.forEach(function (b) {\n        var posInCompositeBox = startY + lineHeight / 2; // middle of the label\n        b.targets.forEach(function () {\n            labels[i].y = b.pos + posInCompositeBox;\n            posInCompositeBox += lineHeight;\n            i++;\n        });\n    });\n    var labelsMap = {};\n    try {\n        for (var labelShapes_1 = __values(labelShapes), labelShapes_1_1 = labelShapes_1.next(); !labelShapes_1_1.done; labelShapes_1_1 = labelShapes_1.next()) {\n            var labelShape = labelShapes_1_1.value;\n            labelsMap[labelShape.get('id')] = labelShape;\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (labelShapes_1_1 && !labelShapes_1_1.done && (_a = labelShapes_1.return)) _a.call(labelShapes_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    // (x - cx)^2 + (y - cy)^2 = totalR^2\n    labels.forEach(function (label) {\n        var rPow2 = label.r * label.r;\n        var dyPow2 = Math.pow(Math.abs(label.y - center.y), 2);\n        if (rPow2 < dyPow2) {\n            label.x = center.x;\n        }\n        else {\n            var dx = Math.sqrt(rPow2 - dyPow2);\n            if (!isRight) {\n                // left\n                label.x = center.x - dx;\n            }\n            else {\n                // right\n                label.x = center.x + dx;\n            }\n        }\n        // adjust labelShape\n        var labelShape = labelsMap[label.id];\n        labelShape.attr('x', label.x);\n        labelShape.attr('y', label.y);\n        // because group could not effect text-shape, should set text-shape position manually\n        var textShape = find(labelShape.getChildren(), function (ele) { return ele.get('type') === 'text'; });\n        // @ts-ignore\n        if (textShape) {\n            textShape.attr('y', label.y);\n            textShape.attr('x', label.x);\n        }\n    });\n}\nexport function distribute(items, labels, shapes, region) {\n    if (!items.length || !labels.length) {\n        return;\n    }\n    var offset = items[0] ? items[0].offset : 0;\n    var coordinate = labels[0].get('coordinate');\n    var radius = coordinate.getRadius();\n    var center = coordinate.getCenter();\n    if (offset > 0) {\n        // const lineHeight = get(this.geometry.theme, ['pieLabels', 'labelHeight'], 14);\n        var lineHeight_1 = 14; // TODO\n        var totalR = radius + offset;\n        var totalHeight_1 = totalR * 2 + lineHeight_1 * 2;\n        var plotRange_1 = {\n            start: coordinate.start,\n            end: coordinate.end,\n        };\n        // step 1: separate labels\n        var halves_1 = [\n            [],\n            [], // right\n        ];\n        items.forEach(function (labelItem) {\n            if (!labelItem) {\n                return;\n            }\n            if (labelItem.textAlign === 'right') {\n                // left\n                halves_1[0].push(labelItem);\n            }\n            else {\n                // right or center will be put on the right side\n                halves_1[1].push(labelItem);\n            }\n        });\n        halves_1.forEach(function (half, index) {\n            // step 2: reduce labels\n            var maxLabelsCountForOneSide = totalHeight_1 / lineHeight_1;\n            if (half.length > maxLabelsCountForOneSide) {\n                half.sort(function (a, b) {\n                    // sort by percentage DESC\n                    return b['..percent'] - a['..percent'];\n                });\n                half.splice(maxLabelsCountForOneSide, half.length - maxLabelsCountForOneSide);\n            }\n            // step 3: distribute position (x and y)\n            half.sort(function (a, b) {\n                // sort by y ASC\n                return a.y - b.y;\n            });\n            antiCollision(labels, half, lineHeight_1, plotRange_1, center, index);\n        });\n    }\n    // 配置 labelLine\n    each(items, function (item) {\n        if (item && item.labelLine) {\n            var distance = item.offset;\n            var angle = item.angle;\n            // 贴近圆周\n            var startPoint = polarToCartesian(center.x, center.y, radius, angle);\n            var innerPoint = polarToCartesian(center.x, center.y, radius + distance / 2, angle);\n            var itemX = item.x + get(item, 'offsetX', 0);\n            var itemY = item.y + get(item, 'offsetY', 0);\n            var endPoint = {\n                x: itemX - Math.cos(angle) * MARGIN,\n                y: itemY - Math.sin(angle) * MARGIN,\n            };\n            if (!isObject(item.labelLine)) {\n                // labelLine: true\n                item.labelLine = {};\n            }\n            item.labelLine.path = [\n                \"M \".concat(startPoint.x),\n                \"\".concat(startPoint.y, \" Q\").concat(innerPoint.x),\n                \"\".concat(innerPoint.y, \" \").concat(endPoint.x),\n                endPoint.y,\n            ].join(',');\n        }\n    });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}