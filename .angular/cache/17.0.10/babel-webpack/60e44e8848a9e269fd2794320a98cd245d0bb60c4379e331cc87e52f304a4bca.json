{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { ext, vec2 } from '@antv/matrix-util';\nimport { isNumberEqual } from '@antv/util';\nimport Coordinate from './base';\n/**\n * 螺旋坐标系\n */\nvar Helix = /** @class */function (_super) {\n  __extends(Helix, _super);\n  function Helix(cfg) {\n    var _this = _super.call(this, cfg) || this;\n    _this.isHelix = true;\n    _this.type = 'helix';\n    var _a = cfg.startAngle,\n      startAngle = _a === void 0 ? 1.25 * Math.PI : _a,\n      _b = cfg.endAngle,\n      endAngle = _b === void 0 ? 7.25 * Math.PI : _b,\n      _c = cfg.innerRadius,\n      innerRadius = _c === void 0 ? 0 : _c,\n      radius = cfg.radius;\n    _this.startAngle = startAngle;\n    _this.endAngle = endAngle;\n    _this.innerRadius = innerRadius;\n    _this.radius = radius;\n    _this.initial();\n    return _this;\n  }\n  Helix.prototype.initial = function () {\n    _super.prototype.initial.call(this);\n    var index = (this.endAngle - this.startAngle) / (2 * Math.PI) + 1; // 螺线圈数\n    var maxRadius = Math.min(this.width, this.height) / 2;\n    if (this.radius && this.radius >= 0 && this.radius <= 1) {\n      maxRadius = maxRadius * this.radius;\n    }\n    this.d = Math.floor(maxRadius * (1 - this.innerRadius) / index);\n    this.a = this.d / (Math.PI * 2); // 螺线系数\n    this.x = {\n      start: this.startAngle,\n      end: this.endAngle\n    };\n    this.y = {\n      start: this.innerRadius * maxRadius,\n      end: this.innerRadius * maxRadius + this.d * 0.99\n    };\n  };\n  /**\n   * 将百分比数据变成屏幕坐标\n   * @param point 归一化的点坐标\n   * @return      返回对应的屏幕坐标\n   */\n  Helix.prototype.convertPoint = function (point) {\n    var _a;\n    var x = point.x,\n      y = point.y;\n    if (this.isTransposed) {\n      _a = [y, x], x = _a[0], y = _a[1];\n    }\n    var thi = this.convertDim(x, 'x');\n    var r = this.a * thi;\n    var newY = this.convertDim(y, 'y');\n    return {\n      x: this.center.x + Math.cos(thi) * (r + newY),\n      y: this.center.y + Math.sin(thi) * (r + newY)\n    };\n  };\n  /**\n   * 将屏幕坐标点还原成百分比数据\n   * @param point 屏幕坐标\n   * @return      返回对应的归一化后的数据\n   */\n  Helix.prototype.invertPoint = function (point) {\n    var _a;\n    var d = this.d + this.y.start;\n    var v = vec2.subtract([0, 0], [point.x, point.y], [this.center.x, this.center.y]);\n    var thi = ext.angleTo(v, [1, 0], true);\n    var rMin = thi * this.a; // 坐标与原点的连线在第一圈上的交点，最小r值\n    if (vec2.length(v) < rMin) {\n      // 坐标与原点的连线不可能小于最小r值，但不排除因小数计算产生的略小于rMin的情况\n      rMin = vec2.length(v);\n    }\n    var index = Math.floor((vec2.length(v) - rMin) / d); // 当前点位于第index圈\n    thi = 2 * index * Math.PI + thi;\n    var r = this.a * thi;\n    var newY = vec2.length(v) - r;\n    newY = isNumberEqual(newY, 0) ? 0 : newY;\n    var x = this.invertDim(thi, 'x');\n    var y = this.invertDim(newY, 'y');\n    x = isNumberEqual(x, 0) ? 0 : x;\n    y = isNumberEqual(y, 0) ? 0 : y;\n    if (this.isTransposed) {\n      _a = [y, x], x = _a[0], y = _a[1];\n    }\n    return {\n      x: x,\n      y: y\n    };\n  };\n  return Helix;\n}(Coordinate);\nexport default Helix;","map":{"version":3,"names":["__extends","ext","vec2","isNumberEqual","Coordinate","Helix","_super","cfg","_this","call","isHelix","type","_a","startAngle","Math","PI","_b","endAngle","_c","innerRadius","radius","initial","prototype","index","maxRadius","min","width","height","d","floor","a","x","start","end","y","convertPoint","point","isTransposed","thi","convertDim","r","newY","center","cos","sin","invertPoint","v","subtract","angleTo","rMin","length","invertDim"],"sources":["/Users/obiechina/Documents/ridy-flutter-full-taxi-solution 2/node_modules/@antv/coord/esm/coord/helix.js"],"sourcesContent":["import { __extends } from \"tslib\";\nimport { ext, vec2 } from '@antv/matrix-util';\nimport { isNumberEqual } from '@antv/util';\nimport Coordinate from './base';\n/**\n * 螺旋坐标系\n */\nvar Helix = /** @class */ (function (_super) {\n    __extends(Helix, _super);\n    function Helix(cfg) {\n        var _this = _super.call(this, cfg) || this;\n        _this.isHelix = true;\n        _this.type = 'helix';\n        var _a = cfg.startAngle, startAngle = _a === void 0 ? 1.25 * Math.PI : _a, _b = cfg.endAngle, endAngle = _b === void 0 ? 7.25 * Math.PI : _b, _c = cfg.innerRadius, innerRadius = _c === void 0 ? 0 : _c, radius = cfg.radius;\n        _this.startAngle = startAngle;\n        _this.endAngle = endAngle;\n        _this.innerRadius = innerRadius;\n        _this.radius = radius;\n        _this.initial();\n        return _this;\n    }\n    Helix.prototype.initial = function () {\n        _super.prototype.initial.call(this);\n        var index = (this.endAngle - this.startAngle) / (2 * Math.PI) + 1; // 螺线圈数\n        var maxRadius = Math.min(this.width, this.height) / 2;\n        if (this.radius && this.radius >= 0 && this.radius <= 1) {\n            maxRadius = maxRadius * this.radius;\n        }\n        this.d = Math.floor((maxRadius * (1 - this.innerRadius)) / index);\n        this.a = this.d / (Math.PI * 2); // 螺线系数\n        this.x = {\n            start: this.startAngle,\n            end: this.endAngle,\n        };\n        this.y = {\n            start: this.innerRadius * maxRadius,\n            end: this.innerRadius * maxRadius + this.d * 0.99,\n        };\n    };\n    /**\n     * 将百分比数据变成屏幕坐标\n     * @param point 归一化的点坐标\n     * @return      返回对应的屏幕坐标\n     */\n    Helix.prototype.convertPoint = function (point) {\n        var _a;\n        var x = point.x, y = point.y;\n        if (this.isTransposed) {\n            _a = [y, x], x = _a[0], y = _a[1];\n        }\n        var thi = this.convertDim(x, 'x');\n        var r = this.a * thi;\n        var newY = this.convertDim(y, 'y');\n        return {\n            x: this.center.x + Math.cos(thi) * (r + newY),\n            y: this.center.y + Math.sin(thi) * (r + newY),\n        };\n    };\n    /**\n     * 将屏幕坐标点还原成百分比数据\n     * @param point 屏幕坐标\n     * @return      返回对应的归一化后的数据\n     */\n    Helix.prototype.invertPoint = function (point) {\n        var _a;\n        var d = this.d + this.y.start;\n        var v = vec2.subtract([0, 0], [point.x, point.y], [this.center.x, this.center.y]);\n        var thi = ext.angleTo(v, [1, 0], true);\n        var rMin = thi * this.a; // 坐标与原点的连线在第一圈上的交点，最小r值\n        if (vec2.length(v) < rMin) {\n            // 坐标与原点的连线不可能小于最小r值，但不排除因小数计算产生的略小于rMin的情况\n            rMin = vec2.length(v);\n        }\n        var index = Math.floor((vec2.length(v) - rMin) / d); // 当前点位于第index圈\n        thi = 2 * index * Math.PI + thi;\n        var r = this.a * thi;\n        var newY = vec2.length(v) - r;\n        newY = isNumberEqual(newY, 0) ? 0 : newY;\n        var x = this.invertDim(thi, 'x');\n        var y = this.invertDim(newY, 'y');\n        x = isNumberEqual(x, 0) ? 0 : x;\n        y = isNumberEqual(y, 0) ? 0 : y;\n        if (this.isTransposed) {\n            _a = [y, x], x = _a[0], y = _a[1];\n        }\n        return { x: x, y: y };\n    };\n    return Helix;\n}(Coordinate));\nexport default Helix;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}