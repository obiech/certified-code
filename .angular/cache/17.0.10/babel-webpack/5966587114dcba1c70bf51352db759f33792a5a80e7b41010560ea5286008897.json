{"ast":null,"code":"import { __values } from \"tslib\";\nimport { isArray, isString } from '@antv/util';\n/**\n * @ignore\n * Determines whether between is\n * @param value\n * @param start\n * @param end\n * @returns true if between\n */\nexport function isBetween(value, start, end) {\n  var min = Math.min(start, end);\n  var max = Math.max(start, end);\n  return value >= min && value <= max;\n}\n/**\n * @ignore\n * pads the current string/array with a given value (repeated, if needed) so that the resulting reaches a given length.\n * The padding is applied from the end of the current value.\n *\n * @param source\n * @param targetLength\n * @param padValue\n * @returns\n */\nexport function padEnd(source, targetLength, padValue) {\n  if (isString(source)) {\n    return source.padEnd(targetLength, padValue);\n  } else if (isArray(source)) {\n    var sourceLength = source.length;\n    if (sourceLength < targetLength) {\n      var diff = targetLength - sourceLength;\n      for (var i = 0; i < diff; i++) {\n        source.push(padValue);\n      }\n    }\n  }\n  return source;\n}\n/**\n * @ignore\n * omit keys of an object.\n * @param obj\n * @param keys\n */\nexport function omit(obj, keys) {\n  if (typeof obj === 'object') {\n    keys.forEach(function (key) {\n      delete obj[key];\n    });\n  }\n  return obj;\n}\n/**\n * @ignore\n * @param sourceArray\n * @param targetArray\n * @param map\n */\nexport function uniq(sourceArray, targetArray, map) {\n  var e_1, _a;\n  if (targetArray === void 0) {\n    targetArray = [];\n  }\n  if (map === void 0) {\n    map = new Map();\n  }\n  try {\n    for (var sourceArray_1 = __values(sourceArray), sourceArray_1_1 = sourceArray_1.next(); !sourceArray_1_1.done; sourceArray_1_1 = sourceArray_1.next()) {\n      var source = sourceArray_1_1.value;\n      if (!map.has(source)) {\n        targetArray.push(source);\n        map.set(source, true);\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (sourceArray_1_1 && !sourceArray_1_1.done && (_a = sourceArray_1.return)) _a.call(sourceArray_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n  return targetArray;\n}","map":{"version":3,"names":["__values","isArray","isString","isBetween","value","start","end","min","Math","max","padEnd","source","targetLength","padValue","sourceLength","length","diff","i","push","omit","obj","keys","forEach","key","uniq","sourceArray","targetArray","map","e_1","_a","Map","sourceArray_1","sourceArray_1_1","next","done","has","set","e_1_1","error","return","call"],"sources":["/Users/obiechina/Documents/ridy-flutter-full-taxi-solution 2/node_modules/@antv/g2/esm/util/helper.js"],"sourcesContent":["import { __values } from \"tslib\";\nimport { isArray, isString } from '@antv/util';\n/**\n * @ignore\n * Determines whether between is\n * @param value\n * @param start\n * @param end\n * @returns true if between\n */\nexport function isBetween(value, start, end) {\n    var min = Math.min(start, end);\n    var max = Math.max(start, end);\n    return value >= min && value <= max;\n}\n/**\n * @ignore\n * pads the current string/array with a given value (repeated, if needed) so that the resulting reaches a given length.\n * The padding is applied from the end of the current value.\n *\n * @param source\n * @param targetLength\n * @param padValue\n * @returns\n */\nexport function padEnd(source, targetLength, padValue) {\n    if (isString(source)) {\n        return source.padEnd(targetLength, padValue);\n    }\n    else if (isArray(source)) {\n        var sourceLength = source.length;\n        if (sourceLength < targetLength) {\n            var diff = targetLength - sourceLength;\n            for (var i = 0; i < diff; i++) {\n                source.push(padValue);\n            }\n        }\n    }\n    return source;\n}\n/**\n * @ignore\n * omit keys of an object.\n * @param obj\n * @param keys\n */\nexport function omit(obj, keys) {\n    if (typeof obj === 'object') {\n        keys.forEach(function (key) {\n            delete obj[key];\n        });\n    }\n    return obj;\n}\n/**\n * @ignore\n * @param sourceArray\n * @param targetArray\n * @param map\n */\nexport function uniq(sourceArray, targetArray, map) {\n    var e_1, _a;\n    if (targetArray === void 0) { targetArray = []; }\n    if (map === void 0) { map = new Map(); }\n    try {\n        for (var sourceArray_1 = __values(sourceArray), sourceArray_1_1 = sourceArray_1.next(); !sourceArray_1_1.done; sourceArray_1_1 = sourceArray_1.next()) {\n            var source = sourceArray_1_1.value;\n            if (!map.has(source)) {\n                targetArray.push(source);\n                map.set(source, true);\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (sourceArray_1_1 && !sourceArray_1_1.done && (_a = sourceArray_1.return)) _a.call(sourceArray_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return targetArray;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}