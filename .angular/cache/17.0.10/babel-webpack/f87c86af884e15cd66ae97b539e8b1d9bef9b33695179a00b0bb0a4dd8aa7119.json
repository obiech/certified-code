{"ast":null,"code":"import { distance, piMod } from './util';\nimport ellipse from './ellipse';\n// 偏导数 x\nfunction derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle) {\n  return -1 * rx * Math.cos(xRotation) * Math.sin(angle) - ry * Math.sin(xRotation) * Math.cos(angle);\n}\n// 偏导数 y\nfunction derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle) {\n  return -1 * rx * Math.sin(xRotation) * Math.sin(angle) + ry * Math.cos(xRotation) * Math.cos(angle);\n}\n// x 的极值\nfunction xExtrema(rx, ry, xRotation) {\n  return Math.atan(-ry / rx * Math.tan(xRotation));\n}\n// y 的极值\nfunction yExtrema(rx, ry, xRotation) {\n  return Math.atan(ry / (rx * Math.tan(xRotation)));\n}\n// 根据角度求 x 坐标\nfunction xAt(cx, cy, rx, ry, xRotation, angle) {\n  return rx * Math.cos(xRotation) * Math.cos(angle) - ry * Math.sin(xRotation) * Math.sin(angle) + cx;\n}\n// 根据角度求 y 坐标\nfunction yAt(cx, cy, rx, ry, xRotation, angle) {\n  return rx * Math.sin(xRotation) * Math.cos(angle) + ry * Math.cos(xRotation) * Math.sin(angle) + cy;\n}\n// 获取点在椭圆上的角度\nfunction getAngle(rx, ry, x0, y0) {\n  var angle = Math.atan2(y0 * rx, x0 * ry);\n  // 转换到 0 - 2PI 内\n  return (angle + Math.PI * 2) % (Math.PI * 2);\n}\n// 根据角度获取，x,y\nfunction getPoint(rx, ry, angle) {\n  return {\n    x: rx * Math.cos(angle),\n    y: ry * Math.sin(angle)\n  };\n}\n// 旋转\nfunction rotate(x, y, angle) {\n  var cos = Math.cos(angle);\n  var sin = Math.sin(angle);\n  return [x * cos - y * sin, x * sin + y * cos];\n}\nexport default {\n  /**\n   * 计算包围盒\n   * @param {number} cx         圆心 x\n   * @param {number} cy         圆心 y\n   * @param {number} rx         x 轴方向的半径\n   * @param {number} ry         y 轴方向的半径\n   * @param {number} xRotation  旋转角度\n   * @param {number} startAngle 起始角度\n   * @param {number} endAngle   结束角度\n   * @return {object} 包围盒对象\n   */\n  box: function (cx, cy, rx, ry, xRotation, startAngle, endAngle) {\n    var xDim = xExtrema(rx, ry, xRotation);\n    var minX = Infinity;\n    var maxX = -Infinity;\n    var xs = [startAngle, endAngle];\n    for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {\n      var xAngle = xDim + i;\n      if (startAngle < endAngle) {\n        if (startAngle < xAngle && xAngle < endAngle) {\n          xs.push(xAngle);\n        }\n      } else {\n        if (endAngle < xAngle && xAngle < startAngle) {\n          xs.push(xAngle);\n        }\n      }\n    }\n    for (var i = 0; i < xs.length; i++) {\n      var x = xAt(cx, cy, rx, ry, xRotation, xs[i]);\n      if (x < minX) {\n        minX = x;\n      }\n      if (x > maxX) {\n        maxX = x;\n      }\n    }\n    var yDim = yExtrema(rx, ry, xRotation);\n    var minY = Infinity;\n    var maxY = -Infinity;\n    var ys = [startAngle, endAngle];\n    for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {\n      var yAngle = yDim + i;\n      if (startAngle < endAngle) {\n        if (startAngle < yAngle && yAngle < endAngle) {\n          ys.push(yAngle);\n        }\n      } else {\n        if (endAngle < yAngle && yAngle < startAngle) {\n          ys.push(yAngle);\n        }\n      }\n    }\n    for (var i = 0; i < ys.length; i++) {\n      var y = yAt(cx, cy, rx, ry, xRotation, ys[i]);\n      if (y < minY) {\n        minY = y;\n      }\n      if (y > maxY) {\n        maxY = y;\n      }\n    }\n    return {\n      x: minX,\n      y: minY,\n      width: maxX - minX,\n      height: maxY - minY\n    };\n  },\n  /**\n   * 获取圆弧的长度，计算圆弧长度时不考虑旋转角度，\n   * 仅跟 rx, ry, startAngle, endAngle 相关\n   * @param {number} cx         圆心 x\n   * @param {number} cy         圆心 y\n   * @param {number} rx         x 轴方向的半径\n   * @param {number} ry         y 轴方向的半径\n   * @param {number} xRotation  旋转角度\n   * @param {number} startAngle 起始角度\n   * @param {number} endAngle   结束角度\n   */\n  length: function (cx, cy, rx, ry, xRotation, startAngle, endAngle) {},\n  /**\n   * 获取指定点到圆弧的最近距离的点\n   * @param {number} cx         圆心 x\n   * @param {number} cy         圆心 y\n   * @param {number} rx         x 轴方向的半径\n   * @param {number} ry         y 轴方向的半径\n   * @param {number} xRotation  旋转角度\n   * @param {number} startAngle 起始角度\n   * @param {number} endAngle   结束角度\n   * @param {number} x0         指定点的 x\n   * @param {number} y0         指定点的 y\n   * @return {object} 到指定点最近距离的点\n   */\n  nearestPoint: function (cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {\n    // 将最近距离问题转换成到椭圆中心 0,0 没有旋转的椭圆问题\n    var relativeVector = rotate(x0 - cx, y0 - cy, -xRotation);\n    var x1 = relativeVector[0],\n      y1 = relativeVector[1];\n    // 计算点到椭圆的最近的点\n    var relativePoint = ellipse.nearestPoint(0, 0, rx, ry, x1, y1);\n    // 获取点在椭圆上的角度\n    var angle = getAngle(rx, ry, relativePoint.x, relativePoint.y);\n    // 点没有在圆弧上\n    if (angle < startAngle) {\n      // 小于起始圆弧\n      relativePoint = getPoint(rx, ry, startAngle);\n    } else if (angle > endAngle) {\n      // 大于结束圆弧\n      relativePoint = getPoint(rx, ry, endAngle);\n    }\n    // 旋转到 xRotation 的角度\n    var vector = rotate(relativePoint.x, relativePoint.y, xRotation);\n    return {\n      x: vector[0] + cx,\n      y: vector[1] + cy\n    };\n  },\n  pointDistance: function (cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {\n    var nearestPoint = this.nearestPoint(cx, cy, rx, ry, x0, y0);\n    return distance(nearestPoint.x, nearestPoint.y, x0, y0);\n  },\n  pointAt: function (cx, cy, rx, ry, xRotation, startAngle, endAngle, t) {\n    var angle = (endAngle - startAngle) * t + startAngle;\n    return {\n      x: xAt(cx, cy, rx, ry, xRotation, angle),\n      y: yAt(cx, cy, rx, ry, xRotation, angle)\n    };\n  },\n  tangentAngle: function (cx, cy, rx, ry, xRotation, startAngle, endAngle, t) {\n    var angle = (endAngle - startAngle) * t + startAngle;\n    var dx = derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle);\n    var dy = derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle);\n    return piMod(Math.atan2(dy, dx));\n  }\n};","map":{"version":3,"names":["distance","piMod","ellipse","derivativeXAt","cx","cy","rx","ry","xRotation","startAngle","endAngle","angle","Math","cos","sin","derivativeYAt","xExtrema","atan","tan","yExtrema","xAt","yAt","getAngle","x0","y0","atan2","PI","getPoint","x","y","rotate","box","xDim","minX","Infinity","maxX","xs","i","xAngle","push","length","yDim","minY","maxY","ys","yAngle","width","height","nearestPoint","relativeVector","x1","y1","relativePoint","vector","pointDistance","pointAt","t","tangentAngle","dx","dy"],"sources":["/Users/obiechina/Documents/ridy-flutter-full-taxi-solution 2/node_modules/@antv/g-math/esm/arc.js"],"sourcesContent":["import { distance, piMod } from './util';\nimport ellipse from './ellipse';\n// 偏导数 x\nfunction derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle) {\n    return -1 * rx * Math.cos(xRotation) * Math.sin(angle) - ry * Math.sin(xRotation) * Math.cos(angle);\n}\n// 偏导数 y\nfunction derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle) {\n    return -1 * rx * Math.sin(xRotation) * Math.sin(angle) + ry * Math.cos(xRotation) * Math.cos(angle);\n}\n// x 的极值\nfunction xExtrema(rx, ry, xRotation) {\n    return Math.atan((-ry / rx) * Math.tan(xRotation));\n}\n// y 的极值\nfunction yExtrema(rx, ry, xRotation) {\n    return Math.atan(ry / (rx * Math.tan(xRotation)));\n}\n// 根据角度求 x 坐标\nfunction xAt(cx, cy, rx, ry, xRotation, angle) {\n    return rx * Math.cos(xRotation) * Math.cos(angle) - ry * Math.sin(xRotation) * Math.sin(angle) + cx;\n}\n// 根据角度求 y 坐标\nfunction yAt(cx, cy, rx, ry, xRotation, angle) {\n    return rx * Math.sin(xRotation) * Math.cos(angle) + ry * Math.cos(xRotation) * Math.sin(angle) + cy;\n}\n// 获取点在椭圆上的角度\nfunction getAngle(rx, ry, x0, y0) {\n    var angle = Math.atan2(y0 * rx, x0 * ry);\n    // 转换到 0 - 2PI 内\n    return (angle + Math.PI * 2) % (Math.PI * 2);\n}\n// 根据角度获取，x,y\nfunction getPoint(rx, ry, angle) {\n    return {\n        x: rx * Math.cos(angle),\n        y: ry * Math.sin(angle),\n    };\n}\n// 旋转\nfunction rotate(x, y, angle) {\n    var cos = Math.cos(angle);\n    var sin = Math.sin(angle);\n    return [x * cos - y * sin, x * sin + y * cos];\n}\nexport default {\n    /**\n     * 计算包围盒\n     * @param {number} cx         圆心 x\n     * @param {number} cy         圆心 y\n     * @param {number} rx         x 轴方向的半径\n     * @param {number} ry         y 轴方向的半径\n     * @param {number} xRotation  旋转角度\n     * @param {number} startAngle 起始角度\n     * @param {number} endAngle   结束角度\n     * @return {object} 包围盒对象\n     */\n    box: function (cx, cy, rx, ry, xRotation, startAngle, endAngle) {\n        var xDim = xExtrema(rx, ry, xRotation);\n        var minX = Infinity;\n        var maxX = -Infinity;\n        var xs = [startAngle, endAngle];\n        for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {\n            var xAngle = xDim + i;\n            if (startAngle < endAngle) {\n                if (startAngle < xAngle && xAngle < endAngle) {\n                    xs.push(xAngle);\n                }\n            }\n            else {\n                if (endAngle < xAngle && xAngle < startAngle) {\n                    xs.push(xAngle);\n                }\n            }\n        }\n        for (var i = 0; i < xs.length; i++) {\n            var x = xAt(cx, cy, rx, ry, xRotation, xs[i]);\n            if (x < minX) {\n                minX = x;\n            }\n            if (x > maxX) {\n                maxX = x;\n            }\n        }\n        var yDim = yExtrema(rx, ry, xRotation);\n        var minY = Infinity;\n        var maxY = -Infinity;\n        var ys = [startAngle, endAngle];\n        for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {\n            var yAngle = yDim + i;\n            if (startAngle < endAngle) {\n                if (startAngle < yAngle && yAngle < endAngle) {\n                    ys.push(yAngle);\n                }\n            }\n            else {\n                if (endAngle < yAngle && yAngle < startAngle) {\n                    ys.push(yAngle);\n                }\n            }\n        }\n        for (var i = 0; i < ys.length; i++) {\n            var y = yAt(cx, cy, rx, ry, xRotation, ys[i]);\n            if (y < minY) {\n                minY = y;\n            }\n            if (y > maxY) {\n                maxY = y;\n            }\n        }\n        return {\n            x: minX,\n            y: minY,\n            width: maxX - minX,\n            height: maxY - minY,\n        };\n    },\n    /**\n     * 获取圆弧的长度，计算圆弧长度时不考虑旋转角度，\n     * 仅跟 rx, ry, startAngle, endAngle 相关\n     * @param {number} cx         圆心 x\n     * @param {number} cy         圆心 y\n     * @param {number} rx         x 轴方向的半径\n     * @param {number} ry         y 轴方向的半径\n     * @param {number} xRotation  旋转角度\n     * @param {number} startAngle 起始角度\n     * @param {number} endAngle   结束角度\n     */\n    length: function (cx, cy, rx, ry, xRotation, startAngle, endAngle) { },\n    /**\n     * 获取指定点到圆弧的最近距离的点\n     * @param {number} cx         圆心 x\n     * @param {number} cy         圆心 y\n     * @param {number} rx         x 轴方向的半径\n     * @param {number} ry         y 轴方向的半径\n     * @param {number} xRotation  旋转角度\n     * @param {number} startAngle 起始角度\n     * @param {number} endAngle   结束角度\n     * @param {number} x0         指定点的 x\n     * @param {number} y0         指定点的 y\n     * @return {object} 到指定点最近距离的点\n     */\n    nearestPoint: function (cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {\n        // 将最近距离问题转换成到椭圆中心 0,0 没有旋转的椭圆问题\n        var relativeVector = rotate(x0 - cx, y0 - cy, -xRotation);\n        var x1 = relativeVector[0], y1 = relativeVector[1];\n        // 计算点到椭圆的最近的点\n        var relativePoint = ellipse.nearestPoint(0, 0, rx, ry, x1, y1);\n        // 获取点在椭圆上的角度\n        var angle = getAngle(rx, ry, relativePoint.x, relativePoint.y);\n        // 点没有在圆弧上\n        if (angle < startAngle) {\n            // 小于起始圆弧\n            relativePoint = getPoint(rx, ry, startAngle);\n        }\n        else if (angle > endAngle) {\n            // 大于结束圆弧\n            relativePoint = getPoint(rx, ry, endAngle);\n        }\n        // 旋转到 xRotation 的角度\n        var vector = rotate(relativePoint.x, relativePoint.y, xRotation);\n        return {\n            x: vector[0] + cx,\n            y: vector[1] + cy,\n        };\n    },\n    pointDistance: function (cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {\n        var nearestPoint = this.nearestPoint(cx, cy, rx, ry, x0, y0);\n        return distance(nearestPoint.x, nearestPoint.y, x0, y0);\n    },\n    pointAt: function (cx, cy, rx, ry, xRotation, startAngle, endAngle, t) {\n        var angle = (endAngle - startAngle) * t + startAngle;\n        return {\n            x: xAt(cx, cy, rx, ry, xRotation, angle),\n            y: yAt(cx, cy, rx, ry, xRotation, angle),\n        };\n    },\n    tangentAngle: function (cx, cy, rx, ry, xRotation, startAngle, endAngle, t) {\n        var angle = (endAngle - startAngle) * t + startAngle;\n        var dx = derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle);\n        var dy = derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle);\n        return piMod(Math.atan2(dy, dx));\n    },\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}