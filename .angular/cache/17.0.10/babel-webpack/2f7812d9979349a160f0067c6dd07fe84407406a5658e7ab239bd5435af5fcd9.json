{"ast":null,"code":"import { isString, each, isArray } from './util';\nvar regexLG = /^l\\s*\\(\\s*([\\d.]+)\\s*\\)\\s*(.*)/i;\nvar regexRG = /^r\\s*\\(\\s*([\\d.]+)\\s*,\\s*([\\d.]+)\\s*,\\s*([\\d.]+)\\s*\\)\\s*(.*)/i;\nvar regexPR = /^p\\s*\\(\\s*([axyn])\\s*\\)\\s*(.*)/i;\nvar regexColorStop = /[\\d.]+:(#[^\\s]+|[^\\)]+\\))/gi;\nfunction addStop(steps, gradient) {\n  var arr = steps.match(regexColorStop);\n  each(arr, function (item) {\n    var itemArr = item.split(':');\n    gradient.addColorStop(itemArr[0], itemArr[1]);\n  });\n}\n/**\n * 将边和填充设置的颜色转换成线性渐变对象\n * @param {CanvasRenderingContext2D} context canvas 上下文\n * @param {IElement}                 element  图形元素\n * @param {string}                   gradientStr   颜色\n * @returns {any} 渐变对象\n */\nexport function parseLineGradient(context, element, gradientStr) {\n  var arr = regexLG.exec(gradientStr);\n  var angle = parseFloat(arr[1]) % 360 * (Math.PI / 180);\n  var steps = arr[2];\n  var box = element.getBBox();\n  var start;\n  var end;\n  if (angle >= 0 && angle < 1 / 2 * Math.PI) {\n    start = {\n      x: box.minX,\n      y: box.minY\n    };\n    end = {\n      x: box.maxX,\n      y: box.maxY\n    };\n  } else if (1 / 2 * Math.PI <= angle && angle < Math.PI) {\n    start = {\n      x: box.maxX,\n      y: box.minY\n    };\n    end = {\n      x: box.minX,\n      y: box.maxY\n    };\n  } else if (Math.PI <= angle && angle < 3 / 2 * Math.PI) {\n    start = {\n      x: box.maxX,\n      y: box.maxY\n    };\n    end = {\n      x: box.minX,\n      y: box.minY\n    };\n  } else {\n    start = {\n      x: box.minX,\n      y: box.maxY\n    };\n    end = {\n      x: box.maxX,\n      y: box.minY\n    };\n  }\n  var tanTheta = Math.tan(angle);\n  var tanTheta2 = tanTheta * tanTheta;\n  var x = (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;\n  var y = tanTheta * (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.y;\n  var gradient = context.createLinearGradient(start.x, start.y, x, y);\n  addStop(steps, gradient);\n  return gradient;\n}\n/**\n * 将边和填充设置的颜色转换成圆形渐变对象\n * @param {CanvasRenderingContext2D} context canvas 上下文\n * @param {IElement}                 element  图形元素\n * @param {string}                   gradientStr   颜色\n * @returns {any} 渐变对象\n */\nexport function parseRadialGradient(context, element, gradientStr) {\n  var arr = regexRG.exec(gradientStr);\n  var fx = parseFloat(arr[1]);\n  var fy = parseFloat(arr[2]);\n  var fr = parseFloat(arr[3]);\n  var steps = arr[4];\n  // 环半径为0时，默认无渐变，取渐变序列的最后一个颜色\n  if (fr === 0) {\n    var colors = steps.match(regexColorStop);\n    return colors[colors.length - 1].split(':')[1];\n  }\n  var box = element.getBBox();\n  var width = box.maxX - box.minX;\n  var height = box.maxY - box.minY;\n  var r = Math.sqrt(width * width + height * height) / 2;\n  var gradient = context.createRadialGradient(box.minX + width * fx, box.minY + height * fy, 0, box.minX + width / 2, box.minY + height / 2, fr * r);\n  addStop(steps, gradient);\n  return gradient;\n}\n/**\n * 边和填充设置的颜色转换成 pattern\n * @param {CanvasRenderingContext2D} context canvas 上下文\n * @param {IElement}                 element  图形元素\n * @param {string}                   patternStr   生成 pattern 的字符串\n */\nexport function parsePattern(context, element, patternStr) {\n  // 在转换过程中进行了缓存\n  if (element.get('patternSource') && element.get('patternSource') === patternStr) {\n    return element.get('pattern');\n  }\n  var pattern;\n  var img;\n  var arr = regexPR.exec(patternStr);\n  var repeat = arr[1];\n  var source = arr[2];\n  // Function to be called when pattern loads\n  function onload() {\n    // Create pattern\n    pattern = context.createPattern(img, repeat);\n    element.set('pattern', pattern); // be a cache\n    element.set('patternSource', patternStr);\n  }\n  switch (repeat) {\n    case 'a':\n      repeat = 'repeat';\n      break;\n    case 'x':\n      repeat = 'repeat-x';\n      break;\n    case 'y':\n      repeat = 'repeat-y';\n      break;\n    case 'n':\n      repeat = 'no-repeat';\n      break;\n    default:\n      repeat = 'no-repeat';\n  }\n  img = new Image();\n  // If source URL is not a data URL\n  if (!source.match(/^data:/i)) {\n    // Set crossOrigin for this image\n    img.crossOrigin = 'Anonymous';\n  }\n  img.src = source;\n  if (img.complete) {\n    onload();\n  } else {\n    img.onload = onload;\n    // Fix onload() bug in IE9\n    img.src = img.src;\n  }\n  return pattern;\n}\nexport function parseStyle(context, element, color) {\n  var bbox = element.getBBox();\n  if (isNaN(bbox.x) || isNaN(bbox.y) || isNaN(bbox.width) || isNaN(bbox.height)) {\n    return color;\n  }\n  if (isString(color)) {\n    if (color[1] === '(' || color[2] === '(') {\n      if (color[0] === 'l') {\n        // regexLG.test(color)\n        return parseLineGradient(context, element, color);\n      }\n      if (color[0] === 'r') {\n        // regexRG.test(color)\n        return parseRadialGradient(context, element, color);\n      }\n      if (color[0] === 'p') {\n        // regexPR.test(color)\n        return parsePattern(context, element, color);\n      }\n    }\n    return color;\n  }\n  if (color instanceof CanvasPattern) {\n    return color;\n  }\n}\nexport function parseRadius(radius) {\n  var r1 = 0;\n  var r2 = 0;\n  var r3 = 0;\n  var r4 = 0;\n  if (isArray(radius)) {\n    if (radius.length === 1) {\n      r1 = r2 = r3 = r4 = radius[0];\n    } else if (radius.length === 2) {\n      r1 = r3 = radius[0];\n      r2 = r4 = radius[1];\n    } else if (radius.length === 3) {\n      r1 = radius[0];\n      r2 = r4 = radius[1];\n      r3 = radius[2];\n    } else {\n      r1 = radius[0];\n      r2 = radius[1];\n      r3 = radius[2];\n      r4 = radius[3];\n    }\n  } else {\n    r1 = r2 = r3 = r4 = radius;\n  }\n  return [r1, r2, r3, r4];\n}","map":{"version":3,"names":["isString","each","isArray","regexLG","regexRG","regexPR","regexColorStop","addStop","steps","gradient","arr","match","item","itemArr","split","addColorStop","parseLineGradient","context","element","gradientStr","exec","angle","parseFloat","Math","PI","box","getBBox","start","end","x","minX","y","minY","maxX","maxY","tanTheta","tan","tanTheta2","createLinearGradient","parseRadialGradient","fx","fy","fr","colors","length","width","height","r","sqrt","createRadialGradient","parsePattern","patternStr","get","pattern","img","repeat","source","onload","createPattern","set","Image","crossOrigin","src","complete","parseStyle","color","bbox","isNaN","CanvasPattern","parseRadius","radius","r1","r2","r3","r4"],"sources":["/Users/obiechina/Documents/ridy-flutter-full-taxi-solution 2/node_modules/@antv/g-canvas/esm/util/parse.js"],"sourcesContent":["import { isString, each, isArray } from './util';\nvar regexLG = /^l\\s*\\(\\s*([\\d.]+)\\s*\\)\\s*(.*)/i;\nvar regexRG = /^r\\s*\\(\\s*([\\d.]+)\\s*,\\s*([\\d.]+)\\s*,\\s*([\\d.]+)\\s*\\)\\s*(.*)/i;\nvar regexPR = /^p\\s*\\(\\s*([axyn])\\s*\\)\\s*(.*)/i;\nvar regexColorStop = /[\\d.]+:(#[^\\s]+|[^\\)]+\\))/gi;\nfunction addStop(steps, gradient) {\n    var arr = steps.match(regexColorStop);\n    each(arr, function (item) {\n        var itemArr = item.split(':');\n        gradient.addColorStop(itemArr[0], itemArr[1]);\n    });\n}\n/**\n * 将边和填充设置的颜色转换成线性渐变对象\n * @param {CanvasRenderingContext2D} context canvas 上下文\n * @param {IElement}                 element  图形元素\n * @param {string}                   gradientStr   颜色\n * @returns {any} 渐变对象\n */\nexport function parseLineGradient(context, element, gradientStr) {\n    var arr = regexLG.exec(gradientStr);\n    var angle = (parseFloat(arr[1]) % 360) * (Math.PI / 180);\n    var steps = arr[2];\n    var box = element.getBBox();\n    var start;\n    var end;\n    if (angle >= 0 && angle < (1 / 2) * Math.PI) {\n        start = {\n            x: box.minX,\n            y: box.minY,\n        };\n        end = {\n            x: box.maxX,\n            y: box.maxY,\n        };\n    }\n    else if ((1 / 2) * Math.PI <= angle && angle < Math.PI) {\n        start = {\n            x: box.maxX,\n            y: box.minY,\n        };\n        end = {\n            x: box.minX,\n            y: box.maxY,\n        };\n    }\n    else if (Math.PI <= angle && angle < (3 / 2) * Math.PI) {\n        start = {\n            x: box.maxX,\n            y: box.maxY,\n        };\n        end = {\n            x: box.minX,\n            y: box.minY,\n        };\n    }\n    else {\n        start = {\n            x: box.minX,\n            y: box.maxY,\n        };\n        end = {\n            x: box.maxX,\n            y: box.minY,\n        };\n    }\n    var tanTheta = Math.tan(angle);\n    var tanTheta2 = tanTheta * tanTheta;\n    var x = (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;\n    var y = (tanTheta * (end.x - start.x + tanTheta * (end.y - start.y))) / (tanTheta2 + 1) + start.y;\n    var gradient = context.createLinearGradient(start.x, start.y, x, y);\n    addStop(steps, gradient);\n    return gradient;\n}\n/**\n * 将边和填充设置的颜色转换成圆形渐变对象\n * @param {CanvasRenderingContext2D} context canvas 上下文\n * @param {IElement}                 element  图形元素\n * @param {string}                   gradientStr   颜色\n * @returns {any} 渐变对象\n */\nexport function parseRadialGradient(context, element, gradientStr) {\n    var arr = regexRG.exec(gradientStr);\n    var fx = parseFloat(arr[1]);\n    var fy = parseFloat(arr[2]);\n    var fr = parseFloat(arr[3]);\n    var steps = arr[4];\n    // 环半径为0时，默认无渐变，取渐变序列的最后一个颜色\n    if (fr === 0) {\n        var colors = steps.match(regexColorStop);\n        return colors[colors.length - 1].split(':')[1];\n    }\n    var box = element.getBBox();\n    var width = box.maxX - box.minX;\n    var height = box.maxY - box.minY;\n    var r = Math.sqrt(width * width + height * height) / 2;\n    var gradient = context.createRadialGradient(box.minX + width * fx, box.minY + height * fy, 0, box.minX + width / 2, box.minY + height / 2, fr * r);\n    addStop(steps, gradient);\n    return gradient;\n}\n/**\n * 边和填充设置的颜色转换成 pattern\n * @param {CanvasRenderingContext2D} context canvas 上下文\n * @param {IElement}                 element  图形元素\n * @param {string}                   patternStr   生成 pattern 的字符串\n */\nexport function parsePattern(context, element, patternStr) {\n    // 在转换过程中进行了缓存\n    if (element.get('patternSource') && element.get('patternSource') === patternStr) {\n        return element.get('pattern');\n    }\n    var pattern;\n    var img;\n    var arr = regexPR.exec(patternStr);\n    var repeat = arr[1];\n    var source = arr[2];\n    // Function to be called when pattern loads\n    function onload() {\n        // Create pattern\n        pattern = context.createPattern(img, repeat);\n        element.set('pattern', pattern); // be a cache\n        element.set('patternSource', patternStr);\n    }\n    switch (repeat) {\n        case 'a':\n            repeat = 'repeat';\n            break;\n        case 'x':\n            repeat = 'repeat-x';\n            break;\n        case 'y':\n            repeat = 'repeat-y';\n            break;\n        case 'n':\n            repeat = 'no-repeat';\n            break;\n        default:\n            repeat = 'no-repeat';\n    }\n    img = new Image();\n    // If source URL is not a data URL\n    if (!source.match(/^data:/i)) {\n        // Set crossOrigin for this image\n        img.crossOrigin = 'Anonymous';\n    }\n    img.src = source;\n    if (img.complete) {\n        onload();\n    }\n    else {\n        img.onload = onload;\n        // Fix onload() bug in IE9\n        img.src = img.src;\n    }\n    return pattern;\n}\nexport function parseStyle(context, element, color) {\n    var bbox = element.getBBox();\n    if (isNaN(bbox.x) || isNaN(bbox.y) || isNaN(bbox.width) || isNaN(bbox.height)) {\n        return color;\n    }\n    if (isString(color)) {\n        if (color[1] === '(' || color[2] === '(') {\n            if (color[0] === 'l') {\n                // regexLG.test(color)\n                return parseLineGradient(context, element, color);\n            }\n            if (color[0] === 'r') {\n                // regexRG.test(color)\n                return parseRadialGradient(context, element, color);\n            }\n            if (color[0] === 'p') {\n                // regexPR.test(color)\n                return parsePattern(context, element, color);\n            }\n        }\n        return color;\n    }\n    if (color instanceof CanvasPattern) {\n        return color;\n    }\n}\nexport function parseRadius(radius) {\n    var r1 = 0;\n    var r2 = 0;\n    var r3 = 0;\n    var r4 = 0;\n    if (isArray(radius)) {\n        if (radius.length === 1) {\n            r1 = r2 = r3 = r4 = radius[0];\n        }\n        else if (radius.length === 2) {\n            r1 = r3 = radius[0];\n            r2 = r4 = radius[1];\n        }\n        else if (radius.length === 3) {\n            r1 = radius[0];\n            r2 = r4 = radius[1];\n            r3 = radius[2];\n        }\n        else {\n            r1 = radius[0];\n            r2 = radius[1];\n            r3 = radius[2];\n            r4 = radius[3];\n        }\n    }\n    else {\n        r1 = r2 = r3 = r4 = radius;\n    }\n    return [r1, r2, r3, r4];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}