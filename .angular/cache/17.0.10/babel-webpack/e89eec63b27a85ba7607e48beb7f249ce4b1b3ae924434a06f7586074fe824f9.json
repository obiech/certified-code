{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as _ from '@antv/util';\nimport Adjust from './adjust';\nvar Symmetric = /** @class */function (_super) {\n  __extends(Symmetric, _super);\n  function Symmetric() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  Symmetric.prototype.process = function (groupDataArray) {\n    var mergeData = _.flatten(groupDataArray);\n    var _a = this,\n      xField = _a.xField,\n      yField = _a.yField;\n    // 每个 x 值对应的 最大值\n    var cache = this.getXValuesMaxMap(mergeData);\n    // 所有数据的最大的值\n    var max = Math.max.apply(Math, Object.keys(cache).map(function (key) {\n      return cache[key];\n    }));\n    return _.map(groupDataArray, function (dataArray) {\n      return _.map(dataArray, function (data) {\n        var _a, _b;\n        var yValue = data[yField];\n        var xValue = data[xField];\n        // 数组处理逻辑\n        if (_.isArray(yValue)) {\n          var off_1 = (max - cache[xValue]) / 2;\n          return __assign(__assign({}, data), (_a = {}, _a[yField] = _.map(yValue, function (y) {\n            return off_1 + y;\n          }), _a));\n        }\n        // 非数组处理逻辑\n        var offset = (max - yValue) / 2;\n        return __assign(__assign({}, data), (_b = {}, _b[yField] = [offset, yValue + offset], _b));\n      });\n    });\n  };\n  // 获取每个 x 对应的最大的值\n  Symmetric.prototype.getXValuesMaxMap = function (mergeData) {\n    var _this = this;\n    var _a = this,\n      xField = _a.xField,\n      yField = _a.yField;\n    // 根据 xField 的值进行分组\n    var groupDataArray = _.groupBy(mergeData, function (data) {\n      return data[xField];\n    });\n    // 获取每个 xField 值中的最大值\n    return _.mapValues(groupDataArray, function (dataArray) {\n      return _this.getDimMaxValue(dataArray, yField);\n    });\n  };\n  Symmetric.prototype.getDimMaxValue = function (mergeData, dim) {\n    // 所有的 value 值\n    var dimValues = _.map(mergeData, function (data) {\n      return _.get(data, dim, []);\n    });\n    // 将数组打平（dim value 有可能是数组，比如 stack 之后的）\n    var flattenValues = _.flatten(dimValues);\n    // 求出数组的最大值\n    return Math.max.apply(Math, flattenValues);\n  };\n  return Symmetric;\n}(Adjust);\nexport default Symmetric;","map":{"version":3,"names":["__assign","__extends","_","Adjust","Symmetric","_super","apply","arguments","prototype","process","groupDataArray","mergeData","flatten","_a","xField","yField","cache","getXValuesMaxMap","max","Math","Object","keys","map","key","dataArray","data","_b","yValue","xValue","isArray","off_1","y","offset","_this","groupBy","mapValues","getDimMaxValue","dim","dimValues","get","flattenValues"],"sources":["/Users/obiechina/Documents/ridy-flutter-full-taxi-solution 2/node_modules/@antv/adjust/esm/adjusts/symmetric.js"],"sourcesContent":["import { __assign, __extends } from \"tslib\";\nimport * as _ from '@antv/util';\nimport Adjust from './adjust';\nvar Symmetric = /** @class */ (function (_super) {\n    __extends(Symmetric, _super);\n    function Symmetric() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Symmetric.prototype.process = function (groupDataArray) {\n        var mergeData = _.flatten(groupDataArray);\n        var _a = this, xField = _a.xField, yField = _a.yField;\n        // 每个 x 值对应的 最大值\n        var cache = this.getXValuesMaxMap(mergeData);\n        // 所有数据的最大的值\n        var max = Math.max.apply(Math, Object.keys(cache).map(function (key) { return cache[key]; }));\n        return _.map(groupDataArray, function (dataArray) {\n            return _.map(dataArray, function (data) {\n                var _a, _b;\n                var yValue = data[yField];\n                var xValue = data[xField];\n                // 数组处理逻辑\n                if (_.isArray(yValue)) {\n                    var off_1 = (max - cache[xValue]) / 2;\n                    return __assign(__assign({}, data), (_a = {}, _a[yField] = _.map(yValue, function (y) { return off_1 + y; }), _a));\n                }\n                // 非数组处理逻辑\n                var offset = (max - yValue) / 2;\n                return __assign(__assign({}, data), (_b = {}, _b[yField] = [offset, yValue + offset], _b));\n            });\n        });\n    };\n    // 获取每个 x 对应的最大的值\n    Symmetric.prototype.getXValuesMaxMap = function (mergeData) {\n        var _this = this;\n        var _a = this, xField = _a.xField, yField = _a.yField;\n        // 根据 xField 的值进行分组\n        var groupDataArray = _.groupBy(mergeData, function (data) { return data[xField]; });\n        // 获取每个 xField 值中的最大值\n        return _.mapValues(groupDataArray, function (dataArray) { return _this.getDimMaxValue(dataArray, yField); });\n    };\n    Symmetric.prototype.getDimMaxValue = function (mergeData, dim) {\n        // 所有的 value 值\n        var dimValues = _.map(mergeData, function (data) { return _.get(data, dim, []); });\n        // 将数组打平（dim value 有可能是数组，比如 stack 之后的）\n        var flattenValues = _.flatten(dimValues);\n        // 求出数组的最大值\n        return Math.max.apply(Math, flattenValues);\n    };\n    return Symmetric;\n}(Adjust));\nexport default Symmetric;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}