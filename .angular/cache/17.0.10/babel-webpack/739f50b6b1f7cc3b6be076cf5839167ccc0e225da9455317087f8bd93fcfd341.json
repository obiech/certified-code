{"ast":null,"code":"import { __assign, __rest } from \"tslib\";\nimport { wrap } from \"optimism\";\nimport { Observable, cacheSizes, getFragmentQueryDocument, mergeDeepArray } from \"../../utilities/index.js\";\nimport { WeakCache } from \"@wry/caches\";\nimport { getApolloCacheMemoryInternals } from \"../../utilities/caching/getMemoryInternals.js\";\nimport { equalByQuery } from \"../../core/equalByQuery.js\";\nvar ApolloCache = /** @class */function () {\n  function ApolloCache() {\n    this.assumeImmutableResults = false;\n    // Make sure we compute the same (===) fragment query document every\n    // time we receive the same fragment in readFragment.\n    this.getFragmentDoc = wrap(getFragmentQueryDocument, {\n      max: cacheSizes[\"cache.fragmentQueryDocuments\"] || 1000 /* defaultCacheSizes[\"cache.fragmentQueryDocuments\"] */,\n      cache: WeakCache\n    });\n  }\n  // Transactional API\n  // The batch method is intended to replace/subsume both performTransaction\n  // and recordOptimisticTransaction, but performTransaction came first, so we\n  // provide a default batch implementation that's just another way of calling\n  // performTransaction. Subclasses of ApolloCache (such as InMemoryCache) can\n  // override the batch method to do more interesting things with its options.\n  ApolloCache.prototype.batch = function (options) {\n    var _this = this;\n    var optimisticId = typeof options.optimistic === \"string\" ? options.optimistic : options.optimistic === false ? null : void 0;\n    var updateResult;\n    this.performTransaction(function () {\n      return updateResult = options.update(_this);\n    }, optimisticId);\n    return updateResult;\n  };\n  ApolloCache.prototype.recordOptimisticTransaction = function (transaction, optimisticId) {\n    this.performTransaction(transaction, optimisticId);\n  };\n  // Optional API\n  // Called once per input document, allowing the cache to make static changes\n  // to the query, such as adding __typename fields.\n  ApolloCache.prototype.transformDocument = function (document) {\n    return document;\n  };\n  // Called before each ApolloLink request, allowing the cache to make dynamic\n  // changes to the query, such as filling in missing fragment definitions.\n  ApolloCache.prototype.transformForLink = function (document) {\n    return document;\n  };\n  ApolloCache.prototype.identify = function (object) {\n    return;\n  };\n  ApolloCache.prototype.gc = function () {\n    return [];\n  };\n  ApolloCache.prototype.modify = function (options) {\n    return false;\n  };\n  // DataProxy API\n  ApolloCache.prototype.readQuery = function (options, optimistic) {\n    if (optimistic === void 0) {\n      optimistic = !!options.optimistic;\n    }\n    return this.read(__assign(__assign({}, options), {\n      rootId: options.id || \"ROOT_QUERY\",\n      optimistic: optimistic\n    }));\n  };\n  /** {@inheritDoc @apollo/client!ApolloClient#watchFragment:member(1)} */\n  ApolloCache.prototype.watchFragment = function (options) {\n    var _this = this;\n    var fragment = options.fragment,\n      fragmentName = options.fragmentName,\n      from = options.from,\n      _a = options.optimistic,\n      optimistic = _a === void 0 ? true : _a,\n      otherOptions = __rest(options, [\"fragment\", \"fragmentName\", \"from\", \"optimistic\"]);\n    var query = this.getFragmentDoc(fragment, fragmentName);\n    var diffOptions = __assign(__assign({}, otherOptions), {\n      returnPartialData: true,\n      id:\n      // While our TypeScript types do not allow for `undefined` as a valid\n      // `from`, its possible `useFragment` gives us an `undefined` since it\n      // calls` cache.identify` and provides that value to `from`. We are\n      // adding this fix here however to ensure those using plain JavaScript\n      // and using `cache.identify` themselves will avoid seeing the obscure\n      // warning.\n      typeof from === \"undefined\" || typeof from === \"string\" ? from : this.identify(from),\n      query: query,\n      optimistic: optimistic\n    });\n    var latestDiff;\n    return new Observable(function (observer) {\n      return _this.watch(__assign(__assign({}, diffOptions), {\n        immediate: true,\n        callback: function (diff) {\n          if (\n          // Always ensure we deliver the first result\n          latestDiff && equalByQuery(query, {\n            data: latestDiff === null || latestDiff === void 0 ? void 0 : latestDiff.result\n          }, {\n            data: diff.result\n          })) {\n            return;\n          }\n          var result = {\n            data: diff.result,\n            complete: !!diff.complete\n          };\n          if (diff.missing) {\n            result.missing = mergeDeepArray(diff.missing.map(function (error) {\n              return error.missing;\n            }));\n          }\n          latestDiff = diff;\n          observer.next(result);\n        }\n      }));\n    });\n  };\n  ApolloCache.prototype.readFragment = function (options, optimistic) {\n    if (optimistic === void 0) {\n      optimistic = !!options.optimistic;\n    }\n    return this.read(__assign(__assign({}, options), {\n      query: this.getFragmentDoc(options.fragment, options.fragmentName),\n      rootId: options.id,\n      optimistic: optimistic\n    }));\n  };\n  ApolloCache.prototype.writeQuery = function (_a) {\n    var id = _a.id,\n      data = _a.data,\n      options = __rest(_a, [\"id\", \"data\"]);\n    return this.write(Object.assign(options, {\n      dataId: id || \"ROOT_QUERY\",\n      result: data\n    }));\n  };\n  ApolloCache.prototype.writeFragment = function (_a) {\n    var id = _a.id,\n      data = _a.data,\n      fragment = _a.fragment,\n      fragmentName = _a.fragmentName,\n      options = __rest(_a, [\"id\", \"data\", \"fragment\", \"fragmentName\"]);\n    return this.write(Object.assign(options, {\n      query: this.getFragmentDoc(fragment, fragmentName),\n      dataId: id,\n      result: data\n    }));\n  };\n  ApolloCache.prototype.updateQuery = function (options, update) {\n    return this.batch({\n      update: function (cache) {\n        var value = cache.readQuery(options);\n        var data = update(value);\n        if (data === void 0 || data === null) return value;\n        cache.writeQuery(__assign(__assign({}, options), {\n          data: data\n        }));\n        return data;\n      }\n    });\n  };\n  ApolloCache.prototype.updateFragment = function (options, update) {\n    return this.batch({\n      update: function (cache) {\n        var value = cache.readFragment(options);\n        var data = update(value);\n        if (data === void 0 || data === null) return value;\n        cache.writeFragment(__assign(__assign({}, options), {\n          data: data\n        }));\n        return data;\n      }\n    });\n  };\n  return ApolloCache;\n}();\nexport { ApolloCache };\nif (globalThis.__DEV__ !== false) {\n  ApolloCache.prototype.getMemoryInternals = getApolloCacheMemoryInternals;\n}","map":{"version":3,"names":["__assign","__rest","wrap","Observable","cacheSizes","getFragmentQueryDocument","mergeDeepArray","WeakCache","getApolloCacheMemoryInternals","equalByQuery","ApolloCache","assumeImmutableResults","getFragmentDoc","max","cache","prototype","batch","options","_this","optimisticId","optimistic","updateResult","performTransaction","update","recordOptimisticTransaction","transaction","transformDocument","document","transformForLink","identify","object","gc","modify","readQuery","read","rootId","id","watchFragment","fragment","fragmentName","from","_a","otherOptions","query","diffOptions","returnPartialData","latestDiff","observer","watch","immediate","callback","diff","data","result","complete","missing","map","error","next","readFragment","writeQuery","write","Object","assign","dataId","writeFragment","updateQuery","value","updateFragment","globalThis","__DEV__","getMemoryInternals"],"sources":["/Users/obiechina/Documents/ridy-flutter-full-taxi-solution 2/node_modules/@apollo/client/cache/core/cache.js"],"sourcesContent":["import { __assign, __rest } from \"tslib\";\nimport { wrap } from \"optimism\";\nimport { Observable, cacheSizes, getFragmentQueryDocument, mergeDeepArray, } from \"../../utilities/index.js\";\nimport { WeakCache } from \"@wry/caches\";\nimport { getApolloCacheMemoryInternals } from \"../../utilities/caching/getMemoryInternals.js\";\nimport { equalByQuery } from \"../../core/equalByQuery.js\";\nvar ApolloCache = /** @class */ (function () {\n    function ApolloCache() {\n        this.assumeImmutableResults = false;\n        // Make sure we compute the same (===) fragment query document every\n        // time we receive the same fragment in readFragment.\n        this.getFragmentDoc = wrap(getFragmentQueryDocument, {\n            max: cacheSizes[\"cache.fragmentQueryDocuments\"] ||\n                1000 /* defaultCacheSizes[\"cache.fragmentQueryDocuments\"] */,\n            cache: WeakCache,\n        });\n    }\n    // Transactional API\n    // The batch method is intended to replace/subsume both performTransaction\n    // and recordOptimisticTransaction, but performTransaction came first, so we\n    // provide a default batch implementation that's just another way of calling\n    // performTransaction. Subclasses of ApolloCache (such as InMemoryCache) can\n    // override the batch method to do more interesting things with its options.\n    ApolloCache.prototype.batch = function (options) {\n        var _this = this;\n        var optimisticId = typeof options.optimistic === \"string\" ? options.optimistic\n            : options.optimistic === false ? null\n                : void 0;\n        var updateResult;\n        this.performTransaction(function () { return (updateResult = options.update(_this)); }, optimisticId);\n        return updateResult;\n    };\n    ApolloCache.prototype.recordOptimisticTransaction = function (transaction, optimisticId) {\n        this.performTransaction(transaction, optimisticId);\n    };\n    // Optional API\n    // Called once per input document, allowing the cache to make static changes\n    // to the query, such as adding __typename fields.\n    ApolloCache.prototype.transformDocument = function (document) {\n        return document;\n    };\n    // Called before each ApolloLink request, allowing the cache to make dynamic\n    // changes to the query, such as filling in missing fragment definitions.\n    ApolloCache.prototype.transformForLink = function (document) {\n        return document;\n    };\n    ApolloCache.prototype.identify = function (object) {\n        return;\n    };\n    ApolloCache.prototype.gc = function () {\n        return [];\n    };\n    ApolloCache.prototype.modify = function (options) {\n        return false;\n    };\n    // DataProxy API\n    ApolloCache.prototype.readQuery = function (options, optimistic) {\n        if (optimistic === void 0) { optimistic = !!options.optimistic; }\n        return this.read(__assign(__assign({}, options), { rootId: options.id || \"ROOT_QUERY\", optimistic: optimistic }));\n    };\n    /** {@inheritDoc @apollo/client!ApolloClient#watchFragment:member(1)} */\n    ApolloCache.prototype.watchFragment = function (options) {\n        var _this = this;\n        var fragment = options.fragment, fragmentName = options.fragmentName, from = options.from, _a = options.optimistic, optimistic = _a === void 0 ? true : _a, otherOptions = __rest(options, [\"fragment\", \"fragmentName\", \"from\", \"optimistic\"]);\n        var query = this.getFragmentDoc(fragment, fragmentName);\n        var diffOptions = __assign(__assign({}, otherOptions), { returnPartialData: true, id: \n            // While our TypeScript types do not allow for `undefined` as a valid\n            // `from`, its possible `useFragment` gives us an `undefined` since it\n            // calls` cache.identify` and provides that value to `from`. We are\n            // adding this fix here however to ensure those using plain JavaScript\n            // and using `cache.identify` themselves will avoid seeing the obscure\n            // warning.\n            typeof from === \"undefined\" || typeof from === \"string\" ?\n                from\n                : this.identify(from), query: query, optimistic: optimistic });\n        var latestDiff;\n        return new Observable(function (observer) {\n            return _this.watch(__assign(__assign({}, diffOptions), { immediate: true, callback: function (diff) {\n                    if (\n                    // Always ensure we deliver the first result\n                    latestDiff &&\n                        equalByQuery(query, { data: latestDiff === null || latestDiff === void 0 ? void 0 : latestDiff.result }, { data: diff.result })) {\n                        return;\n                    }\n                    var result = {\n                        data: diff.result,\n                        complete: !!diff.complete,\n                    };\n                    if (diff.missing) {\n                        result.missing = mergeDeepArray(diff.missing.map(function (error) { return error.missing; }));\n                    }\n                    latestDiff = diff;\n                    observer.next(result);\n                } }));\n        });\n    };\n    ApolloCache.prototype.readFragment = function (options, optimistic) {\n        if (optimistic === void 0) { optimistic = !!options.optimistic; }\n        return this.read(__assign(__assign({}, options), { query: this.getFragmentDoc(options.fragment, options.fragmentName), rootId: options.id, optimistic: optimistic }));\n    };\n    ApolloCache.prototype.writeQuery = function (_a) {\n        var id = _a.id, data = _a.data, options = __rest(_a, [\"id\", \"data\"]);\n        return this.write(Object.assign(options, {\n            dataId: id || \"ROOT_QUERY\",\n            result: data,\n        }));\n    };\n    ApolloCache.prototype.writeFragment = function (_a) {\n        var id = _a.id, data = _a.data, fragment = _a.fragment, fragmentName = _a.fragmentName, options = __rest(_a, [\"id\", \"data\", \"fragment\", \"fragmentName\"]);\n        return this.write(Object.assign(options, {\n            query: this.getFragmentDoc(fragment, fragmentName),\n            dataId: id,\n            result: data,\n        }));\n    };\n    ApolloCache.prototype.updateQuery = function (options, update) {\n        return this.batch({\n            update: function (cache) {\n                var value = cache.readQuery(options);\n                var data = update(value);\n                if (data === void 0 || data === null)\n                    return value;\n                cache.writeQuery(__assign(__assign({}, options), { data: data }));\n                return data;\n            },\n        });\n    };\n    ApolloCache.prototype.updateFragment = function (options, update) {\n        return this.batch({\n            update: function (cache) {\n                var value = cache.readFragment(options);\n                var data = update(value);\n                if (data === void 0 || data === null)\n                    return value;\n                cache.writeFragment(__assign(__assign({}, options), { data: data }));\n                return data;\n            },\n        });\n    };\n    return ApolloCache;\n}());\nexport { ApolloCache };\nif (globalThis.__DEV__ !== false) {\n    ApolloCache.prototype.getMemoryInternals = getApolloCacheMemoryInternals;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}