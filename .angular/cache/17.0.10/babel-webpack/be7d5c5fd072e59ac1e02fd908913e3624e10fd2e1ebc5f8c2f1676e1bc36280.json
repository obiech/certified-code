{"ast":null,"code":"/**\n * @fileoverview 椭圆\n * @author dxq613@gmail.com\n */\nimport { __assign, __extends } from \"tslib\";\nimport ShapeBase from './base';\n// 根据椭圆公式计算 x*x/rx*rx + y*y/ry*ry;\nfunction ellipseDistance(squareX, squareY, rx, ry) {\n  return squareX / (rx * rx) + squareY / (ry * ry);\n}\nvar Ellipse = /** @class */function (_super) {\n  __extends(Ellipse, _super);\n  function Ellipse() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  Ellipse.prototype.getDefaultAttrs = function () {\n    var attrs = _super.prototype.getDefaultAttrs.call(this);\n    return __assign(__assign({}, attrs), {\n      x: 0,\n      y: 0,\n      rx: 0,\n      ry: 0\n    });\n  };\n  Ellipse.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {\n    var attrs = this.attr();\n    var halfLineWith = lineWidth / 2;\n    var cx = attrs.x;\n    var cy = attrs.y;\n    var rx = attrs.rx,\n      ry = attrs.ry;\n    var squareX = (x - cx) * (x - cx);\n    var squareY = (y - cy) * (y - cy);\n    // 使用椭圆的公式： x*x/rx*rx + y*y/ry*ry = 1;\n    if (isFill && isStroke) {\n      return ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;\n    }\n    if (isFill) {\n      return ellipseDistance(squareX, squareY, rx, ry) <= 1;\n    }\n    if (isStroke) {\n      return ellipseDistance(squareX, squareY, rx - halfLineWith, ry - halfLineWith) >= 1 && ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;\n    }\n    return false;\n  };\n  Ellipse.prototype.createPath = function (context) {\n    var attrs = this.attr();\n    var cx = attrs.x;\n    var cy = attrs.y;\n    var rx = attrs.rx;\n    var ry = attrs.ry;\n    context.beginPath();\n    // 兼容逻辑\n    if (context.ellipse) {\n      context.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2, false);\n    } else {\n      // 如果不支持，则使用圆来绘制，进行变形\n      var r = rx > ry ? rx : ry;\n      var scaleX = rx > ry ? 1 : rx / ry;\n      var scaleY = rx > ry ? ry / rx : 1;\n      context.save();\n      context.translate(cx, cy);\n      context.scale(scaleX, scaleY);\n      context.arc(0, 0, r, 0, Math.PI * 2);\n      context.restore();\n      context.closePath();\n    }\n  };\n  return Ellipse;\n}(ShapeBase);\nexport default Ellipse;","map":{"version":3,"names":["__assign","__extends","ShapeBase","ellipseDistance","squareX","squareY","rx","ry","Ellipse","_super","apply","arguments","prototype","getDefaultAttrs","attrs","call","x","y","isInStrokeOrPath","isStroke","isFill","lineWidth","attr","halfLineWith","cx","cy","createPath","context","beginPath","ellipse","Math","PI","r","scaleX","scaleY","save","translate","scale","arc","restore","closePath"],"sources":["/Users/obiechina/Documents/ridy-flutter-full-taxi-solution 2/node_modules/@antv/g-canvas/esm/shape/ellipse.js"],"sourcesContent":["/**\n * @fileoverview 椭圆\n * @author dxq613@gmail.com\n */\nimport { __assign, __extends } from \"tslib\";\nimport ShapeBase from './base';\n// 根据椭圆公式计算 x*x/rx*rx + y*y/ry*ry;\nfunction ellipseDistance(squareX, squareY, rx, ry) {\n    return squareX / (rx * rx) + squareY / (ry * ry);\n}\nvar Ellipse = /** @class */ (function (_super) {\n    __extends(Ellipse, _super);\n    function Ellipse() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Ellipse.prototype.getDefaultAttrs = function () {\n        var attrs = _super.prototype.getDefaultAttrs.call(this);\n        return __assign(__assign({}, attrs), { x: 0, y: 0, rx: 0, ry: 0 });\n    };\n    Ellipse.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {\n        var attrs = this.attr();\n        var halfLineWith = lineWidth / 2;\n        var cx = attrs.x;\n        var cy = attrs.y;\n        var rx = attrs.rx, ry = attrs.ry;\n        var squareX = (x - cx) * (x - cx);\n        var squareY = (y - cy) * (y - cy);\n        // 使用椭圆的公式： x*x/rx*rx + y*y/ry*ry = 1;\n        if (isFill && isStroke) {\n            return ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;\n        }\n        if (isFill) {\n            return ellipseDistance(squareX, squareY, rx, ry) <= 1;\n        }\n        if (isStroke) {\n            return (ellipseDistance(squareX, squareY, rx - halfLineWith, ry - halfLineWith) >= 1 &&\n                ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1);\n        }\n        return false;\n    };\n    Ellipse.prototype.createPath = function (context) {\n        var attrs = this.attr();\n        var cx = attrs.x;\n        var cy = attrs.y;\n        var rx = attrs.rx;\n        var ry = attrs.ry;\n        context.beginPath();\n        // 兼容逻辑\n        if (context.ellipse) {\n            context.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2, false);\n        }\n        else {\n            // 如果不支持，则使用圆来绘制，进行变形\n            var r = rx > ry ? rx : ry;\n            var scaleX = rx > ry ? 1 : rx / ry;\n            var scaleY = rx > ry ? ry / rx : 1;\n            context.save();\n            context.translate(cx, cy);\n            context.scale(scaleX, scaleY);\n            context.arc(0, 0, r, 0, Math.PI * 2);\n            context.restore();\n            context.closePath();\n        }\n    };\n    return Ellipse;\n}(ShapeBase));\nexport default Ellipse;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}