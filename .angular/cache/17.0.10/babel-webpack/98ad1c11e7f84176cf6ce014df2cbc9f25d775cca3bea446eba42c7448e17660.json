{"ast":null,"code":"import { each, isArray, max, min } from '@antv/util';\nimport { parseStyle } from './parse';\nimport getArcParams from './arc-params';\nimport { mergeRegion, intersectRect } from './util';\nimport * as ArrowUtil from '../util/arrow';\nvar SHAPE_ATTRS_MAP = {\n  fill: 'fillStyle',\n  stroke: 'strokeStyle',\n  opacity: 'globalAlpha'\n};\nexport function applyAttrsToContext(context, element) {\n  var attrs = element.attr();\n  for (var k in attrs) {\n    var v = attrs[k];\n    // 转换一下不与 canvas 兼容的属性名\n    var name_1 = SHAPE_ATTRS_MAP[k] ? SHAPE_ATTRS_MAP[k] : k;\n    if (name_1 === 'matrix' && v) {\n      // 设置矩阵\n      context.transform(v[0], v[1], v[3], v[4], v[6], v[7]);\n    } else if (name_1 === 'lineDash' && context.setLineDash) {\n      // 设置虚线，只支持数组形式，非数组形式不做任何操作\n      isArray(v) && context.setLineDash(v);\n    } else {\n      if (name_1 === 'strokeStyle' || name_1 === 'fillStyle') {\n        // 如果存在渐变、pattern 这个开销有些大\n        // 可以考虑缓存机制，通过 hasUpdate 来避免一些运算\n        v = parseStyle(context, element, v);\n      } else if (name_1 === 'globalAlpha') {\n        // opacity 效果可以叠加，子元素的 opacity 需要与父元素 opacity 相乘\n        v = v * context.globalAlpha;\n      }\n      context[name_1] = v;\n    }\n  }\n}\nexport function drawChildren(context, children, region) {\n  for (var i = 0; i < children.length; i++) {\n    var child = children[i];\n    if (child.cfg.visible) {\n      child.draw(context, region);\n    } else {\n      child.skipDraw();\n    }\n  }\n}\n// 这个地方的逻辑比较复杂，简单画了一张图：https://www.yuque.com/antv/ou292n/pcgt5g#OW1QE\nexport function checkRefresh(canvas, children, region) {\n  var refreshElements = canvas.get('refreshElements');\n  // 先遍历需要刷新的元素，将这些元素的父元素也设置 refresh\n  each(refreshElements, function (el) {\n    if (el !== canvas) {\n      var parent_1 = el.cfg.parent;\n      while (parent_1 && parent_1 !== canvas && !parent_1.cfg.refresh) {\n        parent_1.cfg.refresh = true;\n        parent_1 = parent_1.cfg.parent;\n      }\n    }\n  });\n  if (refreshElements[0] === canvas) {\n    setChildrenRefresh(children, region);\n  } else {\n    // 检查所有子元素是否可以刷新\n    checkChildrenRefresh(children, region);\n  }\n}\n// 检查所有的子元素是否应该更新\nexport function checkChildrenRefresh(children, region) {\n  for (var i = 0; i < children.length; i++) {\n    var child = children[i];\n    if (child.cfg.visible) {\n      // 先判断 hasChanged，因为它的优先级判断应该高于 refresh\n      if (child.cfg.hasChanged) {\n        // 如果节点发生了 change，则需要级联设置子元素的 refresh\n        child.cfg.refresh = true;\n        if (child.isGroup()) {\n          setChildrenRefresh(child.cfg.children, region);\n        }\n      } else if (child.cfg.refresh) {\n        // 如果当前图形/分组 refresh = true，说明其子节点存在 changed\n        if (child.isGroup()) {\n          checkChildrenRefresh(child.cfg.children, region);\n        }\n      } else {\n        // 这个分支说明此次局部刷新，所有的节点和父元素没有发生变化，仅需要检查包围盒（缓存）是否相交即可\n        var refresh = checkElementRefresh(child, region);\n        child.cfg.refresh = refresh;\n        if (refresh && child.isGroup()) {\n          // 如果需要刷新，说明子元素也需要刷新，继续进行判定\n          checkChildrenRefresh(child.cfg.children, region);\n        }\n      }\n    }\n  }\n}\n// 由于对改变的图形放入 refreshElements 时做了优化，判定父元素 changed 时不加入\n// 那么有可能会出现 elements 都为空，所以最终 group\nexport function clearChanged(elements) {\n  for (var i = 0; i < elements.length; i++) {\n    var el = elements[i];\n    el.cfg.hasChanged = false;\n    // 级联清理\n    if (el.isGroup() && !el.destroyed) {\n      clearChanged(el.cfg.children);\n    }\n  }\n}\n// 当某个父元素发生改变时，调用这个方法级联设置 refresh\nfunction setChildrenRefresh(children, region) {\n  for (var i = 0; i < children.length; i++) {\n    var child = children[i];\n    if (!child.cfg.visible) {\n      continue;\n    }\n    // let refresh = true;\n    // 获取缓存的 bbox，如果这个 bbox 还存在则说明父元素不是矩阵发生了改变\n    // const bbox = child.cfg.canvasBBox;\n    // if (bbox) {\n    //   // 如果这时候\n    //   refresh = intersectRect(bbox, region);\n    // }\n    child.cfg.refresh = true;\n    // 如果需要刷新当前节点，所有的子元素设置 refresh\n    if (child.isGroup()) {\n      setChildrenRefresh(child.get('children'), region);\n    }\n  }\n}\nfunction checkElementRefresh(shape, region) {\n  var bbox = shape.cfg.cacheCanvasBBox;\n  var isAllow = shape.cfg.isInView && bbox && intersectRect(bbox, region);\n  return isAllow;\n}\n// 绘制 path\nexport function drawPath(shape, context, attrs, arcParamsCache) {\n  var path = attrs.path,\n    startArrow = attrs.startArrow,\n    endArrow = attrs.endArrow;\n  if (!path) {\n    return;\n  }\n  var currentPoint = [0, 0]; // 当前图形\n  var startMovePoint = [0, 0]; // 开始 M 的点，可能会有多个\n  var distance = {\n    dx: 0,\n    dy: 0\n  };\n  context.beginPath();\n  for (var i = 0; i < path.length; i++) {\n    var params = path[i];\n    var command = params[0];\n    if (i === 0 && startArrow && startArrow.d) {\n      var tangent = shape.getStartTangent();\n      distance = ArrowUtil.getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], startArrow.d);\n    } else if (i === path.length - 2 && path[i + 1][0] === 'Z' && endArrow && endArrow.d) {\n      // 为了防止结尾为 Z 的 segment 缩短不起效，需要取最后两个 segment 特殊处理\n      var lastPath = path[i + 1];\n      if (lastPath[0] === 'Z') {\n        var tangent = shape.getEndTangent();\n        distance = ArrowUtil.getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);\n      }\n    } else if (i === path.length - 1 && endArrow && endArrow.d) {\n      if (path[0] !== 'Z') {\n        var tangent = shape.getEndTangent();\n        distance = ArrowUtil.getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);\n      }\n    }\n    var dx = distance.dx,\n      dy = distance.dy;\n    // V,H,S,T 都在前面被转换成标准形式\n    switch (command) {\n      case 'M':\n        context.moveTo(params[1] - dx, params[2] - dy);\n        startMovePoint = [params[1], params[2]];\n        break;\n      case 'L':\n        context.lineTo(params[1] - dx, params[2] - dy);\n        break;\n      case 'Q':\n        context.quadraticCurveTo(params[1], params[2], params[3] - dx, params[4] - dy);\n        break;\n      case 'C':\n        context.bezierCurveTo(params[1], params[2], params[3], params[4], params[5] - dx, params[6] - dy);\n        break;\n      case 'A':\n        {\n          var arcParams = void 0;\n          // 为了加速绘制，可以提供参数的缓存，各个图形自己缓存\n          if (arcParamsCache) {\n            arcParams = arcParamsCache[i];\n            if (!arcParams) {\n              arcParams = getArcParams(currentPoint, params);\n              arcParamsCache[i] = arcParams;\n            }\n          } else {\n            arcParams = getArcParams(currentPoint, params);\n          }\n          var cx = arcParams.cx,\n            cy = arcParams.cy,\n            rx = arcParams.rx,\n            ry = arcParams.ry,\n            startAngle = arcParams.startAngle,\n            endAngle = arcParams.endAngle,\n            xRotation = arcParams.xRotation,\n            sweepFlag = arcParams.sweepFlag;\n          // 直接使用椭圆的 api\n          if (context.ellipse) {\n            context.ellipse(cx, cy, rx, ry, xRotation, startAngle, endAngle, 1 - sweepFlag);\n          } else {\n            var r = rx > ry ? rx : ry;\n            var scaleX = rx > ry ? 1 : rx / ry;\n            var scaleY = rx > ry ? ry / rx : 1;\n            context.translate(cx, cy);\n            context.rotate(xRotation);\n            context.scale(scaleX, scaleY);\n            context.arc(0, 0, r, startAngle, endAngle, 1 - sweepFlag);\n            context.scale(1 / scaleX, 1 / scaleY);\n            context.rotate(-xRotation);\n            context.translate(-cx, -cy);\n          }\n          break;\n        }\n      case 'Z':\n        context.closePath();\n        break;\n      default:\n        break;\n    }\n    // 有了 Z 后，当前节点从开始 M 的点开始\n    if (command === 'Z') {\n      currentPoint = startMovePoint;\n    } else {\n      var len = params.length;\n      currentPoint = [params[len - 2], params[len - 1]];\n    }\n  }\n}\n// 刷新图形元素(Shape 或者 Group)\nexport function refreshElement(element, changeType) {\n  var canvas = element.get('canvas');\n  // 只有存在于 canvas 上时生效\n  if (canvas) {\n    if (changeType === 'remove') {\n      // 一旦 remove，则无法在 element 上拿到包围盒\n      // destroy 后所有属性都拿不到，所以需要暂存一下\n      // 这是一段 hack 的代码\n      element._cacheCanvasBBox = element.get('cacheCanvasBBox');\n    }\n    // 防止反复刷新\n    if (!element.get('hasChanged')) {\n      // 但是始终要标记为 hasChanged，便于后面进行局部渲染\n      element.set('hasChanged', true);\n      // 本来只有局部渲染模式下，才需要记录更新的元素队列\n      // if (canvas.get('localRefresh')) {\n      //   canvas.refreshElement(element, changeType, canvas);\n      // }\n      // 但对于 https://github.com/antvis/g/issues/422 的场景，全局渲染的模式下也需要记录更新的元素队列\n      // 如果当前元素的父元素发生了改变，可以不放入队列，这句话大概能够提升 15% 的初次渲染性能\n      if (!(element.cfg.parent && element.cfg.parent.get('hasChanged'))) {\n        canvas.refreshElement(element, changeType, canvas);\n        if (canvas.get('autoDraw')) {\n          canvas.draw();\n        }\n      }\n    }\n  }\n}\nexport function getRefreshRegion(element) {\n  var region;\n  if (!element.destroyed) {\n    var cacheBox = element.get('cacheCanvasBBox');\n    var validCache = cacheBox && !!(cacheBox.width && cacheBox.height);\n    var bbox = element.getCanvasBBox();\n    var validBBox = bbox && !!(bbox.width && bbox.height);\n    // 是否是有效 bbox 判定，一些 NaN 或者 宽高为 0 的情况过滤掉\n    if (validCache && validBBox) {\n      region = mergeRegion(cacheBox, bbox);\n    } else if (validCache) {\n      region = cacheBox;\n    } else if (validBBox) {\n      region = bbox;\n    }\n  } else {\n    // 因为元素已经销毁所以无法获取到缓存的包围盒\n    region = element['_cacheCanvasBBox'];\n  }\n  return region;\n}\nexport function getMergedRegion(elements) {\n  if (!elements.length) {\n    return null;\n  }\n  var minXArr = [];\n  var minYArr = [];\n  var maxXArr = [];\n  var maxYArr = [];\n  each(elements, function (el) {\n    var region = getRefreshRegion(el);\n    if (region) {\n      minXArr.push(region.minX);\n      minYArr.push(region.minY);\n      maxXArr.push(region.maxX);\n      maxYArr.push(region.maxY);\n    }\n  });\n  return {\n    minX: min(minXArr),\n    minY: min(minYArr),\n    maxX: max(maxXArr),\n    maxY: max(maxYArr)\n  };\n}\nexport function mergeView(region, viewRegion) {\n  if (!region || !viewRegion) {\n    return null;\n  }\n  // 不相交，则直接返回 null\n  if (!intersectRect(region, viewRegion)) {\n    return null;\n  }\n  return {\n    minX: Math.max(region.minX, viewRegion.minX),\n    minY: Math.max(region.minY, viewRegion.minY),\n    maxX: Math.min(region.maxX, viewRegion.maxX),\n    maxY: Math.min(region.maxY, viewRegion.maxY)\n  };\n}","map":{"version":3,"names":["each","isArray","max","min","parseStyle","getArcParams","mergeRegion","intersectRect","ArrowUtil","SHAPE_ATTRS_MAP","fill","stroke","opacity","applyAttrsToContext","context","element","attrs","attr","k","v","name_1","transform","setLineDash","globalAlpha","drawChildren","children","region","i","length","child","cfg","visible","draw","skipDraw","checkRefresh","canvas","refreshElements","get","el","parent_1","parent","refresh","setChildrenRefresh","checkChildrenRefresh","hasChanged","isGroup","checkElementRefresh","clearChanged","elements","destroyed","shape","bbox","cacheCanvasBBox","isAllow","isInView","drawPath","arcParamsCache","path","startArrow","endArrow","currentPoint","startMovePoint","distance","dx","dy","beginPath","params","command","d","tangent","getStartTangent","getShortenOffset","lastPath","getEndTangent","moveTo","lineTo","quadraticCurveTo","bezierCurveTo","arcParams","cx","cy","rx","ry","startAngle","endAngle","xRotation","sweepFlag","ellipse","r","scaleX","scaleY","translate","rotate","scale","arc","closePath","len","refreshElement","changeType","_cacheCanvasBBox","set","getRefreshRegion","cacheBox","validCache","width","height","getCanvasBBox","validBBox","getMergedRegion","minXArr","minYArr","maxXArr","maxYArr","push","minX","minY","maxX","maxY","mergeView","viewRegion","Math"],"sources":["/Users/obiechina/Documents/ridy-flutter-full-taxi-solution 2/node_modules/@antv/g-canvas/esm/util/draw.js"],"sourcesContent":["import { each, isArray, max, min } from '@antv/util';\nimport { parseStyle } from './parse';\nimport getArcParams from './arc-params';\nimport { mergeRegion, intersectRect } from './util';\nimport * as ArrowUtil from '../util/arrow';\nvar SHAPE_ATTRS_MAP = {\n    fill: 'fillStyle',\n    stroke: 'strokeStyle',\n    opacity: 'globalAlpha',\n};\nexport function applyAttrsToContext(context, element) {\n    var attrs = element.attr();\n    for (var k in attrs) {\n        var v = attrs[k];\n        // 转换一下不与 canvas 兼容的属性名\n        var name_1 = SHAPE_ATTRS_MAP[k] ? SHAPE_ATTRS_MAP[k] : k;\n        if (name_1 === 'matrix' && v) {\n            // 设置矩阵\n            context.transform(v[0], v[1], v[3], v[4], v[6], v[7]);\n        }\n        else if (name_1 === 'lineDash' && context.setLineDash) {\n            // 设置虚线，只支持数组形式，非数组形式不做任何操作\n            isArray(v) && context.setLineDash(v);\n        }\n        else {\n            if (name_1 === 'strokeStyle' || name_1 === 'fillStyle') {\n                // 如果存在渐变、pattern 这个开销有些大\n                // 可以考虑缓存机制，通过 hasUpdate 来避免一些运算\n                v = parseStyle(context, element, v);\n            }\n            else if (name_1 === 'globalAlpha') {\n                // opacity 效果可以叠加，子元素的 opacity 需要与父元素 opacity 相乘\n                v = v * context.globalAlpha;\n            }\n            context[name_1] = v;\n        }\n    }\n}\nexport function drawChildren(context, children, region) {\n    for (var i = 0; i < children.length; i++) {\n        var child = children[i];\n        if (child.cfg.visible) {\n            child.draw(context, region);\n        }\n        else {\n            child.skipDraw();\n        }\n    }\n}\n// 这个地方的逻辑比较复杂，简单画了一张图：https://www.yuque.com/antv/ou292n/pcgt5g#OW1QE\nexport function checkRefresh(canvas, children, region) {\n    var refreshElements = canvas.get('refreshElements');\n    // 先遍历需要刷新的元素，将这些元素的父元素也设置 refresh\n    each(refreshElements, function (el) {\n        if (el !== canvas) {\n            var parent_1 = el.cfg.parent;\n            while (parent_1 && parent_1 !== canvas && !parent_1.cfg.refresh) {\n                parent_1.cfg.refresh = true;\n                parent_1 = parent_1.cfg.parent;\n            }\n        }\n    });\n    if (refreshElements[0] === canvas) {\n        setChildrenRefresh(children, region);\n    }\n    else {\n        // 检查所有子元素是否可以刷新\n        checkChildrenRefresh(children, region);\n    }\n}\n// 检查所有的子元素是否应该更新\nexport function checkChildrenRefresh(children, region) {\n    for (var i = 0; i < children.length; i++) {\n        var child = children[i];\n        if (child.cfg.visible) {\n            // 先判断 hasChanged，因为它的优先级判断应该高于 refresh\n            if (child.cfg.hasChanged) {\n                // 如果节点发生了 change，则需要级联设置子元素的 refresh\n                child.cfg.refresh = true;\n                if (child.isGroup()) {\n                    setChildrenRefresh(child.cfg.children, region);\n                }\n            }\n            else if (child.cfg.refresh) {\n                // 如果当前图形/分组 refresh = true，说明其子节点存在 changed\n                if (child.isGroup()) {\n                    checkChildrenRefresh(child.cfg.children, region);\n                }\n            }\n            else {\n                // 这个分支说明此次局部刷新，所有的节点和父元素没有发生变化，仅需要检查包围盒（缓存）是否相交即可\n                var refresh = checkElementRefresh(child, region);\n                child.cfg.refresh = refresh;\n                if (refresh && child.isGroup()) {\n                    // 如果需要刷新，说明子元素也需要刷新，继续进行判定\n                    checkChildrenRefresh(child.cfg.children, region);\n                }\n            }\n        }\n    }\n}\n// 由于对改变的图形放入 refreshElements 时做了优化，判定父元素 changed 时不加入\n// 那么有可能会出现 elements 都为空，所以最终 group\nexport function clearChanged(elements) {\n    for (var i = 0; i < elements.length; i++) {\n        var el = elements[i];\n        el.cfg.hasChanged = false;\n        // 级联清理\n        if (el.isGroup() && !el.destroyed) {\n            clearChanged(el.cfg.children);\n        }\n    }\n}\n// 当某个父元素发生改变时，调用这个方法级联设置 refresh\nfunction setChildrenRefresh(children, region) {\n    for (var i = 0; i < children.length; i++) {\n        var child = children[i];\n        if (!child.cfg.visible) {\n            continue;\n        }\n        // let refresh = true;\n        // 获取缓存的 bbox，如果这个 bbox 还存在则说明父元素不是矩阵发生了改变\n        // const bbox = child.cfg.canvasBBox;\n        // if (bbox) {\n        //   // 如果这时候\n        //   refresh = intersectRect(bbox, region);\n        // }\n        child.cfg.refresh = true;\n        // 如果需要刷新当前节点，所有的子元素设置 refresh\n        if (child.isGroup()) {\n            setChildrenRefresh(child.get('children'), region);\n        }\n    }\n}\nfunction checkElementRefresh(shape, region) {\n    var bbox = shape.cfg.cacheCanvasBBox;\n    var isAllow = shape.cfg.isInView && bbox && intersectRect(bbox, region);\n    return isAllow;\n}\n// 绘制 path\nexport function drawPath(shape, context, attrs, arcParamsCache) {\n    var path = attrs.path, startArrow = attrs.startArrow, endArrow = attrs.endArrow;\n    if (!path) {\n        return;\n    }\n    var currentPoint = [0, 0]; // 当前图形\n    var startMovePoint = [0, 0]; // 开始 M 的点，可能会有多个\n    var distance = {\n        dx: 0,\n        dy: 0,\n    };\n    context.beginPath();\n    for (var i = 0; i < path.length; i++) {\n        var params = path[i];\n        var command = params[0];\n        if (i === 0 && startArrow && startArrow.d) {\n            var tangent = shape.getStartTangent();\n            distance = ArrowUtil.getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], startArrow.d);\n        }\n        else if (i === path.length - 2 && path[i + 1][0] === 'Z' && endArrow && endArrow.d) {\n            // 为了防止结尾为 Z 的 segment 缩短不起效，需要取最后两个 segment 特殊处理\n            var lastPath = path[i + 1];\n            if (lastPath[0] === 'Z') {\n                var tangent = shape.getEndTangent();\n                distance = ArrowUtil.getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);\n            }\n        }\n        else if (i === path.length - 1 && endArrow && endArrow.d) {\n            if (path[0] !== 'Z') {\n                var tangent = shape.getEndTangent();\n                distance = ArrowUtil.getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);\n            }\n        }\n        var dx = distance.dx, dy = distance.dy;\n        // V,H,S,T 都在前面被转换成标准形式\n        switch (command) {\n            case 'M':\n                context.moveTo(params[1] - dx, params[2] - dy);\n                startMovePoint = [params[1], params[2]];\n                break;\n            case 'L':\n                context.lineTo(params[1] - dx, params[2] - dy);\n                break;\n            case 'Q':\n                context.quadraticCurveTo(params[1], params[2], params[3] - dx, params[4] - dy);\n                break;\n            case 'C':\n                context.bezierCurveTo(params[1], params[2], params[3], params[4], params[5] - dx, params[6] - dy);\n                break;\n            case 'A': {\n                var arcParams = void 0;\n                // 为了加速绘制，可以提供参数的缓存，各个图形自己缓存\n                if (arcParamsCache) {\n                    arcParams = arcParamsCache[i];\n                    if (!arcParams) {\n                        arcParams = getArcParams(currentPoint, params);\n                        arcParamsCache[i] = arcParams;\n                    }\n                }\n                else {\n                    arcParams = getArcParams(currentPoint, params);\n                }\n                var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation, sweepFlag = arcParams.sweepFlag;\n                // 直接使用椭圆的 api\n                if (context.ellipse) {\n                    context.ellipse(cx, cy, rx, ry, xRotation, startAngle, endAngle, 1 - sweepFlag);\n                }\n                else {\n                    var r = rx > ry ? rx : ry;\n                    var scaleX = rx > ry ? 1 : rx / ry;\n                    var scaleY = rx > ry ? ry / rx : 1;\n                    context.translate(cx, cy);\n                    context.rotate(xRotation);\n                    context.scale(scaleX, scaleY);\n                    context.arc(0, 0, r, startAngle, endAngle, 1 - sweepFlag);\n                    context.scale(1 / scaleX, 1 / scaleY);\n                    context.rotate(-xRotation);\n                    context.translate(-cx, -cy);\n                }\n                break;\n            }\n            case 'Z':\n                context.closePath();\n                break;\n            default:\n                break;\n        }\n        // 有了 Z 后，当前节点从开始 M 的点开始\n        if (command === 'Z') {\n            currentPoint = startMovePoint;\n        }\n        else {\n            var len = params.length;\n            currentPoint = [params[len - 2], params[len - 1]];\n        }\n    }\n}\n// 刷新图形元素(Shape 或者 Group)\nexport function refreshElement(element, changeType) {\n    var canvas = element.get('canvas');\n    // 只有存在于 canvas 上时生效\n    if (canvas) {\n        if (changeType === 'remove') {\n            // 一旦 remove，则无法在 element 上拿到包围盒\n            // destroy 后所有属性都拿不到，所以需要暂存一下\n            // 这是一段 hack 的代码\n            element._cacheCanvasBBox = element.get('cacheCanvasBBox');\n        }\n        // 防止反复刷新\n        if (!element.get('hasChanged')) {\n            // 但是始终要标记为 hasChanged，便于后面进行局部渲染\n            element.set('hasChanged', true);\n            // 本来只有局部渲染模式下，才需要记录更新的元素队列\n            // if (canvas.get('localRefresh')) {\n            //   canvas.refreshElement(element, changeType, canvas);\n            // }\n            // 但对于 https://github.com/antvis/g/issues/422 的场景，全局渲染的模式下也需要记录更新的元素队列\n            // 如果当前元素的父元素发生了改变，可以不放入队列，这句话大概能够提升 15% 的初次渲染性能\n            if (!(element.cfg.parent && element.cfg.parent.get('hasChanged'))) {\n                canvas.refreshElement(element, changeType, canvas);\n                if (canvas.get('autoDraw')) {\n                    canvas.draw();\n                }\n            }\n        }\n    }\n}\nexport function getRefreshRegion(element) {\n    var region;\n    if (!element.destroyed) {\n        var cacheBox = element.get('cacheCanvasBBox');\n        var validCache = cacheBox && !!(cacheBox.width && cacheBox.height);\n        var bbox = element.getCanvasBBox();\n        var validBBox = bbox && !!(bbox.width && bbox.height);\n        // 是否是有效 bbox 判定，一些 NaN 或者 宽高为 0 的情况过滤掉\n        if (validCache && validBBox) {\n            region = mergeRegion(cacheBox, bbox);\n        }\n        else if (validCache) {\n            region = cacheBox;\n        }\n        else if (validBBox) {\n            region = bbox;\n        }\n    }\n    else {\n        // 因为元素已经销毁所以无法获取到缓存的包围盒\n        region = element['_cacheCanvasBBox'];\n    }\n    return region;\n}\nexport function getMergedRegion(elements) {\n    if (!elements.length) {\n        return null;\n    }\n    var minXArr = [];\n    var minYArr = [];\n    var maxXArr = [];\n    var maxYArr = [];\n    each(elements, function (el) {\n        var region = getRefreshRegion(el);\n        if (region) {\n            minXArr.push(region.minX);\n            minYArr.push(region.minY);\n            maxXArr.push(region.maxX);\n            maxYArr.push(region.maxY);\n        }\n    });\n    return {\n        minX: min(minXArr),\n        minY: min(minYArr),\n        maxX: max(maxXArr),\n        maxY: max(maxYArr),\n    };\n}\nexport function mergeView(region, viewRegion) {\n    if (!region || !viewRegion) {\n        return null;\n    }\n    // 不相交，则直接返回 null\n    if (!intersectRect(region, viewRegion)) {\n        return null;\n    }\n    return {\n        minX: Math.max(region.minX, viewRegion.minX),\n        minY: Math.max(region.minY, viewRegion.minY),\n        maxX: Math.min(region.maxX, viewRegion.maxX),\n        maxY: Math.min(region.maxY, viewRegion.maxY),\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}