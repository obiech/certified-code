{"ast":null,"code":"import { isEqual, isNumber, isFunction } from '@antv/util';\nimport * as d3Timer from 'd3-timer';\nimport { interpolate, interpolateArray } from 'd3-interpolate'; // 目前整体动画只需要数值和数组的差值计算\nimport { getEasing } from './register';\nimport * as PathUtil from '../util/path';\nimport { isColorProp, isGradientColor } from '../util/color';\nvar IDENTITY_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n/**\n * 使用 ratio 进行插值计算来更新属性\n * @param {IElement}  shape    元素\n * @param {Animation} animation 动画\n * @param {number}    ratio    比例\n * @return {boolean}  动画是否执行完成\n */\nfunction _update(shape, animation, ratio) {\n  var cProps = {}; // 此刻属性\n  var fromAttrs = animation.fromAttrs,\n    toAttrs = animation.toAttrs;\n  if (shape.destroyed) {\n    return;\n  }\n  var interf; //  差值函数\n  for (var k in toAttrs) {\n    if (!isEqual(fromAttrs[k], toAttrs[k])) {\n      if (k === 'path') {\n        var toPath = toAttrs[k];\n        var fromPath = fromAttrs[k];\n        if (toPath.length > fromPath.length) {\n          toPath = PathUtil.parsePathString(toAttrs[k]); // 终点状态\n          fromPath = PathUtil.parsePathString(fromAttrs[k]); // 起始状态\n          fromPath = PathUtil.fillPathByDiff(fromPath, toPath);\n          fromPath = PathUtil.formatPath(fromPath, toPath);\n          animation.fromAttrs.path = fromPath;\n          animation.toAttrs.path = toPath;\n        } else if (!animation.pathFormatted) {\n          toPath = PathUtil.parsePathString(toAttrs[k]);\n          fromPath = PathUtil.parsePathString(fromAttrs[k]);\n          fromPath = PathUtil.formatPath(fromPath, toPath);\n          animation.fromAttrs.path = fromPath;\n          animation.toAttrs.path = toPath;\n          animation.pathFormatted = true;\n        }\n        cProps[k] = [];\n        for (var i = 0; i < toPath.length; i++) {\n          var toPathPoint = toPath[i];\n          var fromPathPoint = fromPath[i];\n          var cPathPoint = [];\n          for (var j = 0; j < toPathPoint.length; j++) {\n            if (isNumber(toPathPoint[j]) && fromPathPoint && isNumber(fromPathPoint[j])) {\n              interf = interpolate(fromPathPoint[j], toPathPoint[j]);\n              cPathPoint.push(interf(ratio));\n            } else {\n              cPathPoint.push(toPathPoint[j]);\n            }\n          }\n          cProps[k].push(cPathPoint);\n        }\n      } else if (k === 'matrix') {\n        /*\n         对矩阵进行插值时，需要保证矩阵不为空，为空则使用单位矩阵\n         TODO: 二维和三维场景下单位矩阵不同，之后 WebGL 版需要做进一步处理\n         */\n        var matrixFn = interpolateArray(fromAttrs[k] || IDENTITY_MATRIX, toAttrs[k] || IDENTITY_MATRIX);\n        var currentMatrix = matrixFn(ratio);\n        cProps[k] = currentMatrix;\n      } else if (isColorProp(k) && isGradientColor(toAttrs[k])) {\n        cProps[k] = toAttrs[k];\n      } else if (!isFunction(toAttrs[k])) {\n        // 非函数类型的值才能做插值\n        interf = interpolate(fromAttrs[k], toAttrs[k]);\n        cProps[k] = interf(ratio);\n      }\n    }\n  }\n  shape.attr(cProps);\n}\n/**\n * 根据自定义帧动画函数 onFrame 来更新属性\n * @param {IElement}  shape    元素\n * @param {Animation} animation 动画\n * @param {number}    elapsed  动画执行时间(毫秒)\n * @return {boolean}  动画是否执行完成\n */\nfunction update(shape, animation, elapsed) {\n  var startTime = animation.startTime,\n    delay = animation.delay;\n  // 如果还没有开始执行或暂停，先不更新\n  if (elapsed < startTime + delay || animation._paused) {\n    return false;\n  }\n  var ratio;\n  var duration = animation.duration;\n  var easing = animation.easing;\n  var easeFn = getEasing(easing);\n  // 已执行时间\n  elapsed = elapsed - startTime - animation.delay;\n  if (animation.repeat) {\n    // 如果动画重复执行，则 elapsed > duration，计算 ratio 时需取模\n    ratio = elapsed % duration / duration;\n    ratio = easeFn(ratio);\n  } else {\n    ratio = elapsed / duration;\n    if (ratio < 1) {\n      // 动画未执行完\n      ratio = easeFn(ratio);\n    } else {\n      // 动画已执行完\n      if (animation.onFrame) {\n        shape.attr(animation.onFrame(1));\n      } else {\n        shape.attr(animation.toAttrs);\n      }\n      return true;\n    }\n  }\n  if (animation.onFrame) {\n    var attrs = animation.onFrame(ratio);\n    shape.attr(attrs);\n  } else {\n    _update(shape, animation, ratio);\n  }\n  return false;\n}\nvar Timeline = /** @class */function () {\n  /**\n   * 时间轴构造函数，依赖于画布\n   * @param {}\n   */\n  function Timeline(canvas) {\n    /**\n     * 执行动画的元素列表\n     * @type {IElement[]}\n     */\n    this.animators = [];\n    /**\n     * 当前时间\n     * @type {number}\n     */\n    this.current = 0;\n    /**\n     * 定时器\n     * @type {d3Timer.Timer}\n     */\n    this.timer = null;\n    this.canvas = canvas;\n  }\n  /**\n   * 初始化定时器\n   */\n  Timeline.prototype.initTimer = function () {\n    var _this = this;\n    var isFinished = false;\n    var shape;\n    var animations;\n    var animation;\n    this.timer = d3Timer.timer(function (elapsed) {\n      _this.current = elapsed;\n      if (_this.animators.length > 0) {\n        for (var i = _this.animators.length - 1; i >= 0; i--) {\n          shape = _this.animators[i];\n          if (shape.destroyed) {\n            // 如果已经被销毁，直接移出队列\n            _this.removeAnimator(i);\n            continue;\n          }\n          if (!shape.isAnimatePaused()) {\n            animations = shape.get('animations');\n            for (var j = animations.length - 1; j >= 0; j--) {\n              animation = animations[j];\n              isFinished = update(shape, animation, elapsed);\n              if (isFinished) {\n                animations.splice(j, 1);\n                isFinished = false;\n                if (animation.callback) {\n                  animation.callback();\n                }\n              }\n            }\n          }\n          if (animations.length === 0) {\n            _this.removeAnimator(i);\n          }\n        }\n        var autoDraw = _this.canvas.get('autoDraw');\n        // 非自动渲染模式下，手动调用 canvas.draw() 重新渲染\n        if (!autoDraw) {\n          _this.canvas.draw();\n        }\n      }\n    });\n  };\n  /**\n   * 增加动画元素\n   */\n  Timeline.prototype.addAnimator = function (shape) {\n    this.animators.push(shape);\n  };\n  /**\n   * 移除动画元素\n   */\n  Timeline.prototype.removeAnimator = function (index) {\n    this.animators.splice(index, 1);\n  };\n  /**\n   * 是否有动画在执行\n   */\n  Timeline.prototype.isAnimating = function () {\n    return !!this.animators.length;\n  };\n  /**\n   * 停止定时器\n   */\n  Timeline.prototype.stop = function () {\n    if (this.timer) {\n      this.timer.stop();\n    }\n  };\n  /**\n   * 停止时间轴上所有元素的动画，并置空动画元素列表\n   * @param {boolean} toEnd 是否到动画的最终状态，用来透传给动画元素的 stopAnimate 方法\n   */\n  Timeline.prototype.stopAllAnimations = function (toEnd) {\n    if (toEnd === void 0) {\n      toEnd = true;\n    }\n    this.animators.forEach(function (animator) {\n      animator.stopAnimate(toEnd);\n    });\n    this.animators = [];\n    this.canvas.draw();\n  };\n  /**\n   * 获取当前时间\n   */\n  Timeline.prototype.getTime = function () {\n    return this.current;\n  };\n  return Timeline;\n}();\nexport default Timeline;","map":{"version":3,"names":["isEqual","isNumber","isFunction","d3Timer","interpolate","interpolateArray","getEasing","PathUtil","isColorProp","isGradientColor","IDENTITY_MATRIX","_update","shape","animation","ratio","cProps","fromAttrs","toAttrs","destroyed","interf","k","toPath","fromPath","length","parsePathString","fillPathByDiff","formatPath","path","pathFormatted","i","toPathPoint","fromPathPoint","cPathPoint","j","push","matrixFn","currentMatrix","attr","update","elapsed","startTime","delay","_paused","duration","easing","easeFn","repeat","onFrame","attrs","Timeline","canvas","animators","current","timer","prototype","initTimer","_this","isFinished","animations","removeAnimator","isAnimatePaused","get","splice","callback","autoDraw","draw","addAnimator","index","isAnimating","stop","stopAllAnimations","toEnd","forEach","animator","stopAnimate","getTime"],"sources":["/Users/obiechina/Documents/ridy-flutter-full-taxi-solution 2/node_modules/@antv/g-base/esm/animate/timeline.js"],"sourcesContent":["import { isEqual, isNumber, isFunction } from '@antv/util';\nimport * as d3Timer from 'd3-timer';\nimport { interpolate, interpolateArray } from 'd3-interpolate'; // 目前整体动画只需要数值和数组的差值计算\nimport { getEasing } from './register';\nimport * as PathUtil from '../util/path';\nimport { isColorProp, isGradientColor } from '../util/color';\nvar IDENTITY_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n/**\n * 使用 ratio 进行插值计算来更新属性\n * @param {IElement}  shape    元素\n * @param {Animation} animation 动画\n * @param {number}    ratio    比例\n * @return {boolean}  动画是否执行完成\n */\nfunction _update(shape, animation, ratio) {\n    var cProps = {}; // 此刻属性\n    var fromAttrs = animation.fromAttrs, toAttrs = animation.toAttrs;\n    if (shape.destroyed) {\n        return;\n    }\n    var interf; //  差值函数\n    for (var k in toAttrs) {\n        if (!isEqual(fromAttrs[k], toAttrs[k])) {\n            if (k === 'path') {\n                var toPath = toAttrs[k];\n                var fromPath = fromAttrs[k];\n                if (toPath.length > fromPath.length) {\n                    toPath = PathUtil.parsePathString(toAttrs[k]); // 终点状态\n                    fromPath = PathUtil.parsePathString(fromAttrs[k]); // 起始状态\n                    fromPath = PathUtil.fillPathByDiff(fromPath, toPath);\n                    fromPath = PathUtil.formatPath(fromPath, toPath);\n                    animation.fromAttrs.path = fromPath;\n                    animation.toAttrs.path = toPath;\n                }\n                else if (!animation.pathFormatted) {\n                    toPath = PathUtil.parsePathString(toAttrs[k]);\n                    fromPath = PathUtil.parsePathString(fromAttrs[k]);\n                    fromPath = PathUtil.formatPath(fromPath, toPath);\n                    animation.fromAttrs.path = fromPath;\n                    animation.toAttrs.path = toPath;\n                    animation.pathFormatted = true;\n                }\n                cProps[k] = [];\n                for (var i = 0; i < toPath.length; i++) {\n                    var toPathPoint = toPath[i];\n                    var fromPathPoint = fromPath[i];\n                    var cPathPoint = [];\n                    for (var j = 0; j < toPathPoint.length; j++) {\n                        if (isNumber(toPathPoint[j]) && fromPathPoint && isNumber(fromPathPoint[j])) {\n                            interf = interpolate(fromPathPoint[j], toPathPoint[j]);\n                            cPathPoint.push(interf(ratio));\n                        }\n                        else {\n                            cPathPoint.push(toPathPoint[j]);\n                        }\n                    }\n                    cProps[k].push(cPathPoint);\n                }\n            }\n            else if (k === 'matrix') {\n                /*\n                 对矩阵进行插值时，需要保证矩阵不为空，为空则使用单位矩阵\n                 TODO: 二维和三维场景下单位矩阵不同，之后 WebGL 版需要做进一步处理\n                 */\n                var matrixFn = interpolateArray(fromAttrs[k] || IDENTITY_MATRIX, toAttrs[k] || IDENTITY_MATRIX);\n                var currentMatrix = matrixFn(ratio);\n                cProps[k] = currentMatrix;\n            }\n            else if (isColorProp(k) && isGradientColor(toAttrs[k])) {\n                cProps[k] = toAttrs[k];\n            }\n            else if (!isFunction(toAttrs[k])) {\n                // 非函数类型的值才能做插值\n                interf = interpolate(fromAttrs[k], toAttrs[k]);\n                cProps[k] = interf(ratio);\n            }\n        }\n    }\n    shape.attr(cProps);\n}\n/**\n * 根据自定义帧动画函数 onFrame 来更新属性\n * @param {IElement}  shape    元素\n * @param {Animation} animation 动画\n * @param {number}    elapsed  动画执行时间(毫秒)\n * @return {boolean}  动画是否执行完成\n */\nfunction update(shape, animation, elapsed) {\n    var startTime = animation.startTime, delay = animation.delay;\n    // 如果还没有开始执行或暂停，先不更新\n    if (elapsed < startTime + delay || animation._paused) {\n        return false;\n    }\n    var ratio;\n    var duration = animation.duration;\n    var easing = animation.easing;\n    var easeFn = getEasing(easing);\n    // 已执行时间\n    elapsed = elapsed - startTime - animation.delay;\n    if (animation.repeat) {\n        // 如果动画重复执行，则 elapsed > duration，计算 ratio 时需取模\n        ratio = (elapsed % duration) / duration;\n        ratio = easeFn(ratio);\n    }\n    else {\n        ratio = elapsed / duration;\n        if (ratio < 1) {\n            // 动画未执行完\n            ratio = easeFn(ratio);\n        }\n        else {\n            // 动画已执行完\n            if (animation.onFrame) {\n                shape.attr(animation.onFrame(1));\n            }\n            else {\n                shape.attr(animation.toAttrs);\n            }\n            return true;\n        }\n    }\n    if (animation.onFrame) {\n        var attrs = animation.onFrame(ratio);\n        shape.attr(attrs);\n    }\n    else {\n        _update(shape, animation, ratio);\n    }\n    return false;\n}\nvar Timeline = /** @class */ (function () {\n    /**\n     * 时间轴构造函数，依赖于画布\n     * @param {}\n     */\n    function Timeline(canvas) {\n        /**\n         * 执行动画的元素列表\n         * @type {IElement[]}\n         */\n        this.animators = [];\n        /**\n         * 当前时间\n         * @type {number}\n         */\n        this.current = 0;\n        /**\n         * 定时器\n         * @type {d3Timer.Timer}\n         */\n        this.timer = null;\n        this.canvas = canvas;\n    }\n    /**\n     * 初始化定时器\n     */\n    Timeline.prototype.initTimer = function () {\n        var _this = this;\n        var isFinished = false;\n        var shape;\n        var animations;\n        var animation;\n        this.timer = d3Timer.timer(function (elapsed) {\n            _this.current = elapsed;\n            if (_this.animators.length > 0) {\n                for (var i = _this.animators.length - 1; i >= 0; i--) {\n                    shape = _this.animators[i];\n                    if (shape.destroyed) {\n                        // 如果已经被销毁，直接移出队列\n                        _this.removeAnimator(i);\n                        continue;\n                    }\n                    if (!shape.isAnimatePaused()) {\n                        animations = shape.get('animations');\n                        for (var j = animations.length - 1; j >= 0; j--) {\n                            animation = animations[j];\n                            isFinished = update(shape, animation, elapsed);\n                            if (isFinished) {\n                                animations.splice(j, 1);\n                                isFinished = false;\n                                if (animation.callback) {\n                                    animation.callback();\n                                }\n                            }\n                        }\n                    }\n                    if (animations.length === 0) {\n                        _this.removeAnimator(i);\n                    }\n                }\n                var autoDraw = _this.canvas.get('autoDraw');\n                // 非自动渲染模式下，手动调用 canvas.draw() 重新渲染\n                if (!autoDraw) {\n                    _this.canvas.draw();\n                }\n            }\n        });\n    };\n    /**\n     * 增加动画元素\n     */\n    Timeline.prototype.addAnimator = function (shape) {\n        this.animators.push(shape);\n    };\n    /**\n     * 移除动画元素\n     */\n    Timeline.prototype.removeAnimator = function (index) {\n        this.animators.splice(index, 1);\n    };\n    /**\n     * 是否有动画在执行\n     */\n    Timeline.prototype.isAnimating = function () {\n        return !!this.animators.length;\n    };\n    /**\n     * 停止定时器\n     */\n    Timeline.prototype.stop = function () {\n        if (this.timer) {\n            this.timer.stop();\n        }\n    };\n    /**\n     * 停止时间轴上所有元素的动画，并置空动画元素列表\n     * @param {boolean} toEnd 是否到动画的最终状态，用来透传给动画元素的 stopAnimate 方法\n     */\n    Timeline.prototype.stopAllAnimations = function (toEnd) {\n        if (toEnd === void 0) { toEnd = true; }\n        this.animators.forEach(function (animator) {\n            animator.stopAnimate(toEnd);\n        });\n        this.animators = [];\n        this.canvas.draw();\n    };\n    /**\n     * 获取当前时间\n     */\n    Timeline.prototype.getTime = function () {\n        return this.current;\n    };\n    return Timeline;\n}());\nexport default Timeline;\n"],"mappings":"AAAA,SAASA,OAAO,EAAEC,QAAQ,EAAEC,UAAU,QAAQ,YAAY;AAC1D,OAAO,KAAKC,OAAO,MAAM,UAAU;AACnC,SAASC,WAAW,EAAEC,gBAAgB,QAAQ,gBAAgB,CAAC,CAAC;AAChE,SAASC,SAAS,QAAQ,YAAY;AACtC,OAAO,KAAKC,QAAQ,MAAM,cAAc;AACxC,SAASC,WAAW,EAAEC,eAAe,QAAQ,eAAe;AAC5D,IAAIC,eAAe,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,OAAOA,CAACC,KAAK,EAAEC,SAAS,EAAEC,KAAK,EAAE;EACtC,IAAIC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;EACjB,IAAIC,SAAS,GAAGH,SAAS,CAACG,SAAS;IAAEC,OAAO,GAAGJ,SAAS,CAACI,OAAO;EAChE,IAAIL,KAAK,CAACM,SAAS,EAAE;IACjB;EACJ;EACA,IAAIC,MAAM,CAAC,CAAC;EACZ,KAAK,IAAIC,CAAC,IAAIH,OAAO,EAAE;IACnB,IAAI,CAACjB,OAAO,CAACgB,SAAS,CAACI,CAAC,CAAC,EAAEH,OAAO,CAACG,CAAC,CAAC,CAAC,EAAE;MACpC,IAAIA,CAAC,KAAK,MAAM,EAAE;QACd,IAAIC,MAAM,GAAGJ,OAAO,CAACG,CAAC,CAAC;QACvB,IAAIE,QAAQ,GAAGN,SAAS,CAACI,CAAC,CAAC;QAC3B,IAAIC,MAAM,CAACE,MAAM,GAAGD,QAAQ,CAACC,MAAM,EAAE;UACjCF,MAAM,GAAGd,QAAQ,CAACiB,eAAe,CAACP,OAAO,CAACG,CAAC,CAAC,CAAC,CAAC,CAAC;UAC/CE,QAAQ,GAAGf,QAAQ,CAACiB,eAAe,CAACR,SAAS,CAACI,CAAC,CAAC,CAAC,CAAC,CAAC;UACnDE,QAAQ,GAAGf,QAAQ,CAACkB,cAAc,CAACH,QAAQ,EAAED,MAAM,CAAC;UACpDC,QAAQ,GAAGf,QAAQ,CAACmB,UAAU,CAACJ,QAAQ,EAAED,MAAM,CAAC;UAChDR,SAAS,CAACG,SAAS,CAACW,IAAI,GAAGL,QAAQ;UACnCT,SAAS,CAACI,OAAO,CAACU,IAAI,GAAGN,MAAM;QACnC,CAAC,MACI,IAAI,CAACR,SAAS,CAACe,aAAa,EAAE;UAC/BP,MAAM,GAAGd,QAAQ,CAACiB,eAAe,CAACP,OAAO,CAACG,CAAC,CAAC,CAAC;UAC7CE,QAAQ,GAAGf,QAAQ,CAACiB,eAAe,CAACR,SAAS,CAACI,CAAC,CAAC,CAAC;UACjDE,QAAQ,GAAGf,QAAQ,CAACmB,UAAU,CAACJ,QAAQ,EAAED,MAAM,CAAC;UAChDR,SAAS,CAACG,SAAS,CAACW,IAAI,GAAGL,QAAQ;UACnCT,SAAS,CAACI,OAAO,CAACU,IAAI,GAAGN,MAAM;UAC/BR,SAAS,CAACe,aAAa,GAAG,IAAI;QAClC;QACAb,MAAM,CAACK,CAAC,CAAC,GAAG,EAAE;QACd,KAAK,IAAIS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,MAAM,CAACE,MAAM,EAAEM,CAAC,EAAE,EAAE;UACpC,IAAIC,WAAW,GAAGT,MAAM,CAACQ,CAAC,CAAC;UAC3B,IAAIE,aAAa,GAAGT,QAAQ,CAACO,CAAC,CAAC;UAC/B,IAAIG,UAAU,GAAG,EAAE;UACnB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,WAAW,CAACP,MAAM,EAAEU,CAAC,EAAE,EAAE;YACzC,IAAIhC,QAAQ,CAAC6B,WAAW,CAACG,CAAC,CAAC,CAAC,IAAIF,aAAa,IAAI9B,QAAQ,CAAC8B,aAAa,CAACE,CAAC,CAAC,CAAC,EAAE;cACzEd,MAAM,GAAGf,WAAW,CAAC2B,aAAa,CAACE,CAAC,CAAC,EAAEH,WAAW,CAACG,CAAC,CAAC,CAAC;cACtDD,UAAU,CAACE,IAAI,CAACf,MAAM,CAACL,KAAK,CAAC,CAAC;YAClC,CAAC,MACI;cACDkB,UAAU,CAACE,IAAI,CAACJ,WAAW,CAACG,CAAC,CAAC,CAAC;YACnC;UACJ;UACAlB,MAAM,CAACK,CAAC,CAAC,CAACc,IAAI,CAACF,UAAU,CAAC;QAC9B;MACJ,CAAC,MACI,IAAIZ,CAAC,KAAK,QAAQ,EAAE;QACrB;AAChB;AACA;AACA;QACgB,IAAIe,QAAQ,GAAG9B,gBAAgB,CAACW,SAAS,CAACI,CAAC,CAAC,IAAIV,eAAe,EAAEO,OAAO,CAACG,CAAC,CAAC,IAAIV,eAAe,CAAC;QAC/F,IAAI0B,aAAa,GAAGD,QAAQ,CAACrB,KAAK,CAAC;QACnCC,MAAM,CAACK,CAAC,CAAC,GAAGgB,aAAa;MAC7B,CAAC,MACI,IAAI5B,WAAW,CAACY,CAAC,CAAC,IAAIX,eAAe,CAACQ,OAAO,CAACG,CAAC,CAAC,CAAC,EAAE;QACpDL,MAAM,CAACK,CAAC,CAAC,GAAGH,OAAO,CAACG,CAAC,CAAC;MAC1B,CAAC,MACI,IAAI,CAAClB,UAAU,CAACe,OAAO,CAACG,CAAC,CAAC,CAAC,EAAE;QAC9B;QACAD,MAAM,GAAGf,WAAW,CAACY,SAAS,CAACI,CAAC,CAAC,EAAEH,OAAO,CAACG,CAAC,CAAC,CAAC;QAC9CL,MAAM,CAACK,CAAC,CAAC,GAAGD,MAAM,CAACL,KAAK,CAAC;MAC7B;IACJ;EACJ;EACAF,KAAK,CAACyB,IAAI,CAACtB,MAAM,CAAC;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASuB,MAAMA,CAAC1B,KAAK,EAAEC,SAAS,EAAE0B,OAAO,EAAE;EACvC,IAAIC,SAAS,GAAG3B,SAAS,CAAC2B,SAAS;IAAEC,KAAK,GAAG5B,SAAS,CAAC4B,KAAK;EAC5D;EACA,IAAIF,OAAO,GAAGC,SAAS,GAAGC,KAAK,IAAI5B,SAAS,CAAC6B,OAAO,EAAE;IAClD,OAAO,KAAK;EAChB;EACA,IAAI5B,KAAK;EACT,IAAI6B,QAAQ,GAAG9B,SAAS,CAAC8B,QAAQ;EACjC,IAAIC,MAAM,GAAG/B,SAAS,CAAC+B,MAAM;EAC7B,IAAIC,MAAM,GAAGvC,SAAS,CAACsC,MAAM,CAAC;EAC9B;EACAL,OAAO,GAAGA,OAAO,GAAGC,SAAS,GAAG3B,SAAS,CAAC4B,KAAK;EAC/C,IAAI5B,SAAS,CAACiC,MAAM,EAAE;IAClB;IACAhC,KAAK,GAAIyB,OAAO,GAAGI,QAAQ,GAAIA,QAAQ;IACvC7B,KAAK,GAAG+B,MAAM,CAAC/B,KAAK,CAAC;EACzB,CAAC,MACI;IACDA,KAAK,GAAGyB,OAAO,GAAGI,QAAQ;IAC1B,IAAI7B,KAAK,GAAG,CAAC,EAAE;MACX;MACAA,KAAK,GAAG+B,MAAM,CAAC/B,KAAK,CAAC;IACzB,CAAC,MACI;MACD;MACA,IAAID,SAAS,CAACkC,OAAO,EAAE;QACnBnC,KAAK,CAACyB,IAAI,CAACxB,SAAS,CAACkC,OAAO,CAAC,CAAC,CAAC,CAAC;MACpC,CAAC,MACI;QACDnC,KAAK,CAACyB,IAAI,CAACxB,SAAS,CAACI,OAAO,CAAC;MACjC;MACA,OAAO,IAAI;IACf;EACJ;EACA,IAAIJ,SAAS,CAACkC,OAAO,EAAE;IACnB,IAAIC,KAAK,GAAGnC,SAAS,CAACkC,OAAO,CAACjC,KAAK,CAAC;IACpCF,KAAK,CAACyB,IAAI,CAACW,KAAK,CAAC;EACrB,CAAC,MACI;IACDrC,OAAO,CAACC,KAAK,EAAEC,SAAS,EAAEC,KAAK,CAAC;EACpC;EACA,OAAO,KAAK;AAChB;AACA,IAAImC,QAAQ,GAAG,aAAe,YAAY;EACtC;AACJ;AACA;AACA;EACI,SAASA,QAAQA,CAACC,MAAM,EAAE;IACtB;AACR;AACA;AACA;IACQ,IAAI,CAACC,SAAS,GAAG,EAAE;IACnB;AACR;AACA;AACA;IACQ,IAAI,CAACC,OAAO,GAAG,CAAC;IAChB;AACR;AACA;AACA;IACQ,IAAI,CAACC,KAAK,GAAG,IAAI;IACjB,IAAI,CAACH,MAAM,GAAGA,MAAM;EACxB;EACA;AACJ;AACA;EACID,QAAQ,CAACK,SAAS,CAACC,SAAS,GAAG,YAAY;IACvC,IAAIC,KAAK,GAAG,IAAI;IAChB,IAAIC,UAAU,GAAG,KAAK;IACtB,IAAI7C,KAAK;IACT,IAAI8C,UAAU;IACd,IAAI7C,SAAS;IACb,IAAI,CAACwC,KAAK,GAAGlD,OAAO,CAACkD,KAAK,CAAC,UAAUd,OAAO,EAAE;MAC1CiB,KAAK,CAACJ,OAAO,GAAGb,OAAO;MACvB,IAAIiB,KAAK,CAACL,SAAS,CAAC5B,MAAM,GAAG,CAAC,EAAE;QAC5B,KAAK,IAAIM,CAAC,GAAG2B,KAAK,CAACL,SAAS,CAAC5B,MAAM,GAAG,CAAC,EAAEM,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;UAClDjB,KAAK,GAAG4C,KAAK,CAACL,SAAS,CAACtB,CAAC,CAAC;UAC1B,IAAIjB,KAAK,CAACM,SAAS,EAAE;YACjB;YACAsC,KAAK,CAACG,cAAc,CAAC9B,CAAC,CAAC;YACvB;UACJ;UACA,IAAI,CAACjB,KAAK,CAACgD,eAAe,CAAC,CAAC,EAAE;YAC1BF,UAAU,GAAG9C,KAAK,CAACiD,GAAG,CAAC,YAAY,CAAC;YACpC,KAAK,IAAI5B,CAAC,GAAGyB,UAAU,CAACnC,MAAM,GAAG,CAAC,EAAEU,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;cAC7CpB,SAAS,GAAG6C,UAAU,CAACzB,CAAC,CAAC;cACzBwB,UAAU,GAAGnB,MAAM,CAAC1B,KAAK,EAAEC,SAAS,EAAE0B,OAAO,CAAC;cAC9C,IAAIkB,UAAU,EAAE;gBACZC,UAAU,CAACI,MAAM,CAAC7B,CAAC,EAAE,CAAC,CAAC;gBACvBwB,UAAU,GAAG,KAAK;gBAClB,IAAI5C,SAAS,CAACkD,QAAQ,EAAE;kBACpBlD,SAAS,CAACkD,QAAQ,CAAC,CAAC;gBACxB;cACJ;YACJ;UACJ;UACA,IAAIL,UAAU,CAACnC,MAAM,KAAK,CAAC,EAAE;YACzBiC,KAAK,CAACG,cAAc,CAAC9B,CAAC,CAAC;UAC3B;QACJ;QACA,IAAImC,QAAQ,GAAGR,KAAK,CAACN,MAAM,CAACW,GAAG,CAAC,UAAU,CAAC;QAC3C;QACA,IAAI,CAACG,QAAQ,EAAE;UACXR,KAAK,CAACN,MAAM,CAACe,IAAI,CAAC,CAAC;QACvB;MACJ;IACJ,CAAC,CAAC;EACN,CAAC;EACD;AACJ;AACA;EACIhB,QAAQ,CAACK,SAAS,CAACY,WAAW,GAAG,UAAUtD,KAAK,EAAE;IAC9C,IAAI,CAACuC,SAAS,CAACjB,IAAI,CAACtB,KAAK,CAAC;EAC9B,CAAC;EACD;AACJ;AACA;EACIqC,QAAQ,CAACK,SAAS,CAACK,cAAc,GAAG,UAAUQ,KAAK,EAAE;IACjD,IAAI,CAAChB,SAAS,CAACW,MAAM,CAACK,KAAK,EAAE,CAAC,CAAC;EACnC,CAAC;EACD;AACJ;AACA;EACIlB,QAAQ,CAACK,SAAS,CAACc,WAAW,GAAG,YAAY;IACzC,OAAO,CAAC,CAAC,IAAI,CAACjB,SAAS,CAAC5B,MAAM;EAClC,CAAC;EACD;AACJ;AACA;EACI0B,QAAQ,CAACK,SAAS,CAACe,IAAI,GAAG,YAAY;IAClC,IAAI,IAAI,CAAChB,KAAK,EAAE;MACZ,IAAI,CAACA,KAAK,CAACgB,IAAI,CAAC,CAAC;IACrB;EACJ,CAAC;EACD;AACJ;AACA;AACA;EACIpB,QAAQ,CAACK,SAAS,CAACgB,iBAAiB,GAAG,UAAUC,KAAK,EAAE;IACpD,IAAIA,KAAK,KAAK,KAAK,CAAC,EAAE;MAAEA,KAAK,GAAG,IAAI;IAAE;IACtC,IAAI,CAACpB,SAAS,CAACqB,OAAO,CAAC,UAAUC,QAAQ,EAAE;MACvCA,QAAQ,CAACC,WAAW,CAACH,KAAK,CAAC;IAC/B,CAAC,CAAC;IACF,IAAI,CAACpB,SAAS,GAAG,EAAE;IACnB,IAAI,CAACD,MAAM,CAACe,IAAI,CAAC,CAAC;EACtB,CAAC;EACD;AACJ;AACA;EACIhB,QAAQ,CAACK,SAAS,CAACqB,OAAO,GAAG,YAAY;IACrC,OAAO,IAAI,CAACvB,OAAO;EACvB,CAAC;EACD,OAAOH,QAAQ;AACnB,CAAC,CAAC,CAAE;AACJ,eAAeA,QAAQ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}