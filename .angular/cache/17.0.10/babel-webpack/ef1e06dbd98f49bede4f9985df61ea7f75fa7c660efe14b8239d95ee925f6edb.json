{"ast":null,"code":"import { each, isArray } from '@antv/util';\nimport { registerShape, registerShapeFactory } from '../base';\nimport { getPathPoints } from '../util/get-path-points';\nimport { getStyle } from '../util/get-style';\nimport { getLinePath, getSplinePath } from '../util/path';\nimport { splitPoints } from '../util/split-points';\nimport { getLineMarker } from './util';\nfunction getShapeAttrs(cfg, smooth, constraint) {\n  var isStack = cfg.isStack,\n    connectNulls = cfg.connectNulls,\n    isInCircle = cfg.isInCircle,\n    showSinglePoint = cfg.showSinglePoint;\n  var shapeAttrs = getStyle(cfg, true, false, 'lineWidth');\n  var points = getPathPoints(cfg.points, connectNulls, showSinglePoint); // 根据 connectNulls 值处理 points\n  var path = [];\n  for (var i = 0, len = points.length; i < len; i++) {\n    var eachLinePoints = points[i];\n    path = path.concat(getPath(eachLinePoints, isInCircle, isStack, smooth, constraint, shapeAttrs));\n  }\n  shapeAttrs.path = path;\n  return shapeAttrs;\n}\n// 单条 path\nfunction getSinglePath(points, isInCircle, smooth, constraint, style) {\n  if (points.length === 1) {\n    // 只有一个点时\n    return [['M', points[0].x, points[0].y - style.lineWidth / 2], ['L', points[0].x, points[0].y], ['L', points[0].x, points[0].y + style.lineWidth / 2]];\n  }\n  var path;\n  if (!smooth) {\n    path = getLinePath(points, false);\n    if (isInCircle) {\n      path.push(['Z']);\n    }\n  } else {\n    // 直角坐标系下绘制曲线时限制最大值、最小值\n    if (isInCircle && points.length) {\n      points.push({\n        x: points[0].x,\n        y: points[0].y\n      });\n    }\n    path = getSplinePath(points, false, constraint);\n  }\n  return path;\n}\nfunction getRangePath(points, isInCircle, isStack, smooth, constraint, style) {\n  var topPoints = [];\n  var bottomPoints = [];\n  each(points, function (point) {\n    var result = splitPoints(point);\n    topPoints.push(result[1]); // 上边\n    bottomPoints.push(result[0]); // 底边\n  });\n\n  var topPath = getSinglePath(topPoints, isInCircle, smooth, constraint, style);\n  var bottomPath = getSinglePath(bottomPoints, isInCircle, smooth, constraint, style);\n  if (isStack) {\n    return topPath;\n  }\n  return topPath.concat(bottomPath);\n}\n/**\n * 获取折线图 path\n */\nexport function getPath(points, isInCircle, isStack, smooth, constraint, style) {\n  if (points.length) {\n    var first = points[0];\n    return isArray(first.y) ? getRangePath(points, isInCircle, isStack, smooth, constraint, style) : getSinglePath(points, isInCircle, smooth, constraint, style);\n  }\n  return [];\n}\nvar LineShapeFactory = registerShapeFactory('line', {\n  defaultShapeType: 'line'\n});\n// 这里因为代码公用，所以直接全部注册\n// 'line' 默认折线；'dot' 点线 ···；'dash' 断线 - - -\neach(['line', 'dot', 'dash', 'smooth'], function (shapeType) {\n  registerShape('line', shapeType, {\n    draw: function (cfg, container) {\n      var smooth = shapeType === 'smooth';\n      var constraint;\n      if (smooth) {\n        var _a = this.coordinate,\n          start = _a.start,\n          end = _a.end;\n        constraint = [[start.x, end.y], [end.x, start.y]];\n      }\n      var attrs = getShapeAttrs(cfg, smooth, constraint);\n      var shape = container.addShape({\n        type: 'path',\n        attrs: attrs,\n        name: 'line',\n        capture: !smooth\n      });\n      return shape;\n    },\n    getMarker: function (markerCfg) {\n      return getLineMarker(markerCfg, shapeType);\n    }\n  });\n});\nexport default LineShapeFactory;","map":{"version":3,"names":["each","isArray","registerShape","registerShapeFactory","getPathPoints","getStyle","getLinePath","getSplinePath","splitPoints","getLineMarker","getShapeAttrs","cfg","smooth","constraint","isStack","connectNulls","isInCircle","showSinglePoint","shapeAttrs","points","path","i","len","length","eachLinePoints","concat","getPath","getSinglePath","style","x","y","lineWidth","push","getRangePath","topPoints","bottomPoints","point","result","topPath","bottomPath","first","LineShapeFactory","defaultShapeType","shapeType","draw","container","_a","coordinate","start","end","attrs","shape","addShape","type","name","capture","getMarker","markerCfg"],"sources":["/Users/obiechina/Documents/ridy-flutter-full-taxi-solution 2/node_modules/@antv/g2/esm/geometry/shape/line/index.js"],"sourcesContent":["import { each, isArray } from '@antv/util';\nimport { registerShape, registerShapeFactory } from '../base';\nimport { getPathPoints } from '../util/get-path-points';\nimport { getStyle } from '../util/get-style';\nimport { getLinePath, getSplinePath } from '../util/path';\nimport { splitPoints } from '../util/split-points';\nimport { getLineMarker } from './util';\nfunction getShapeAttrs(cfg, smooth, constraint) {\n    var isStack = cfg.isStack, connectNulls = cfg.connectNulls, isInCircle = cfg.isInCircle, showSinglePoint = cfg.showSinglePoint;\n    var shapeAttrs = getStyle(cfg, true, false, 'lineWidth');\n    var points = getPathPoints(cfg.points, connectNulls, showSinglePoint); // 根据 connectNulls 值处理 points\n    var path = [];\n    for (var i = 0, len = points.length; i < len; i++) {\n        var eachLinePoints = points[i];\n        path = path.concat(getPath(eachLinePoints, isInCircle, isStack, smooth, constraint, shapeAttrs));\n    }\n    shapeAttrs.path = path;\n    return shapeAttrs;\n}\n// 单条 path\nfunction getSinglePath(points, isInCircle, smooth, constraint, style) {\n    if (points.length === 1) {\n        // 只有一个点时\n        return [\n            ['M', points[0].x, points[0].y - style.lineWidth / 2],\n            ['L', points[0].x, points[0].y],\n            ['L', points[0].x, points[0].y + style.lineWidth / 2],\n        ];\n    }\n    var path;\n    if (!smooth) {\n        path = getLinePath(points, false);\n        if (isInCircle) {\n            path.push(['Z']);\n        }\n    }\n    else {\n        // 直角坐标系下绘制曲线时限制最大值、最小值\n        if (isInCircle && points.length) {\n            points.push({ x: points[0].x, y: points[0].y });\n        }\n        path = getSplinePath(points, false, constraint);\n    }\n    return path;\n}\nfunction getRangePath(points, isInCircle, isStack, smooth, constraint, style) {\n    var topPoints = [];\n    var bottomPoints = [];\n    each(points, function (point) {\n        var result = splitPoints(point);\n        topPoints.push(result[1]); // 上边\n        bottomPoints.push(result[0]); // 底边\n    });\n    var topPath = getSinglePath(topPoints, isInCircle, smooth, constraint, style);\n    var bottomPath = getSinglePath(bottomPoints, isInCircle, smooth, constraint, style);\n    if (isStack) {\n        return topPath;\n    }\n    return topPath.concat(bottomPath);\n}\n/**\n * 获取折线图 path\n */\nexport function getPath(points, isInCircle, isStack, smooth, constraint, style) {\n    if (points.length) {\n        var first = points[0];\n        return isArray(first.y)\n            ? getRangePath(points, isInCircle, isStack, smooth, constraint, style)\n            : getSinglePath(points, isInCircle, smooth, constraint, style);\n    }\n    return [];\n}\nvar LineShapeFactory = registerShapeFactory('line', {\n    defaultShapeType: 'line',\n});\n// 这里因为代码公用，所以直接全部注册\n// 'line' 默认折线；'dot' 点线 ···；'dash' 断线 - - -\neach(['line', 'dot', 'dash', 'smooth'], function (shapeType) {\n    registerShape('line', shapeType, {\n        draw: function (cfg, container) {\n            var smooth = shapeType === 'smooth';\n            var constraint;\n            if (smooth) {\n                var _a = this.coordinate, start = _a.start, end = _a.end;\n                constraint = [\n                    [start.x, end.y],\n                    [end.x, start.y],\n                ];\n            }\n            var attrs = getShapeAttrs(cfg, smooth, constraint);\n            var shape = container.addShape({\n                type: 'path',\n                attrs: attrs,\n                name: 'line',\n                capture: !smooth,\n            });\n            return shape;\n        },\n        getMarker: function (markerCfg) {\n            return getLineMarker(markerCfg, shapeType);\n        },\n    });\n});\nexport default LineShapeFactory;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}