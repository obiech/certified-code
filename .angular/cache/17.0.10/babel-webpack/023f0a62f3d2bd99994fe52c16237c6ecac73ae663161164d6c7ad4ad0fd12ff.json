{"ast":null,"code":"/**\n * @file utils of label\n */\nimport { isNil, isNumber, some } from '@antv/util';\nimport { rotate } from '../../../util/transform';\n/**\n * 查找 Label Group 中的文本 shape 对象\n * @param label\n */\nexport function findLabelTextShape(label) {\n  return label.find(function (el) {\n    return el.get('type') === 'text';\n  });\n}\n/**\n * 获取标签背景信息: box (无旋转) + rotation (旋转角度)\n */\nexport function getLabelBackgroundInfo(labelGroup, labelItem, padding) {\n  if (padding === void 0) {\n    padding = [0, 0, 0, 0];\n  }\n  var content = labelGroup && labelGroup.getChildren()[0];\n  if (content) {\n    var labelShape = content.clone();\n    // revert rotate\n    if (labelItem === null || labelItem === void 0 ? void 0 : labelItem.rotate) {\n      rotate(labelShape, -labelItem.rotate);\n    }\n    // use `getCanvasBBox`, because if Shape is been translated, `getBBox` is not the actual box position\n    var _a = labelShape.getCanvasBBox(),\n      x = _a.x,\n      y = _a.y,\n      width = _a.width,\n      height = _a.height;\n    labelShape.destroy();\n    var boxPadding = padding;\n    if (isNil(boxPadding)) {\n      boxPadding = [2, 2, 2, 2];\n    } else if (isNumber(boxPadding)) {\n      boxPadding = new Array(4).fill(boxPadding);\n    }\n    return {\n      x: x - boxPadding[3],\n      y: y - boxPadding[0],\n      width: width + boxPadding[1] + boxPadding[3],\n      height: height + boxPadding[0] + boxPadding[2],\n      rotation: (labelItem === null || labelItem === void 0 ? void 0 : labelItem.rotate) || 0\n    };\n  }\n  return {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0,\n    rotation: 0\n  };\n}\n/**\n * 计算两个矩形之间的堆叠区域面积\n */\nexport function getOverlapArea(a, b, margin) {\n  if (margin === void 0) {\n    margin = 0;\n  }\n  var xOverlap = Math.max(0, Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin));\n  var yOverlap = Math.max(0, Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin));\n  return xOverlap * yOverlap;\n}\n/** 检测是否和已布局的堆叠 */\nexport function checkShapeOverlap(cur, dones) {\n  var box = cur.getBBox();\n  return some(dones, function (done) {\n    var target = done.getBBox();\n    return getOverlapArea(box, target, 2) > 0;\n  });\n}","map":{"version":3,"names":["isNil","isNumber","some","rotate","findLabelTextShape","label","find","el","get","getLabelBackgroundInfo","labelGroup","labelItem","padding","content","getChildren","labelShape","clone","_a","getCanvasBBox","x","y","width","height","destroy","boxPadding","Array","fill","rotation","getOverlapArea","a","b","margin","xOverlap","Math","max","min","yOverlap","checkShapeOverlap","cur","dones","box","getBBox","done","target"],"sources":["/Users/obiechina/Documents/ridy-flutter-full-taxi-solution 2/node_modules/@antv/g2/esm/geometry/label/util/index.js"],"sourcesContent":["/**\n * @file utils of label\n */\nimport { isNil, isNumber, some } from '@antv/util';\nimport { rotate } from '../../../util/transform';\n/**\n * 查找 Label Group 中的文本 shape 对象\n * @param label\n */\nexport function findLabelTextShape(label) {\n    return label.find(function (el) { return el.get('type') === 'text'; });\n}\n/**\n * 获取标签背景信息: box (无旋转) + rotation (旋转角度)\n */\nexport function getLabelBackgroundInfo(labelGroup, labelItem, padding) {\n    if (padding === void 0) { padding = [0, 0, 0, 0]; }\n    var content = labelGroup && labelGroup.getChildren()[0];\n    if (content) {\n        var labelShape = content.clone();\n        // revert rotate\n        if (labelItem === null || labelItem === void 0 ? void 0 : labelItem.rotate) {\n            rotate(labelShape, -labelItem.rotate);\n        }\n        // use `getCanvasBBox`, because if Shape is been translated, `getBBox` is not the actual box position\n        var _a = labelShape.getCanvasBBox(), x = _a.x, y = _a.y, width = _a.width, height = _a.height;\n        labelShape.destroy();\n        var boxPadding = padding;\n        if (isNil(boxPadding)) {\n            boxPadding = [2, 2, 2, 2];\n        }\n        else if (isNumber(boxPadding)) {\n            boxPadding = new Array(4).fill(boxPadding);\n        }\n        return {\n            x: x - boxPadding[3],\n            y: y - boxPadding[0],\n            width: width + boxPadding[1] + boxPadding[3],\n            height: height + boxPadding[0] + boxPadding[2],\n            rotation: (labelItem === null || labelItem === void 0 ? void 0 : labelItem.rotate) || 0,\n        };\n    }\n    return { x: 0, y: 0, width: 0, height: 0, rotation: 0 };\n}\n/**\n * 计算两个矩形之间的堆叠区域面积\n */\nexport function getOverlapArea(a, b, margin) {\n    if (margin === void 0) { margin = 0; }\n    var xOverlap = Math.max(0, Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin));\n    var yOverlap = Math.max(0, Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin));\n    return xOverlap * yOverlap;\n}\n/** 检测是否和已布局的堆叠 */\nexport function checkShapeOverlap(cur, dones) {\n    var box = cur.getBBox();\n    return some(dones, function (done) {\n        var target = done.getBBox();\n        return getOverlapArea(box, target, 2) > 0;\n    });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}