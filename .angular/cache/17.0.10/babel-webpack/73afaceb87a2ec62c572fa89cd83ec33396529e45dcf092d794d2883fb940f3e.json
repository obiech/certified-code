{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { Cubic as CubicUtil } from '@antv/g-math';\nimport { each, isNil } from '@antv/util';\nimport ShapeBase from './base';\nimport { path2Absolute, path2Segments } from '@antv/path-util';\nimport { drawPath } from '../util/draw';\nimport isPointInPath from '../util/in-path/point-in-path';\nimport isInPolygon from '../util/in-path/polygon';\nimport PathUtil from '../util/path';\nimport * as ArrowUtil from '../util/arrow';\n// 是否在多个多边形内部\nfunction isInPolygons(polygons, x, y) {\n  var isHit = false;\n  for (var i = 0; i < polygons.length; i++) {\n    var points = polygons[i];\n    isHit = isInPolygon(points, x, y);\n    if (isHit) {\n      break;\n    }\n  }\n  return isHit;\n}\nvar Path = /** @class */function (_super) {\n  __extends(Path, _super);\n  function Path() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  Path.prototype.getDefaultAttrs = function () {\n    var attrs = _super.prototype.getDefaultAttrs.call(this);\n    return __assign(__assign({}, attrs), {\n      startArrow: false,\n      endArrow: false\n    });\n  };\n  Path.prototype.initAttrs = function (attrs) {\n    this._setPathArr(attrs.path);\n    this.setArrow();\n  };\n  // 更新属性时，检测是否更改了 path\n  Path.prototype.onAttrChange = function (name, value, originValue) {\n    _super.prototype.onAttrChange.call(this, name, value, originValue);\n    if (name === 'path') {\n      this._setPathArr(value);\n    }\n    // 由于箭头的绘制依赖于 line 的诸多 attrs，因此这里不再对每个 attr 进行判断，attr 每次变化都会影响箭头的更新\n    this.setArrow();\n  };\n  // 将 path 转换成绝对路径\n  Path.prototype._setPathArr = function (path) {\n    // 转换 path 的格式\n    this.attrs.path = path2Absolute(path);\n    var hasArc = PathUtil.hasArc(path);\n    // 为了加速 path 的绘制、拾取和计算，这个地方可以缓存很多东西\n    // 这些缓存都是第一次需要时计算和存储，虽然增加了复杂度，但是频繁调用的方法，性能有很大提升\n    this.set('hasArc', hasArc);\n    this.set('paramsCache', {}); // 清理缓存\n    this.set('segments', null); // 延迟生成 path，在动画场景下可能不会有拾取\n    this.set('curve', null);\n    this.set('tCache', null);\n    this.set('totalLength', null);\n  };\n  Path.prototype.getSegments = function () {\n    var segments = this.get('segements');\n    if (!segments) {\n      segments = path2Segments(this.attr('path'));\n      this.set('segments', segments);\n    }\n    return segments;\n  };\n  Path.prototype.setArrow = function () {\n    var attrs = this.attr();\n    var startArrow = attrs.startArrow,\n      endArrow = attrs.endArrow;\n    if (startArrow) {\n      var tangent = this.getStartTangent();\n      ArrowUtil.addStartArrow(this, attrs, tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1]);\n    }\n    if (endArrow) {\n      var tangent = this.getEndTangent();\n      ArrowUtil.addEndArrow(this, attrs, tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1]);\n    }\n  };\n  Path.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {\n    var segments = this.getSegments();\n    var hasArc = this.get('hasArc');\n    var isHit = false;\n    if (isStroke) {\n      var length_1 = this.getTotalLength();\n      isHit = PathUtil.isPointInStroke(segments, lineWidth, x, y, length_1);\n    }\n    if (!isHit && isFill) {\n      if (hasArc) {\n        // 存在曲线时，暂时使用 canvas 的 api 计算，后续可以进行多边形切割\n        isHit = isPointInPath(this, x, y);\n      } else {\n        var path = this.attr('path');\n        var extractResutl = PathUtil.extractPolygons(path);\n        // 提取出来的多边形包含闭合的和非闭合的，在这里统一按照多边形处理\n        isHit = isInPolygons(extractResutl.polygons, x, y) || isInPolygons(extractResutl.polylines, x, y);\n      }\n    }\n    return isHit;\n  };\n  Path.prototype.createPath = function (context) {\n    var attrs = this.attr();\n    var paramsCache = this.get('paramsCache'); // 由于计算圆弧的参数成本很大，所以要缓存\n    drawPath(this, context, attrs, paramsCache);\n  };\n  Path.prototype.afterDrawPath = function (context) {\n    var startArrowShape = this.get('startArrowShape');\n    var endArrowShape = this.get('endArrowShape');\n    if (startArrowShape) {\n      startArrowShape.draw(context);\n    }\n    if (endArrowShape) {\n      endArrowShape.draw(context);\n    }\n  };\n  /**\n   * Get total length of path\n   * @return {number} length\n   */\n  Path.prototype.getTotalLength = function () {\n    var totalLength = this.get('totalLength');\n    if (!isNil(totalLength)) {\n      return totalLength;\n    }\n    this._calculateCurve();\n    this._setTcache();\n    return this.get('totalLength');\n  };\n  /**\n   * Get point according to ratio\n   * @param {number} ratio\n   * @return {Point} point\n   */\n  Path.prototype.getPoint = function (ratio) {\n    var tCache = this.get('tCache');\n    if (!tCache) {\n      this._calculateCurve();\n      this._setTcache();\n      tCache = this.get('tCache');\n    }\n    var subt;\n    var index;\n    var curve = this.get('curve');\n    if (!tCache || tCache.length === 0) {\n      if (curve) {\n        return {\n          x: curve[0][1],\n          y: curve[0][2]\n        };\n      }\n      return null;\n    }\n    each(tCache, function (v, i) {\n      if (ratio >= v[0] && ratio <= v[1]) {\n        subt = (ratio - v[0]) / (v[1] - v[0]);\n        index = i;\n      }\n    });\n    var seg = curve[index];\n    if (isNil(seg) || isNil(index)) {\n      return null;\n    }\n    var l = seg.length;\n    var nextSeg = curve[index + 1];\n    return CubicUtil.pointAt(seg[l - 2], seg[l - 1], nextSeg[1], nextSeg[2], nextSeg[3], nextSeg[4], nextSeg[5], nextSeg[6], subt);\n  };\n  Path.prototype._calculateCurve = function () {\n    var path = this.attr().path;\n    this.set('curve', PathUtil.pathToCurve(path));\n  };\n  Path.prototype._setTcache = function () {\n    var totalLength = 0;\n    var tempLength = 0;\n    // 每段 curve 对应起止点的长度比例列表，形如: [[0, 0.25], [0.25, 0.6]. [0.6, 0.9], [0.9, 1]]\n    var tCache = [];\n    var segmentT;\n    var segmentL;\n    var segmentN;\n    var l;\n    var curve = this.get('curve');\n    if (!curve) {\n      return;\n    }\n    each(curve, function (segment, i) {\n      segmentN = curve[i + 1];\n      l = segment.length;\n      if (segmentN) {\n        totalLength += CubicUtil.length(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]) || 0;\n      }\n    });\n    this.set('totalLength', totalLength);\n    if (totalLength === 0) {\n      this.set('tCache', []);\n      return;\n    }\n    each(curve, function (segment, i) {\n      segmentN = curve[i + 1];\n      l = segment.length;\n      if (segmentN) {\n        segmentT = [];\n        segmentT[0] = tempLength / totalLength;\n        segmentL = CubicUtil.length(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]);\n        // 当 path 不连续时，segmentL 可能为空，为空时需要作为 0 处理\n        tempLength += segmentL || 0;\n        segmentT[1] = tempLength / totalLength;\n        tCache.push(segmentT);\n      }\n    });\n    this.set('tCache', tCache);\n  };\n  /**\n   * Get start tangent vector\n   * @return {Array}\n   */\n  Path.prototype.getStartTangent = function () {\n    var segments = this.getSegments();\n    var result;\n    if (segments.length > 1) {\n      var startPoint = segments[0].currentPoint;\n      var endPoint = segments[1].currentPoint;\n      var tangent = segments[1].startTangent;\n      result = [];\n      if (tangent) {\n        result.push([startPoint[0] - tangent[0], startPoint[1] - tangent[1]]);\n        result.push([startPoint[0], startPoint[1]]);\n      } else {\n        result.push([endPoint[0], endPoint[1]]);\n        result.push([startPoint[0], startPoint[1]]);\n      }\n    }\n    return result;\n  };\n  /**\n   * Get end tangent vector\n   * @return {Array}\n   */\n  Path.prototype.getEndTangent = function () {\n    var segments = this.getSegments();\n    var length = segments.length;\n    var result;\n    if (length > 1) {\n      var startPoint = segments[length - 2].currentPoint;\n      var endPoint = segments[length - 1].currentPoint;\n      var tangent = segments[length - 1].endTangent;\n      result = [];\n      if (tangent) {\n        result.push([endPoint[0] - tangent[0], endPoint[1] - tangent[1]]);\n        result.push([endPoint[0], endPoint[1]]);\n      } else {\n        result.push([startPoint[0], startPoint[1]]);\n        result.push([endPoint[0], endPoint[1]]);\n      }\n    }\n    return result;\n  };\n  return Path;\n}(ShapeBase);\nexport default Path;","map":{"version":3,"names":["__assign","__extends","Cubic","CubicUtil","each","isNil","ShapeBase","path2Absolute","path2Segments","drawPath","isPointInPath","isInPolygon","PathUtil","ArrowUtil","isInPolygons","polygons","x","y","isHit","i","length","points","Path","_super","apply","arguments","prototype","getDefaultAttrs","attrs","call","startArrow","endArrow","initAttrs","_setPathArr","path","setArrow","onAttrChange","name","value","originValue","hasArc","set","getSegments","segments","get","attr","tangent","getStartTangent","addStartArrow","getEndTangent","addEndArrow","isInStrokeOrPath","isStroke","isFill","lineWidth","length_1","getTotalLength","isPointInStroke","extractResutl","extractPolygons","polylines","createPath","context","paramsCache","afterDrawPath","startArrowShape","endArrowShape","draw","totalLength","_calculateCurve","_setTcache","getPoint","ratio","tCache","subt","index","curve","v","seg","l","nextSeg","pointAt","pathToCurve","tempLength","segmentT","segmentL","segmentN","segment","push","result","startPoint","currentPoint","endPoint","startTangent","endTangent"],"sources":["/Users/obiechina/Documents/ridy-flutter-full-taxi-solution 2/node_modules/@antv/g-canvas/esm/shape/path.js"],"sourcesContent":["import { __assign, __extends } from \"tslib\";\nimport { Cubic as CubicUtil } from '@antv/g-math';\nimport { each, isNil } from '@antv/util';\nimport ShapeBase from './base';\nimport { path2Absolute, path2Segments } from '@antv/path-util';\nimport { drawPath } from '../util/draw';\nimport isPointInPath from '../util/in-path/point-in-path';\nimport isInPolygon from '../util/in-path/polygon';\nimport PathUtil from '../util/path';\nimport * as ArrowUtil from '../util/arrow';\n// 是否在多个多边形内部\nfunction isInPolygons(polygons, x, y) {\n    var isHit = false;\n    for (var i = 0; i < polygons.length; i++) {\n        var points = polygons[i];\n        isHit = isInPolygon(points, x, y);\n        if (isHit) {\n            break;\n        }\n    }\n    return isHit;\n}\nvar Path = /** @class */ (function (_super) {\n    __extends(Path, _super);\n    function Path() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Path.prototype.getDefaultAttrs = function () {\n        var attrs = _super.prototype.getDefaultAttrs.call(this);\n        return __assign(__assign({}, attrs), { startArrow: false, endArrow: false });\n    };\n    Path.prototype.initAttrs = function (attrs) {\n        this._setPathArr(attrs.path);\n        this.setArrow();\n    };\n    // 更新属性时，检测是否更改了 path\n    Path.prototype.onAttrChange = function (name, value, originValue) {\n        _super.prototype.onAttrChange.call(this, name, value, originValue);\n        if (name === 'path') {\n            this._setPathArr(value);\n        }\n        // 由于箭头的绘制依赖于 line 的诸多 attrs，因此这里不再对每个 attr 进行判断，attr 每次变化都会影响箭头的更新\n        this.setArrow();\n    };\n    // 将 path 转换成绝对路径\n    Path.prototype._setPathArr = function (path) {\n        // 转换 path 的格式\n        this.attrs.path = path2Absolute(path);\n        var hasArc = PathUtil.hasArc(path);\n        // 为了加速 path 的绘制、拾取和计算，这个地方可以缓存很多东西\n        // 这些缓存都是第一次需要时计算和存储，虽然增加了复杂度，但是频繁调用的方法，性能有很大提升\n        this.set('hasArc', hasArc);\n        this.set('paramsCache', {}); // 清理缓存\n        this.set('segments', null); // 延迟生成 path，在动画场景下可能不会有拾取\n        this.set('curve', null);\n        this.set('tCache', null);\n        this.set('totalLength', null);\n    };\n    Path.prototype.getSegments = function () {\n        var segments = this.get('segements');\n        if (!segments) {\n            segments = path2Segments(this.attr('path'));\n            this.set('segments', segments);\n        }\n        return segments;\n    };\n    Path.prototype.setArrow = function () {\n        var attrs = this.attr();\n        var startArrow = attrs.startArrow, endArrow = attrs.endArrow;\n        if (startArrow) {\n            var tangent = this.getStartTangent();\n            ArrowUtil.addStartArrow(this, attrs, tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1]);\n        }\n        if (endArrow) {\n            var tangent = this.getEndTangent();\n            ArrowUtil.addEndArrow(this, attrs, tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1]);\n        }\n    };\n    Path.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {\n        var segments = this.getSegments();\n        var hasArc = this.get('hasArc');\n        var isHit = false;\n        if (isStroke) {\n            var length_1 = this.getTotalLength();\n            isHit = PathUtil.isPointInStroke(segments, lineWidth, x, y, length_1);\n        }\n        if (!isHit && isFill) {\n            if (hasArc) {\n                // 存在曲线时，暂时使用 canvas 的 api 计算，后续可以进行多边形切割\n                isHit = isPointInPath(this, x, y);\n            }\n            else {\n                var path = this.attr('path');\n                var extractResutl = PathUtil.extractPolygons(path);\n                // 提取出来的多边形包含闭合的和非闭合的，在这里统一按照多边形处理\n                isHit = isInPolygons(extractResutl.polygons, x, y) || isInPolygons(extractResutl.polylines, x, y);\n            }\n        }\n        return isHit;\n    };\n    Path.prototype.createPath = function (context) {\n        var attrs = this.attr();\n        var paramsCache = this.get('paramsCache'); // 由于计算圆弧的参数成本很大，所以要缓存\n        drawPath(this, context, attrs, paramsCache);\n    };\n    Path.prototype.afterDrawPath = function (context) {\n        var startArrowShape = this.get('startArrowShape');\n        var endArrowShape = this.get('endArrowShape');\n        if (startArrowShape) {\n            startArrowShape.draw(context);\n        }\n        if (endArrowShape) {\n            endArrowShape.draw(context);\n        }\n    };\n    /**\n     * Get total length of path\n     * @return {number} length\n     */\n    Path.prototype.getTotalLength = function () {\n        var totalLength = this.get('totalLength');\n        if (!isNil(totalLength)) {\n            return totalLength;\n        }\n        this._calculateCurve();\n        this._setTcache();\n        return this.get('totalLength');\n    };\n    /**\n     * Get point according to ratio\n     * @param {number} ratio\n     * @return {Point} point\n     */\n    Path.prototype.getPoint = function (ratio) {\n        var tCache = this.get('tCache');\n        if (!tCache) {\n            this._calculateCurve();\n            this._setTcache();\n            tCache = this.get('tCache');\n        }\n        var subt;\n        var index;\n        var curve = this.get('curve');\n        if (!tCache || tCache.length === 0) {\n            if (curve) {\n                return {\n                    x: curve[0][1],\n                    y: curve[0][2],\n                };\n            }\n            return null;\n        }\n        each(tCache, function (v, i) {\n            if (ratio >= v[0] && ratio <= v[1]) {\n                subt = (ratio - v[0]) / (v[1] - v[0]);\n                index = i;\n            }\n        });\n        var seg = curve[index];\n        if (isNil(seg) || isNil(index)) {\n            return null;\n        }\n        var l = seg.length;\n        var nextSeg = curve[index + 1];\n        return CubicUtil.pointAt(seg[l - 2], seg[l - 1], nextSeg[1], nextSeg[2], nextSeg[3], nextSeg[4], nextSeg[5], nextSeg[6], subt);\n    };\n    Path.prototype._calculateCurve = function () {\n        var path = this.attr().path;\n        this.set('curve', PathUtil.pathToCurve(path));\n    };\n    Path.prototype._setTcache = function () {\n        var totalLength = 0;\n        var tempLength = 0;\n        // 每段 curve 对应起止点的长度比例列表，形如: [[0, 0.25], [0.25, 0.6]. [0.6, 0.9], [0.9, 1]]\n        var tCache = [];\n        var segmentT;\n        var segmentL;\n        var segmentN;\n        var l;\n        var curve = this.get('curve');\n        if (!curve) {\n            return;\n        }\n        each(curve, function (segment, i) {\n            segmentN = curve[i + 1];\n            l = segment.length;\n            if (segmentN) {\n                totalLength +=\n                    CubicUtil.length(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]) || 0;\n            }\n        });\n        this.set('totalLength', totalLength);\n        if (totalLength === 0) {\n            this.set('tCache', []);\n            return;\n        }\n        each(curve, function (segment, i) {\n            segmentN = curve[i + 1];\n            l = segment.length;\n            if (segmentN) {\n                segmentT = [];\n                segmentT[0] = tempLength / totalLength;\n                segmentL = CubicUtil.length(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]);\n                // 当 path 不连续时，segmentL 可能为空，为空时需要作为 0 处理\n                tempLength += segmentL || 0;\n                segmentT[1] = tempLength / totalLength;\n                tCache.push(segmentT);\n            }\n        });\n        this.set('tCache', tCache);\n    };\n    /**\n     * Get start tangent vector\n     * @return {Array}\n     */\n    Path.prototype.getStartTangent = function () {\n        var segments = this.getSegments();\n        var result;\n        if (segments.length > 1) {\n            var startPoint = segments[0].currentPoint;\n            var endPoint = segments[1].currentPoint;\n            var tangent = segments[1].startTangent;\n            result = [];\n            if (tangent) {\n                result.push([startPoint[0] - tangent[0], startPoint[1] - tangent[1]]);\n                result.push([startPoint[0], startPoint[1]]);\n            }\n            else {\n                result.push([endPoint[0], endPoint[1]]);\n                result.push([startPoint[0], startPoint[1]]);\n            }\n        }\n        return result;\n    };\n    /**\n     * Get end tangent vector\n     * @return {Array}\n     */\n    Path.prototype.getEndTangent = function () {\n        var segments = this.getSegments();\n        var length = segments.length;\n        var result;\n        if (length > 1) {\n            var startPoint = segments[length - 2].currentPoint;\n            var endPoint = segments[length - 1].currentPoint;\n            var tangent = segments[length - 1].endTangent;\n            result = [];\n            if (tangent) {\n                result.push([endPoint[0] - tangent[0], endPoint[1] - tangent[1]]);\n                result.push([endPoint[0], endPoint[1]]);\n            }\n            else {\n                result.push([startPoint[0], startPoint[1]]);\n                result.push([endPoint[0], endPoint[1]]);\n            }\n        }\n        return result;\n    };\n    return Path;\n}(ShapeBase));\nexport default Path;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}