{"ast":null,"code":"import { __assign } from \"tslib\";\n/**\n * @fileoverview path 的一些工具\n * @author dxq613@gmail.com\n */\nimport { PathUtil } from '@antv/g-base';\nimport { Quad as QuadUtil } from '@antv/g-math';\nimport { Cubic as CubicUtil } from '@antv/g-math';\nimport { ext } from '@antv/matrix-util';\nimport * as vec3 from 'gl-matrix/vec3';\nimport { inBox } from './util';\nimport inLine from './in-stroke/line';\nimport inArc from './in-stroke/arc';\nvar transform = ext.transform;\nfunction hasArc(path) {\n  var hasArc = false;\n  var count = path.length;\n  for (var i = 0; i < count; i++) {\n    var params = path[i];\n    var cmd = params[0];\n    if (cmd === 'C' || cmd === 'A' || cmd === 'Q') {\n      hasArc = true;\n      break;\n    }\n  }\n  return hasArc;\n}\nfunction isPointInStroke(segments, lineWidth, x, y, length) {\n  var isHit = false;\n  var halfWidth = lineWidth / 2;\n  for (var i = 0; i < segments.length; i++) {\n    var segment = segments[i];\n    var currentPoint = segment.currentPoint,\n      params = segment.params,\n      prePoint = segment.prePoint,\n      box = segment.box;\n    // 如果在前面已经生成过包围盒，直接按照包围盒计算\n    if (box && !inBox(box.x - halfWidth, box.y - halfWidth, box.width + lineWidth, box.height + lineWidth, x, y)) {\n      continue;\n    }\n    switch (segment.command) {\n      // L 和 Z 都是直线， M 不进行拾取\n      case 'L':\n      case 'Z':\n        isHit = inLine(prePoint[0], prePoint[1], currentPoint[0], currentPoint[1], lineWidth, x, y);\n        break;\n      case 'Q':\n        var qDistance = QuadUtil.pointDistance(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], x, y);\n        isHit = qDistance <= lineWidth / 2;\n        break;\n      case 'C':\n        var cDistance = CubicUtil.pointDistance(prePoint[0],\n        // 上一段结束位置, 即 C 的起始点\n        prePoint[1], params[1],\n        // 'C' 的参数，1、2 为第一个控制点，3、4 为第二个控制点，5、6 为结束点\n        params[2], params[3], params[4], params[5], params[6], x, y, length);\n        isHit = cDistance <= lineWidth / 2;\n        break;\n      case 'A':\n        // 计算点到椭圆圆弧的距离，暂时使用近似算法，后面可以改成切割法求最近距离\n        var arcParams = segment.arcParams;\n        var cx = arcParams.cx,\n          cy = arcParams.cy,\n          rx = arcParams.rx,\n          ry = arcParams.ry,\n          startAngle = arcParams.startAngle,\n          endAngle = arcParams.endAngle,\n          xRotation = arcParams.xRotation;\n        var p = [x, y, 1];\n        var r = rx > ry ? rx : ry;\n        var scaleX = rx > ry ? 1 : rx / ry;\n        var scaleY = rx > ry ? ry / rx : 1;\n        var m = transform(null, [['t', -cx, -cy], ['r', -xRotation], ['s', 1 / scaleX, 1 / scaleY]]);\n        vec3.transformMat3(p, p, m);\n        isHit = inArc(0, 0, r, startAngle, endAngle, lineWidth, p[0], p[1]);\n        break;\n      default:\n        break;\n    }\n    if (isHit) {\n      break;\n    }\n  }\n  return isHit;\n}\n/**\n * 提取出内部的闭合多边形和非闭合的多边形，假设 path 不存在圆弧\n * @param {Array} path 路径\n * @returns {Array} 点的集合\n */\nfunction extractPolygons(path) {\n  var count = path.length;\n  var polygons = [];\n  var polylines = [];\n  var points = []; // 防止第一个命令不是 'M'\n  for (var i = 0; i < count; i++) {\n    var params = path[i];\n    var cmd = params[0];\n    if (cmd === 'M') {\n      // 遇到 'M' 判定是否是新数组，新数组中没有点\n      if (points.length) {\n        // 如果存在点，则说明没有遇到 'Z'，开始了一个新的多边形\n        polylines.push(points);\n        points = []; // 创建新的点\n      }\n\n      points.push([params[1], params[2]]);\n    } else if (cmd === 'Z') {\n      if (points.length) {\n        // 存在点\n        polygons.push(points);\n        points = []; // 开始新的点集合\n      }\n      // 如果不存在点，同时 'Z'，则说明是错误，不处理\n    } else {\n      points.push([params[1], params[2]]);\n    }\n  }\n  // 说明 points 未放入 polygons 或者 polyline\n  // 仅当只有一个 M，没有 Z 时会发生这种情况\n  if (points.length > 0) {\n    polylines.push(points);\n  }\n  return {\n    polygons: polygons,\n    polylines: polylines\n  };\n}\nexport default __assign({\n  hasArc: hasArc,\n  extractPolygons: extractPolygons,\n  isPointInStroke: isPointInStroke\n}, PathUtil);","map":{"version":3,"names":["__assign","PathUtil","Quad","QuadUtil","Cubic","CubicUtil","ext","vec3","inBox","inLine","inArc","transform","hasArc","path","count","length","i","params","cmd","isPointInStroke","segments","lineWidth","x","y","isHit","halfWidth","segment","currentPoint","prePoint","box","width","height","command","qDistance","pointDistance","cDistance","arcParams","cx","cy","rx","ry","startAngle","endAngle","xRotation","p","r","scaleX","scaleY","m","transformMat3","extractPolygons","polygons","polylines","points","push"],"sources":["/Users/obiechina/Documents/ridy-flutter-full-taxi-solution 2/node_modules/@antv/g-canvas/esm/util/path.js"],"sourcesContent":["import { __assign } from \"tslib\";\n/**\n * @fileoverview path 的一些工具\n * @author dxq613@gmail.com\n */\nimport { PathUtil } from '@antv/g-base';\nimport { Quad as QuadUtil } from '@antv/g-math';\nimport { Cubic as CubicUtil } from '@antv/g-math';\nimport { ext } from '@antv/matrix-util';\nimport * as vec3 from 'gl-matrix/vec3';\nimport { inBox } from './util';\nimport inLine from './in-stroke/line';\nimport inArc from './in-stroke/arc';\nvar transform = ext.transform;\nfunction hasArc(path) {\n    var hasArc = false;\n    var count = path.length;\n    for (var i = 0; i < count; i++) {\n        var params = path[i];\n        var cmd = params[0];\n        if (cmd === 'C' || cmd === 'A' || cmd === 'Q') {\n            hasArc = true;\n            break;\n        }\n    }\n    return hasArc;\n}\nfunction isPointInStroke(segments, lineWidth, x, y, length) {\n    var isHit = false;\n    var halfWidth = lineWidth / 2;\n    for (var i = 0; i < segments.length; i++) {\n        var segment = segments[i];\n        var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint, box = segment.box;\n        // 如果在前面已经生成过包围盒，直接按照包围盒计算\n        if (box && !inBox(box.x - halfWidth, box.y - halfWidth, box.width + lineWidth, box.height + lineWidth, x, y)) {\n            continue;\n        }\n        switch (segment.command) {\n            // L 和 Z 都是直线， M 不进行拾取\n            case 'L':\n            case 'Z':\n                isHit = inLine(prePoint[0], prePoint[1], currentPoint[0], currentPoint[1], lineWidth, x, y);\n                break;\n            case 'Q':\n                var qDistance = QuadUtil.pointDistance(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], x, y);\n                isHit = qDistance <= lineWidth / 2;\n                break;\n            case 'C':\n                var cDistance = CubicUtil.pointDistance(prePoint[0], // 上一段结束位置, 即 C 的起始点\n                prePoint[1], params[1], // 'C' 的参数，1、2 为第一个控制点，3、4 为第二个控制点，5、6 为结束点\n                params[2], params[3], params[4], params[5], params[6], x, y, length);\n                isHit = cDistance <= lineWidth / 2;\n                break;\n            case 'A':\n                // 计算点到椭圆圆弧的距离，暂时使用近似算法，后面可以改成切割法求最近距离\n                var arcParams = segment.arcParams;\n                var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation;\n                var p = [x, y, 1];\n                var r = rx > ry ? rx : ry;\n                var scaleX = rx > ry ? 1 : rx / ry;\n                var scaleY = rx > ry ? ry / rx : 1;\n                var m = transform(null, [\n                    ['t', -cx, -cy],\n                    ['r', -xRotation],\n                    ['s', 1 / scaleX, 1 / scaleY],\n                ]);\n                vec3.transformMat3(p, p, m);\n                isHit = inArc(0, 0, r, startAngle, endAngle, lineWidth, p[0], p[1]);\n                break;\n            default:\n                break;\n        }\n        if (isHit) {\n            break;\n        }\n    }\n    return isHit;\n}\n/**\n * 提取出内部的闭合多边形和非闭合的多边形，假设 path 不存在圆弧\n * @param {Array} path 路径\n * @returns {Array} 点的集合\n */\nfunction extractPolygons(path) {\n    var count = path.length;\n    var polygons = [];\n    var polylines = [];\n    var points = []; // 防止第一个命令不是 'M'\n    for (var i = 0; i < count; i++) {\n        var params = path[i];\n        var cmd = params[0];\n        if (cmd === 'M') {\n            // 遇到 'M' 判定是否是新数组，新数组中没有点\n            if (points.length) {\n                // 如果存在点，则说明没有遇到 'Z'，开始了一个新的多边形\n                polylines.push(points);\n                points = []; // 创建新的点\n            }\n            points.push([params[1], params[2]]);\n        }\n        else if (cmd === 'Z') {\n            if (points.length) {\n                // 存在点\n                polygons.push(points);\n                points = []; // 开始新的点集合\n            }\n            // 如果不存在点，同时 'Z'，则说明是错误，不处理\n        }\n        else {\n            points.push([params[1], params[2]]);\n        }\n    }\n    // 说明 points 未放入 polygons 或者 polyline\n    // 仅当只有一个 M，没有 Z 时会发生这种情况\n    if (points.length > 0) {\n        polylines.push(points);\n    }\n    return {\n        polygons: polygons,\n        polylines: polylines,\n    };\n}\nexport default __assign({ hasArc: hasArc,\n    extractPolygons: extractPolygons,\n    isPointInStroke: isPointInStroke }, PathUtil);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}