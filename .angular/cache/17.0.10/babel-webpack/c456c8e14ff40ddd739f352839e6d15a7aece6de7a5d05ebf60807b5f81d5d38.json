{"ast":null,"code":"import { each, isEmpty, isNumber, isNumberEqual, max, min } from '@antv/util';\n// 获取图形的包围盒\nfunction getPointsBox(points) {\n  if (isEmpty(points)) {\n    return null;\n  }\n  var minX = points[0].x;\n  var maxX = points[0].x;\n  var minY = points[0].y;\n  var maxY = points[0].y;\n  each(points, function (point) {\n    minX = minX > point.x ? point.x : minX;\n    maxX = maxX < point.x ? point.x : maxX;\n    minY = minY > point.y ? point.y : minY;\n    maxY = maxY < point.y ? point.y : maxY;\n  });\n  return {\n    minX: minX,\n    maxX: maxX,\n    minY: minY,\n    maxY: maxY,\n    centerX: (minX + maxX) / 2,\n    centerY: (minY + maxY) / 2\n  };\n}\nfunction uniqueValues(array) {\n  return Array.from(new Set(array)).length === 1;\n}\nfunction mid(array) {\n  return (min(array) + max(array)) / 2;\n}\n/**\n * @ignore\n * 根据弧度计算极坐标系下的坐标点\n * @param centerX\n * @param centerY\n * @param radius\n * @param angleInRadian\n * @returns\n */\nexport function polarToCartesian(centerX, centerY, radius, angleInRadian) {\n  return {\n    x: centerX + radius * Math.cos(angleInRadian),\n    y: centerY + radius * Math.sin(angleInRadian)\n  };\n}\n/**\n * @ignore\n * 根据起始角度计算绘制扇形的 path\n * @param centerX\n * @param centerY\n * @param radius\n * @param startAngleInRadian\n * @param endAngleInRadian\n * @returns\n */\nexport function getSectorPath(centerX, centerY, radius, startAngleInRadian, endAngleInRadian, innerRadius) {\n  if (innerRadius === void 0) {\n    innerRadius = 0;\n  }\n  var start = polarToCartesian(centerX, centerY, radius, startAngleInRadian);\n  var end = polarToCartesian(centerX, centerY, radius, endAngleInRadian);\n  var innerStart = polarToCartesian(centerX, centerY, innerRadius, startAngleInRadian);\n  var innerEnd = polarToCartesian(centerX, centerY, innerRadius, endAngleInRadian);\n  if (endAngleInRadian - startAngleInRadian === Math.PI * 2) {\n    // 整个圆是分割成两个圆\n    var middlePoint = polarToCartesian(centerX, centerY, radius, startAngleInRadian + Math.PI);\n    var innerMiddlePoint = polarToCartesian(centerX, centerY, innerRadius, startAngleInRadian + Math.PI);\n    var circlePathCommands = [['M', start.x, start.y], ['A', radius, radius, 0, 1, 1, middlePoint.x, middlePoint.y], ['A', radius, radius, 0, 1, 1, end.x, end.y], ['M', innerStart.x, innerStart.y]];\n    if (innerRadius) {\n      circlePathCommands.push(['A', innerRadius, innerRadius, 0, 1, 0, innerMiddlePoint.x, innerMiddlePoint.y]);\n      circlePathCommands.push(['A', innerRadius, innerRadius, 0, 1, 0, innerEnd.x, innerEnd.y]);\n    }\n    circlePathCommands.push(['M', start.x, start.y]);\n    circlePathCommands.push(['Z']);\n    return circlePathCommands;\n  }\n  var arcSweep = endAngleInRadian - startAngleInRadian <= Math.PI ? 0 : 1;\n  var sectorPathCommands = [['M', start.x, start.y], ['A', radius, radius, 0, arcSweep, 1, end.x, end.y], ['L', innerEnd.x, innerEnd.y]];\n  if (innerRadius) {\n    sectorPathCommands.push(['A', innerRadius, innerRadius, 0, arcSweep, 0, innerStart.x, innerStart.y]);\n  }\n  sectorPathCommands.push(['L', start.x, start.y]);\n  sectorPathCommands.push(['Z']);\n  return sectorPathCommands;\n}\n/**\n * @ignore\n * Gets arc path\n * @param centerX\n * @param centerY\n * @param radius\n * @param startAngleInRadian\n * @param endAngleInRadian\n * @returns\n */\nexport function getArcPath(centerX, centerY, radius, startAngleInRadian, endAngleInRadian) {\n  var start = polarToCartesian(centerX, centerY, radius, startAngleInRadian);\n  var end = polarToCartesian(centerX, centerY, radius, endAngleInRadian);\n  if (isNumberEqual(endAngleInRadian - startAngleInRadian, Math.PI * 2)) {\n    var middlePoint = polarToCartesian(centerX, centerY, radius, startAngleInRadian + Math.PI);\n    return [['M', start.x, start.y], ['A', radius, radius, 0, 1, 1, middlePoint.x, middlePoint.y], ['A', radius, radius, 0, 1, 1, start.x, start.y], ['A', radius, radius, 0, 1, 0, middlePoint.x, middlePoint.y], ['A', radius, radius, 0, 1, 0, start.x, start.y], ['Z']];\n  }\n  var arcSweep = endAngleInRadian - startAngleInRadian <= Math.PI ? 0 : 1;\n  return [['M', start.x, start.y], ['A', radius, radius, 0, arcSweep, 1, end.x, end.y]];\n}\n/**\n * @ignore\n * 从数据模型中的 points 换算角度\n * @param shapeModel\n * @param coordinate\n * @returns\n */\nexport function getAngle(shapeModel, coordinate) {\n  var points = shapeModel.points;\n  var box = getPointsBox(points);\n  var endAngle;\n  var startAngle;\n  var coordStartAngle = coordinate.startAngle,\n    coordEndAngle = coordinate.endAngle;\n  var diffAngle = coordEndAngle - coordStartAngle;\n  if (coordinate.isTransposed) {\n    endAngle = box.maxY * diffAngle;\n    startAngle = box.minY * diffAngle;\n  } else {\n    endAngle = box.maxX * diffAngle;\n    startAngle = box.minX * diffAngle;\n  }\n  endAngle += coordStartAngle;\n  startAngle += coordStartAngle;\n  return {\n    startAngle: startAngle,\n    endAngle: endAngle\n  };\n}\n/**\n * @ignore\n * 计算多边形重心: https://en.wikipedia.org/wiki/Centroid#Of_a_polygon\n */\nexport function getPolygonCentroid(xs, ys) {\n  if (isNumber(xs) && isNumber(ys)) {\n    // 普通色块图，xs 和 ys 是数值\n    return [xs, ys];\n  }\n  xs = xs;\n  ys = ys;\n  // 当这个 polygon 的点在一条线上的时候\n  // 也就是说 xs 里面的值都相同，比如：[1, 1, 1, 1]\n  // 或者说 ys 里面的值都相同，比如：[0, 0, 0, 0]\n  // 下面计算得到的 k = 0\n  // 导致返回的值是 [NaN, NaN]\n  // 所以这里做相应的处理\n  if (uniqueValues(xs) || uniqueValues(ys)) return [mid(xs), mid(ys)];\n  var i = -1;\n  var x = 0;\n  var y = 0;\n  var former;\n  var current = xs.length - 1;\n  var diff;\n  var k = 0;\n  while (++i < xs.length) {\n    former = current;\n    current = i;\n    k += diff = xs[former] * ys[current] - xs[current] * ys[former];\n    x += (xs[former] + xs[current]) * diff;\n    y += (ys[former] + ys[current]) * diff;\n  }\n  k *= 3;\n  return [x / k, y / k];\n}\n/**\n * @ignore\n * 获取需要替换的属性，如果原先图形元素存在，而新图形不存在，则设置 undefined\n */\nexport function getReplaceAttrs(sourceShape, targetShape) {\n  var originAttrs = sourceShape.attr();\n  var newAttrs = targetShape.attr();\n  each(originAttrs, function (v, k) {\n    if (newAttrs[k] === undefined) {\n      newAttrs[k] = undefined;\n    }\n  });\n  return newAttrs;\n}","map":{"version":3,"names":["each","isEmpty","isNumber","isNumberEqual","max","min","getPointsBox","points","minX","x","maxX","minY","y","maxY","point","centerX","centerY","uniqueValues","array","Array","from","Set","length","mid","polarToCartesian","radius","angleInRadian","Math","cos","sin","getSectorPath","startAngleInRadian","endAngleInRadian","innerRadius","start","end","innerStart","innerEnd","PI","middlePoint","innerMiddlePoint","circlePathCommands","push","arcSweep","sectorPathCommands","getArcPath","getAngle","shapeModel","coordinate","box","endAngle","startAngle","coordStartAngle","coordEndAngle","diffAngle","isTransposed","getPolygonCentroid","xs","ys","i","former","current","diff","k","getReplaceAttrs","sourceShape","targetShape","originAttrs","attr","newAttrs","v","undefined"],"sources":["/Users/obiechina/Documents/ridy-flutter-full-taxi-solution 2/node_modules/@antv/g2/esm/util/graphics.js"],"sourcesContent":["import { each, isEmpty, isNumber, isNumberEqual, max, min } from '@antv/util';\n// 获取图形的包围盒\nfunction getPointsBox(points) {\n    if (isEmpty(points)) {\n        return null;\n    }\n    var minX = points[0].x;\n    var maxX = points[0].x;\n    var minY = points[0].y;\n    var maxY = points[0].y;\n    each(points, function (point) {\n        minX = minX > point.x ? point.x : minX;\n        maxX = maxX < point.x ? point.x : maxX;\n        minY = minY > point.y ? point.y : minY;\n        maxY = maxY < point.y ? point.y : maxY;\n    });\n    return {\n        minX: minX,\n        maxX: maxX,\n        minY: minY,\n        maxY: maxY,\n        centerX: (minX + maxX) / 2,\n        centerY: (minY + maxY) / 2,\n    };\n}\nfunction uniqueValues(array) {\n    return Array.from(new Set(array)).length === 1;\n}\nfunction mid(array) {\n    return (min(array) + max(array)) / 2;\n}\n/**\n * @ignore\n * 根据弧度计算极坐标系下的坐标点\n * @param centerX\n * @param centerY\n * @param radius\n * @param angleInRadian\n * @returns\n */\nexport function polarToCartesian(centerX, centerY, radius, angleInRadian) {\n    return {\n        x: centerX + radius * Math.cos(angleInRadian),\n        y: centerY + radius * Math.sin(angleInRadian),\n    };\n}\n/**\n * @ignore\n * 根据起始角度计算绘制扇形的 path\n * @param centerX\n * @param centerY\n * @param radius\n * @param startAngleInRadian\n * @param endAngleInRadian\n * @returns\n */\nexport function getSectorPath(centerX, centerY, radius, startAngleInRadian, endAngleInRadian, innerRadius) {\n    if (innerRadius === void 0) { innerRadius = 0; }\n    var start = polarToCartesian(centerX, centerY, radius, startAngleInRadian);\n    var end = polarToCartesian(centerX, centerY, radius, endAngleInRadian);\n    var innerStart = polarToCartesian(centerX, centerY, innerRadius, startAngleInRadian);\n    var innerEnd = polarToCartesian(centerX, centerY, innerRadius, endAngleInRadian);\n    if (endAngleInRadian - startAngleInRadian === Math.PI * 2) {\n        // 整个圆是分割成两个圆\n        var middlePoint = polarToCartesian(centerX, centerY, radius, startAngleInRadian + Math.PI);\n        var innerMiddlePoint = polarToCartesian(centerX, centerY, innerRadius, startAngleInRadian + Math.PI);\n        var circlePathCommands = [\n            ['M', start.x, start.y],\n            ['A', radius, radius, 0, 1, 1, middlePoint.x, middlePoint.y],\n            ['A', radius, radius, 0, 1, 1, end.x, end.y],\n            ['M', innerStart.x, innerStart.y],\n        ];\n        if (innerRadius) {\n            circlePathCommands.push(['A', innerRadius, innerRadius, 0, 1, 0, innerMiddlePoint.x, innerMiddlePoint.y]);\n            circlePathCommands.push(['A', innerRadius, innerRadius, 0, 1, 0, innerEnd.x, innerEnd.y]);\n        }\n        circlePathCommands.push(['M', start.x, start.y]);\n        circlePathCommands.push(['Z']);\n        return circlePathCommands;\n    }\n    var arcSweep = endAngleInRadian - startAngleInRadian <= Math.PI ? 0 : 1;\n    var sectorPathCommands = [\n        ['M', start.x, start.y],\n        ['A', radius, radius, 0, arcSweep, 1, end.x, end.y],\n        ['L', innerEnd.x, innerEnd.y],\n    ];\n    if (innerRadius) {\n        sectorPathCommands.push(['A', innerRadius, innerRadius, 0, arcSweep, 0, innerStart.x, innerStart.y]);\n    }\n    sectorPathCommands.push(['L', start.x, start.y]);\n    sectorPathCommands.push(['Z']);\n    return sectorPathCommands;\n}\n/**\n * @ignore\n * Gets arc path\n * @param centerX\n * @param centerY\n * @param radius\n * @param startAngleInRadian\n * @param endAngleInRadian\n * @returns\n */\nexport function getArcPath(centerX, centerY, radius, startAngleInRadian, endAngleInRadian) {\n    var start = polarToCartesian(centerX, centerY, radius, startAngleInRadian);\n    var end = polarToCartesian(centerX, centerY, radius, endAngleInRadian);\n    if (isNumberEqual(endAngleInRadian - startAngleInRadian, Math.PI * 2)) {\n        var middlePoint = polarToCartesian(centerX, centerY, radius, startAngleInRadian + Math.PI);\n        return [\n            ['M', start.x, start.y],\n            ['A', radius, radius, 0, 1, 1, middlePoint.x, middlePoint.y],\n            ['A', radius, radius, 0, 1, 1, start.x, start.y],\n            ['A', radius, radius, 0, 1, 0, middlePoint.x, middlePoint.y],\n            ['A', radius, radius, 0, 1, 0, start.x, start.y],\n            ['Z'],\n        ];\n    }\n    var arcSweep = endAngleInRadian - startAngleInRadian <= Math.PI ? 0 : 1;\n    return [\n        ['M', start.x, start.y],\n        ['A', radius, radius, 0, arcSweep, 1, end.x, end.y],\n    ];\n}\n/**\n * @ignore\n * 从数据模型中的 points 换算角度\n * @param shapeModel\n * @param coordinate\n * @returns\n */\nexport function getAngle(shapeModel, coordinate) {\n    var points = shapeModel.points;\n    var box = getPointsBox(points);\n    var endAngle;\n    var startAngle;\n    var coordStartAngle = coordinate.startAngle, coordEndAngle = coordinate.endAngle;\n    var diffAngle = coordEndAngle - coordStartAngle;\n    if (coordinate.isTransposed) {\n        endAngle = box.maxY * diffAngle;\n        startAngle = box.minY * diffAngle;\n    }\n    else {\n        endAngle = box.maxX * diffAngle;\n        startAngle = box.minX * diffAngle;\n    }\n    endAngle += coordStartAngle;\n    startAngle += coordStartAngle;\n    return {\n        startAngle: startAngle,\n        endAngle: endAngle,\n    };\n}\n/**\n * @ignore\n * 计算多边形重心: https://en.wikipedia.org/wiki/Centroid#Of_a_polygon\n */\nexport function getPolygonCentroid(xs, ys) {\n    if (isNumber(xs) && isNumber(ys)) {\n        // 普通色块图，xs 和 ys 是数值\n        return [xs, ys];\n    }\n    xs = xs;\n    ys = ys;\n    // 当这个 polygon 的点在一条线上的时候\n    // 也就是说 xs 里面的值都相同，比如：[1, 1, 1, 1]\n    // 或者说 ys 里面的值都相同，比如：[0, 0, 0, 0]\n    // 下面计算得到的 k = 0\n    // 导致返回的值是 [NaN, NaN]\n    // 所以这里做相应的处理\n    if (uniqueValues(xs) || uniqueValues(ys))\n        return [mid(xs), mid(ys)];\n    var i = -1;\n    var x = 0;\n    var y = 0;\n    var former;\n    var current = xs.length - 1;\n    var diff;\n    var k = 0;\n    while (++i < xs.length) {\n        former = current;\n        current = i;\n        k += diff = xs[former] * ys[current] - xs[current] * ys[former];\n        x += (xs[former] + xs[current]) * diff;\n        y += (ys[former] + ys[current]) * diff;\n    }\n    k *= 3;\n    return [x / k, y / k];\n}\n/**\n * @ignore\n * 获取需要替换的属性，如果原先图形元素存在，而新图形不存在，则设置 undefined\n */\nexport function getReplaceAttrs(sourceShape, targetShape) {\n    var originAttrs = sourceShape.attr();\n    var newAttrs = targetShape.attr();\n    each(originAttrs, function (v, k) {\n        if (newAttrs[k] === undefined) {\n            newAttrs[k] = undefined;\n        }\n    });\n    return newAttrs;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}