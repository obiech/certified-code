{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { AbstractGroup } from '@antv/g-base';\nimport * as Shape from './shape';\nimport { applyAttrsToContext, drawChildren, refreshElement } from './util/draw';\nimport { each, max, min } from '@antv/util';\nimport { intersectRect } from './util/util';\nvar Group = /** @class */function (_super) {\n  __extends(Group, _super);\n  function Group() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * 一些方法调用会引起画布变化\n   * @param {ChangeType} changeType 改变的类型\n   */\n  Group.prototype.onCanvasChange = function (changeType) {\n    refreshElement(this, changeType);\n  };\n  Group.prototype.getShapeBase = function () {\n    return Shape;\n  };\n  Group.prototype.getGroupBase = function () {\n    return Group;\n  };\n  // 同 shape 中的方法重复了\n  Group.prototype._applyClip = function (context, clip) {\n    if (clip) {\n      context.save();\n      // 将 clip 的属性挂载到 context 上\n      applyAttrsToContext(context, clip);\n      // 绘制 clip 路径\n      clip.createPath(context);\n      context.restore();\n      // 裁剪\n      context.clip();\n      clip._afterDraw();\n    }\n  };\n  // 这个方法以前直接使用的 getCanvasBBox，由于 group 上没有缓存，所以每次重新计算，导致性能开销比较大\n  // 大概能够节省全局渲染 15-20% 的性能，如果不在这里加缓存优化后 10W 个节点无法达到 5-6 ms，大概能够 30-40ms\n  Group.prototype.cacheCanvasBBox = function () {\n    var children = this.cfg.children;\n    var xArr = [];\n    var yArr = [];\n    each(children, function (child) {\n      var bbox = child.cfg.cacheCanvasBBox;\n      // isInview 的判定是一旦图形或者分组渲染就要计算是否在视图内，\n      // 这个判定 10W 个图形下差不多能够节省 5-6 ms 的开销\n      if (bbox && child.cfg.isInView) {\n        xArr.push(bbox.minX, bbox.maxX);\n        yArr.push(bbox.minY, bbox.maxY);\n      }\n    });\n    var bbox = null;\n    if (xArr.length) {\n      var minX = min(xArr);\n      var maxX = max(xArr);\n      var minY = min(yArr);\n      var maxY = max(yArr);\n      bbox = {\n        minX: minX,\n        minY: minY,\n        x: minX,\n        y: minY,\n        maxX: maxX,\n        maxY: maxY,\n        width: maxX - minX,\n        height: maxY - minY\n      };\n      var canvas = this.cfg.canvas;\n      if (canvas) {\n        var viewRange = canvas.getViewRange();\n        // 如果这个地方判定 isInView == false 设置 bbox 为 false 的话，拾取的性能会更高\n        // 但是目前 10W 图形的拾取在 2-5ms 内，这个优化意义不大，可以后期观察再看\n        this.set('isInView', intersectRect(bbox, viewRange));\n      }\n    } else {\n      this.set('isInView', false);\n    }\n    this.set('cacheCanvasBBox', bbox);\n  };\n  Group.prototype.draw = function (context, region) {\n    var children = this.cfg.children;\n    var allowDraw = region ? this.cfg.refresh : true; // 局部刷新需要判定\n    // 这个地方需要判定，在 G6 的场景每个 group 都有 transform 的场景下性能会开销非常大\n    // 通过 refresh 的判定，可以不刷新没有发生过变化的分组，不在视窗内的分组等等\n    // 如果想进一步提升局部渲染性能，可以进一步优化 refresh 的判定，依然有潜力\n    if (children.length && allowDraw) {\n      context.save();\n      // group 上的矩阵和属性也会应用到上下文上\n      // 先将 attrs 应用到上下文中，再设置 clip。因为 clip 应该被当前元素的 matrix 所影响\n      applyAttrsToContext(context, this);\n      this._applyClip(context, this.getClip());\n      drawChildren(context, children, region);\n      context.restore();\n      this.cacheCanvasBBox();\n    }\n    // 这里的成本比较大，如果不绘制则不再\n    // this.set('cacheCanvasBBox', this.getCanvasBBox());\n    this.cfg.refresh = null;\n    // 绘制后，消除更新标记\n    this.set('hasChanged', false);\n  };\n  // 绘制时被跳过，一般发生在分组隐藏时\n  Group.prototype.skipDraw = function () {\n    this.set('cacheCanvasBBox', null);\n    this.set('hasChanged', false);\n  };\n  return Group;\n}(AbstractGroup);\nexport default Group;","map":{"version":3,"names":["__extends","AbstractGroup","Shape","applyAttrsToContext","drawChildren","refreshElement","each","max","min","intersectRect","Group","_super","apply","arguments","prototype","onCanvasChange","changeType","getShapeBase","getGroupBase","_applyClip","context","clip","save","createPath","restore","_afterDraw","cacheCanvasBBox","children","cfg","xArr","yArr","child","bbox","isInView","push","minX","maxX","minY","maxY","length","x","y","width","height","canvas","viewRange","getViewRange","set","draw","region","allowDraw","refresh","getClip","skipDraw"],"sources":["/Users/obiechina/Documents/ridy-flutter-full-taxi-solution 2/node_modules/@antv/g-canvas/esm/group.js"],"sourcesContent":["import { __extends } from \"tslib\";\nimport { AbstractGroup } from '@antv/g-base';\nimport * as Shape from './shape';\nimport { applyAttrsToContext, drawChildren, refreshElement } from './util/draw';\nimport { each, max, min } from '@antv/util';\nimport { intersectRect } from './util/util';\nvar Group = /** @class */ (function (_super) {\n    __extends(Group, _super);\n    function Group() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * 一些方法调用会引起画布变化\n     * @param {ChangeType} changeType 改变的类型\n     */\n    Group.prototype.onCanvasChange = function (changeType) {\n        refreshElement(this, changeType);\n    };\n    Group.prototype.getShapeBase = function () {\n        return Shape;\n    };\n    Group.prototype.getGroupBase = function () {\n        return Group;\n    };\n    // 同 shape 中的方法重复了\n    Group.prototype._applyClip = function (context, clip) {\n        if (clip) {\n            context.save();\n            // 将 clip 的属性挂载到 context 上\n            applyAttrsToContext(context, clip);\n            // 绘制 clip 路径\n            clip.createPath(context);\n            context.restore();\n            // 裁剪\n            context.clip();\n            clip._afterDraw();\n        }\n    };\n    // 这个方法以前直接使用的 getCanvasBBox，由于 group 上没有缓存，所以每次重新计算，导致性能开销比较大\n    // 大概能够节省全局渲染 15-20% 的性能，如果不在这里加缓存优化后 10W 个节点无法达到 5-6 ms，大概能够 30-40ms\n    Group.prototype.cacheCanvasBBox = function () {\n        var children = this.cfg.children;\n        var xArr = [];\n        var yArr = [];\n        each(children, function (child) {\n            var bbox = child.cfg.cacheCanvasBBox;\n            // isInview 的判定是一旦图形或者分组渲染就要计算是否在视图内，\n            // 这个判定 10W 个图形下差不多能够节省 5-6 ms 的开销\n            if (bbox && child.cfg.isInView) {\n                xArr.push(bbox.minX, bbox.maxX);\n                yArr.push(bbox.minY, bbox.maxY);\n            }\n        });\n        var bbox = null;\n        if (xArr.length) {\n            var minX = min(xArr);\n            var maxX = max(xArr);\n            var minY = min(yArr);\n            var maxY = max(yArr);\n            bbox = {\n                minX: minX,\n                minY: minY,\n                x: minX,\n                y: minY,\n                maxX: maxX,\n                maxY: maxY,\n                width: maxX - minX,\n                height: maxY - minY,\n            };\n            var canvas = this.cfg.canvas;\n            if (canvas) {\n                var viewRange = canvas.getViewRange();\n                // 如果这个地方判定 isInView == false 设置 bbox 为 false 的话，拾取的性能会更高\n                // 但是目前 10W 图形的拾取在 2-5ms 内，这个优化意义不大，可以后期观察再看\n                this.set('isInView', intersectRect(bbox, viewRange));\n            }\n        }\n        else {\n            this.set('isInView', false);\n        }\n        this.set('cacheCanvasBBox', bbox);\n    };\n    Group.prototype.draw = function (context, region) {\n        var children = this.cfg.children;\n        var allowDraw = region ? this.cfg.refresh : true; // 局部刷新需要判定\n        // 这个地方需要判定，在 G6 的场景每个 group 都有 transform 的场景下性能会开销非常大\n        // 通过 refresh 的判定，可以不刷新没有发生过变化的分组，不在视窗内的分组等等\n        // 如果想进一步提升局部渲染性能，可以进一步优化 refresh 的判定，依然有潜力\n        if (children.length && allowDraw) {\n            context.save();\n            // group 上的矩阵和属性也会应用到上下文上\n            // 先将 attrs 应用到上下文中，再设置 clip。因为 clip 应该被当前元素的 matrix 所影响\n            applyAttrsToContext(context, this);\n            this._applyClip(context, this.getClip());\n            drawChildren(context, children, region);\n            context.restore();\n            this.cacheCanvasBBox();\n        }\n        // 这里的成本比较大，如果不绘制则不再\n        // this.set('cacheCanvasBBox', this.getCanvasBBox());\n        this.cfg.refresh = null;\n        // 绘制后，消除更新标记\n        this.set('hasChanged', false);\n    };\n    // 绘制时被跳过，一般发生在分组隐藏时\n    Group.prototype.skipDraw = function () {\n        this.set('cacheCanvasBBox', null);\n        this.set('hasChanged', false);\n    };\n    return Group;\n}(AbstractGroup));\nexport default Group;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}