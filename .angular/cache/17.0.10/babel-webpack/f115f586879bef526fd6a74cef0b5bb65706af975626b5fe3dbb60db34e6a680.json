{"ast":null,"code":"/**\n * @fileoverview 文本\n * @author dxq613@gmail.com\n */\nimport { __assign, __extends } from \"tslib\";\nimport ShapeBase from './base';\nimport { isNil, isString, each } from '../util/util';\nimport { getTextHeight, assembleFont } from '@antv/g-base';\nvar Text = /** @class */function (_super) {\n  __extends(Text, _super);\n  function Text() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  // 默认文本属性\n  Text.prototype.getDefaultAttrs = function () {\n    var attrs = _super.prototype.getDefaultAttrs.call(this);\n    return __assign(__assign({}, attrs), {\n      x: 0,\n      y: 0,\n      text: null,\n      fontSize: 12,\n      fontFamily: 'sans-serif',\n      fontStyle: 'normal',\n      fontWeight: 'normal',\n      fontVariant: 'normal',\n      textAlign: 'start',\n      textBaseline: 'bottom'\n    });\n  };\n  // 仅仅使用包围盒检测来进行拾取\n  Text.prototype.isOnlyHitBox = function () {\n    return true;\n  };\n  // 初始化时组合 font，同时判断 text 是否换行\n  Text.prototype.initAttrs = function (attrs) {\n    this._assembleFont();\n    if (attrs.text) {\n      this._setText(attrs.text);\n    }\n  };\n  // 组装字体\n  Text.prototype._assembleFont = function () {\n    var attrs = this.attrs;\n    attrs.font = assembleFont(attrs);\n  };\n  // 如果文本换行，则缓存数组\n  Text.prototype._setText = function (text) {\n    var textArr = null;\n    if (isString(text) && text.indexOf('\\n') !== -1) {\n      textArr = text.split('\\n');\n    }\n    this.set('textArr', textArr);\n  };\n  // 更新属性时，检测是否更改了 font、text\n  Text.prototype.onAttrChange = function (name, value, originValue) {\n    _super.prototype.onAttrChange.call(this, name, value, originValue);\n    if (name.startsWith('font')) {\n      this._assembleFont();\n    }\n    if (name === 'text') {\n      this._setText(value);\n    }\n  };\n  // 这个方法在 text 时没有可以做的事情，如果要支持文字背景时可以考虑\n  // createPath(context) {\n  // }\n  // 如果文本多行，需要获取文本间距\n  Text.prototype._getSpaceingY = function () {\n    var attrs = this.attrs;\n    var lineHeight = attrs.lineHeight;\n    var fontSize = attrs.fontSize * 1;\n    return lineHeight ? lineHeight - fontSize : fontSize * 0.14;\n  };\n  // 绘制文本，考虑多行的场景\n  Text.prototype._drawTextArr = function (context, textArr, isFill) {\n    var attrs = this.attrs;\n    var textBaseline = attrs.textBaseline;\n    var x = attrs.x;\n    var y = attrs.y;\n    var fontSize = attrs.fontSize * 1;\n    var spaceingY = this._getSpaceingY();\n    var height = getTextHeight(attrs.text, attrs.fontSize, attrs.lineHeight);\n    var subY;\n    each(textArr, function (subText, index) {\n      subY = y + index * (spaceingY + fontSize) - height + fontSize; // bottom;\n      if (textBaseline === 'middle') subY += height - fontSize - (height - fontSize) / 2;\n      if (textBaseline === 'top') subY += height - fontSize;\n      if (!isNil(subText)) {\n        if (isFill) {\n          context.fillText(subText, x, subY);\n        } else {\n          context.strokeText(subText, x, subY);\n        }\n      }\n    });\n  };\n  // 绘制文本，同时考虑填充和绘制边框\n  Text.prototype._drawText = function (context, isFill) {\n    var attrs = this.attr();\n    var x = attrs.x;\n    var y = attrs.y;\n    var textArr = this.get('textArr');\n    if (textArr) {\n      this._drawTextArr(context, textArr, isFill);\n    } else {\n      var text = attrs.text;\n      if (!isNil(text)) {\n        if (isFill) {\n          context.fillText(text, x, y);\n        } else {\n          context.strokeText(text, x, y);\n        }\n      }\n    }\n  };\n  // 复写绘制和填充的逻辑：对于文本，应该先绘制边框，再进行填充\n  Text.prototype.strokeAndFill = function (context) {\n    var _a = this.attrs,\n      lineWidth = _a.lineWidth,\n      opacity = _a.opacity,\n      strokeOpacity = _a.strokeOpacity,\n      fillOpacity = _a.fillOpacity;\n    if (this.isStroke()) {\n      if (lineWidth > 0) {\n        if (!isNil(strokeOpacity) && strokeOpacity !== 1) {\n          context.globalAlpha = opacity;\n        }\n        this.stroke(context);\n      }\n    }\n    if (this.isFill()) {\n      if (!isNil(fillOpacity) && fillOpacity !== 1) {\n        context.globalAlpha = fillOpacity;\n        this.fill(context);\n        context.globalAlpha = opacity;\n      } else {\n        this.fill(context);\n      }\n    }\n    this.afterDrawPath(context);\n  };\n  // 复写填充逻辑\n  Text.prototype.fill = function (context) {\n    this._drawText(context, true);\n  };\n  // 复写绘制边框的逻辑\n  Text.prototype.stroke = function (context) {\n    this._drawText(context, false);\n  };\n  return Text;\n}(ShapeBase);\nexport default Text;","map":{"version":3,"names":["__assign","__extends","ShapeBase","isNil","isString","each","getTextHeight","assembleFont","Text","_super","apply","arguments","prototype","getDefaultAttrs","attrs","call","x","y","text","fontSize","fontFamily","fontStyle","fontWeight","fontVariant","textAlign","textBaseline","isOnlyHitBox","initAttrs","_assembleFont","_setText","font","textArr","indexOf","split","set","onAttrChange","name","value","originValue","startsWith","_getSpaceingY","lineHeight","_drawTextArr","context","isFill","spaceingY","height","subY","subText","index","fillText","strokeText","_drawText","attr","get","strokeAndFill","_a","lineWidth","opacity","strokeOpacity","fillOpacity","isStroke","globalAlpha","stroke","fill","afterDrawPath"],"sources":["/Users/obiechina/Documents/ridy-flutter-full-taxi-solution 2/node_modules/@antv/g-canvas/esm/shape/text.js"],"sourcesContent":["/**\n * @fileoverview 文本\n * @author dxq613@gmail.com\n */\nimport { __assign, __extends } from \"tslib\";\nimport ShapeBase from './base';\nimport { isNil, isString, each } from '../util/util';\nimport { getTextHeight, assembleFont } from '@antv/g-base';\nvar Text = /** @class */ (function (_super) {\n    __extends(Text, _super);\n    function Text() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    // 默认文本属性\n    Text.prototype.getDefaultAttrs = function () {\n        var attrs = _super.prototype.getDefaultAttrs.call(this);\n        return __assign(__assign({}, attrs), { x: 0, y: 0, text: null, fontSize: 12, fontFamily: 'sans-serif', fontStyle: 'normal', fontWeight: 'normal', fontVariant: 'normal', textAlign: 'start', textBaseline: 'bottom' });\n    };\n    // 仅仅使用包围盒检测来进行拾取\n    Text.prototype.isOnlyHitBox = function () {\n        return true;\n    };\n    // 初始化时组合 font，同时判断 text 是否换行\n    Text.prototype.initAttrs = function (attrs) {\n        this._assembleFont();\n        if (attrs.text) {\n            this._setText(attrs.text);\n        }\n    };\n    // 组装字体\n    Text.prototype._assembleFont = function () {\n        var attrs = this.attrs;\n        attrs.font = assembleFont(attrs);\n    };\n    // 如果文本换行，则缓存数组\n    Text.prototype._setText = function (text) {\n        var textArr = null;\n        if (isString(text) && text.indexOf('\\n') !== -1) {\n            textArr = text.split('\\n');\n        }\n        this.set('textArr', textArr);\n    };\n    // 更新属性时，检测是否更改了 font、text\n    Text.prototype.onAttrChange = function (name, value, originValue) {\n        _super.prototype.onAttrChange.call(this, name, value, originValue);\n        if (name.startsWith('font')) {\n            this._assembleFont();\n        }\n        if (name === 'text') {\n            this._setText(value);\n        }\n    };\n    // 这个方法在 text 时没有可以做的事情，如果要支持文字背景时可以考虑\n    // createPath(context) {\n    // }\n    // 如果文本多行，需要获取文本间距\n    Text.prototype._getSpaceingY = function () {\n        var attrs = this.attrs;\n        var lineHeight = attrs.lineHeight;\n        var fontSize = attrs.fontSize * 1;\n        return lineHeight ? lineHeight - fontSize : fontSize * 0.14;\n    };\n    // 绘制文本，考虑多行的场景\n    Text.prototype._drawTextArr = function (context, textArr, isFill) {\n        var attrs = this.attrs;\n        var textBaseline = attrs.textBaseline;\n        var x = attrs.x;\n        var y = attrs.y;\n        var fontSize = attrs.fontSize * 1;\n        var spaceingY = this._getSpaceingY();\n        var height = getTextHeight(attrs.text, attrs.fontSize, attrs.lineHeight);\n        var subY;\n        each(textArr, function (subText, index) {\n            subY = y + index * (spaceingY + fontSize) - height + fontSize; // bottom;\n            if (textBaseline === 'middle')\n                subY += height - fontSize - (height - fontSize) / 2;\n            if (textBaseline === 'top')\n                subY += height - fontSize;\n            if (!isNil(subText)) {\n                if (isFill) {\n                    context.fillText(subText, x, subY);\n                }\n                else {\n                    context.strokeText(subText, x, subY);\n                }\n            }\n        });\n    };\n    // 绘制文本，同时考虑填充和绘制边框\n    Text.prototype._drawText = function (context, isFill) {\n        var attrs = this.attr();\n        var x = attrs.x;\n        var y = attrs.y;\n        var textArr = this.get('textArr');\n        if (textArr) {\n            this._drawTextArr(context, textArr, isFill);\n        }\n        else {\n            var text = attrs.text;\n            if (!isNil(text)) {\n                if (isFill) {\n                    context.fillText(text, x, y);\n                }\n                else {\n                    context.strokeText(text, x, y);\n                }\n            }\n        }\n    };\n    // 复写绘制和填充的逻辑：对于文本，应该先绘制边框，再进行填充\n    Text.prototype.strokeAndFill = function (context) {\n        var _a = this.attrs, lineWidth = _a.lineWidth, opacity = _a.opacity, strokeOpacity = _a.strokeOpacity, fillOpacity = _a.fillOpacity;\n        if (this.isStroke()) {\n            if (lineWidth > 0) {\n                if (!isNil(strokeOpacity) && strokeOpacity !== 1) {\n                    context.globalAlpha = opacity;\n                }\n                this.stroke(context);\n            }\n        }\n        if (this.isFill()) {\n            if (!isNil(fillOpacity) && fillOpacity !== 1) {\n                context.globalAlpha = fillOpacity;\n                this.fill(context);\n                context.globalAlpha = opacity;\n            }\n            else {\n                this.fill(context);\n            }\n        }\n        this.afterDrawPath(context);\n    };\n    // 复写填充逻辑\n    Text.prototype.fill = function (context) {\n        this._drawText(context, true);\n    };\n    // 复写绘制边框的逻辑\n    Text.prototype.stroke = function (context) {\n        this._drawText(context, false);\n    };\n    return Text;\n}(ShapeBase));\nexport default Text;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}