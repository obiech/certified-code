{"ast":null,"code":"/**\n * @fileoverview 椭圆的一些计算，\n *  - 周长计算参考：https://www.mathsisfun.com/geometry/ellipse-perimeter.html\n *  - 距离计算参考：https://wet-robots.ghost.io/simple-method-for-distance-to-ellipse/\n * @author dxq613@gmail.com\n */\nimport { distance, piMod } from './util';\nfunction copysign(v1, v2) {\n  var absv = Math.abs(v1);\n  return v2 > 0 ? absv : absv * -1;\n}\nexport default {\n  /**\n   * 包围盒计算\n   * @param {number} x  椭圆中心 x\n   * @param {number} y  椭圆中心 y\n   * @param {number} rx 椭圆 x 方向半径\n   * @param {number} ry 椭圆 y 方向半径\n   * @return {object} 包围盒\n   */\n  box: function (x, y, rx, ry) {\n    return {\n      x: x - rx,\n      y: y - ry,\n      width: rx * 2,\n      height: ry * 2\n    };\n  },\n  /**\n   * 计算周长，使用近似法\n   * @param {number} x  椭圆中心 x\n   * @param {number} y  椭圆中心 y\n   * @param {number} rx 椭圆 x 方向半径\n   * @param {number} ry 椭圆 y 方向半径\n   * @return {number} 椭圆周长\n   */\n  length: function (x, y, rx, ry) {\n    return Math.PI * (3 * (rx + ry) - Math.sqrt((3 * rx + ry) * (rx + 3 * ry)));\n  },\n  /**\n   * 距离椭圆最近的点\n   * @param {number} x  椭圆中心 x\n   * @param {number} y  椭圆中心 y\n   * @param {number} rx 椭圆 x 方向半径\n   * @param {number} ry 椭圆 y 方向半径\n   * @param {number} x0  指定的点 x\n   * @param {number} y0  指定的点 y\n   * @return {object} 椭圆上距离指定点最近的点\n   */\n  nearestPoint: function (x, y, rx, ry, x0, y0) {\n    var a = rx;\n    var b = ry;\n    // 假如椭圆半径为0则返回圆心\n    if (a === 0 || b === 0) {\n      return {\n        x: x,\n        y: y\n      };\n    }\n    // 转换成 0， 0 为中心的椭圆计算\n    var relativeX = x0 - x;\n    var relativeY = y0 - y;\n    var px = Math.abs(relativeX);\n    var py = Math.abs(relativeY);\n    var squareA = a * a;\n    var squareB = b * b;\n    // const angle0 = Math.atan2(relativeY, relativeX);\n    var t = Math.PI / 4;\n    var nearestX; // 椭圆上的任一点\n    var nearestY;\n    // 迭代 4 次\n    for (var i = 0; i < 4; i++) {\n      nearestX = a * Math.cos(t);\n      nearestY = b * Math.sin(t);\n      var ex = (squareA - squareB) * Math.pow(Math.cos(t), 3) / a;\n      var ey = (squareB - squareA) * Math.pow(Math.sin(t), 3) / b;\n      var rx1 = nearestX - ex;\n      var ry1 = nearestY - ey;\n      var qx = px - ex;\n      var qy = py - ey;\n      var r = Math.hypot(ry1, rx1);\n      var q = Math.hypot(qy, qx);\n      var delta_c = r * Math.asin((rx1 * qy - ry1 * qx) / (r * q));\n      var delta_t = delta_c / Math.sqrt(squareA + squareB - nearestX * nearestX - nearestY * nearestY);\n      t += delta_t;\n      t = Math.min(Math.PI / 2, Math.max(0, t));\n    }\n    return {\n      x: x + copysign(nearestX, relativeX),\n      y: y + copysign(nearestY, relativeY)\n    };\n  },\n  /**\n   * 点到椭圆最近的距离\n   * @param {number} x  椭圆中心 x\n   * @param {number} y  椭圆中心 y\n   * @param {number} rx 椭圆 x 方向半径\n   * @param {number} ry 椭圆 y 方向半径\n   * @param {number} x0  指定的点 x\n   * @param {number} y0  指定的点 y\n   * @return {number} 点到椭圆的距离\n   */\n  pointDistance: function (x, y, rx, ry, x0, y0) {\n    var nearestPoint = this.nearestPoint(x, y, rx, ry, x0, y0);\n    return distance(nearestPoint.x, nearestPoint.y, x0, y0);\n  },\n  /**\n   * 根据比例获取点\n   * @param {number} x 椭圆中心 x\n   * @param {number} y 椭圆中心 y\n   * @param {number} rx 椭圆 x 方向半径\n   * @param {number} ry 椭圆 y 方向半径\n   * @param {number} t 指定比例，x轴方向为 0\n   * @return {object} 点\n   */\n  pointAt: function (x, y, rx, ry, t) {\n    var angle = 2 * Math.PI * t; // 按照角度进行计算，而不按照周长计算\n    return {\n      x: x + rx * Math.cos(angle),\n      y: y + ry * Math.sin(angle)\n    };\n  },\n  /**\n   * 根据比例计算切线角度\n   * @param {number} x 椭圆中心 x\n   * @param {number} y 椭圆中心 y\n   * @param {number} rx 椭圆 x 方向半径\n   * @param {number} ry 椭圆 y 方向半径\n   * @param {number} t 指定比例 0 - 1 之间，x轴方向为 0。在 0-1 范围之外是循环还是返回 null，还需要调整\n   * @return {number} 角度，在 0 - 2PI 之间\n   */\n  tangentAngle: function (x, y, rx, ry, t) {\n    var angle = 2 * Math.PI * t; // 按照角度进行计算，而不按照周长计算\n    // 直接使用 x,y 的导数计算， x' = -rx * sin(t); y' = ry * cos(t);\n    var tangentAngle = Math.atan2(ry * Math.cos(angle), -rx * Math.sin(angle));\n    // 也可以使用指定点的切线方程计算，成本有些高\n    // const point = this.pointAt(0, 0, rx, ry, t); // 椭圆的切线同椭圆的中心不相关\n    // let tangentAngle = -1 * Math.atan((ry * ry * point.x) / (rx * rx * point.y));\n    // if (angle >= 0 && angle <= Math.PI) {\n    //   tangentAngle += Math.PI;\n    // }\n    return piMod(tangentAngle);\n  }\n};","map":{"version":3,"names":["distance","piMod","copysign","v1","v2","absv","Math","abs","box","x","y","rx","ry","width","height","length","PI","sqrt","nearestPoint","x0","y0","a","b","relativeX","relativeY","px","py","squareA","squareB","t","nearestX","nearestY","i","cos","sin","ex","pow","ey","rx1","ry1","qx","qy","r","hypot","q","delta_c","asin","delta_t","min","max","pointDistance","pointAt","angle","tangentAngle","atan2"],"sources":["/Users/obiechina/Documents/ridy-flutter-full-taxi-solution 2/node_modules/@antv/g-math/esm/ellipse.js"],"sourcesContent":["/**\n * @fileoverview 椭圆的一些计算，\n *  - 周长计算参考：https://www.mathsisfun.com/geometry/ellipse-perimeter.html\n *  - 距离计算参考：https://wet-robots.ghost.io/simple-method-for-distance-to-ellipse/\n * @author dxq613@gmail.com\n */\nimport { distance, piMod } from './util';\nfunction copysign(v1, v2) {\n    var absv = Math.abs(v1);\n    return v2 > 0 ? absv : absv * -1;\n}\nexport default {\n    /**\n     * 包围盒计算\n     * @param {number} x  椭圆中心 x\n     * @param {number} y  椭圆中心 y\n     * @param {number} rx 椭圆 x 方向半径\n     * @param {number} ry 椭圆 y 方向半径\n     * @return {object} 包围盒\n     */\n    box: function (x, y, rx, ry) {\n        return {\n            x: x - rx,\n            y: y - ry,\n            width: rx * 2,\n            height: ry * 2,\n        };\n    },\n    /**\n     * 计算周长，使用近似法\n     * @param {number} x  椭圆中心 x\n     * @param {number} y  椭圆中心 y\n     * @param {number} rx 椭圆 x 方向半径\n     * @param {number} ry 椭圆 y 方向半径\n     * @return {number} 椭圆周长\n     */\n    length: function (x, y, rx, ry) {\n        return Math.PI * (3 * (rx + ry) - Math.sqrt((3 * rx + ry) * (rx + 3 * ry)));\n    },\n    /**\n     * 距离椭圆最近的点\n     * @param {number} x  椭圆中心 x\n     * @param {number} y  椭圆中心 y\n     * @param {number} rx 椭圆 x 方向半径\n     * @param {number} ry 椭圆 y 方向半径\n     * @param {number} x0  指定的点 x\n     * @param {number} y0  指定的点 y\n     * @return {object} 椭圆上距离指定点最近的点\n     */\n    nearestPoint: function (x, y, rx, ry, x0, y0) {\n        var a = rx;\n        var b = ry;\n        // 假如椭圆半径为0则返回圆心\n        if (a === 0 || b === 0) {\n            return {\n                x: x,\n                y: y,\n            };\n        }\n        // 转换成 0， 0 为中心的椭圆计算\n        var relativeX = x0 - x;\n        var relativeY = y0 - y;\n        var px = Math.abs(relativeX);\n        var py = Math.abs(relativeY);\n        var squareA = a * a;\n        var squareB = b * b;\n        // const angle0 = Math.atan2(relativeY, relativeX);\n        var t = Math.PI / 4;\n        var nearestX; // 椭圆上的任一点\n        var nearestY;\n        // 迭代 4 次\n        for (var i = 0; i < 4; i++) {\n            nearestX = a * Math.cos(t);\n            nearestY = b * Math.sin(t);\n            var ex = ((squareA - squareB) * Math.pow(Math.cos(t), 3)) / a;\n            var ey = ((squareB - squareA) * Math.pow(Math.sin(t), 3)) / b;\n            var rx1 = nearestX - ex;\n            var ry1 = nearestY - ey;\n            var qx = px - ex;\n            var qy = py - ey;\n            var r = Math.hypot(ry1, rx1);\n            var q = Math.hypot(qy, qx);\n            var delta_c = r * Math.asin((rx1 * qy - ry1 * qx) / (r * q));\n            var delta_t = delta_c / Math.sqrt(squareA + squareB - nearestX * nearestX - nearestY * nearestY);\n            t += delta_t;\n            t = Math.min(Math.PI / 2, Math.max(0, t));\n        }\n        return {\n            x: x + copysign(nearestX, relativeX),\n            y: y + copysign(nearestY, relativeY),\n        };\n    },\n    /**\n     * 点到椭圆最近的距离\n     * @param {number} x  椭圆中心 x\n     * @param {number} y  椭圆中心 y\n     * @param {number} rx 椭圆 x 方向半径\n     * @param {number} ry 椭圆 y 方向半径\n     * @param {number} x0  指定的点 x\n     * @param {number} y0  指定的点 y\n     * @return {number} 点到椭圆的距离\n     */\n    pointDistance: function (x, y, rx, ry, x0, y0) {\n        var nearestPoint = this.nearestPoint(x, y, rx, ry, x0, y0);\n        return distance(nearestPoint.x, nearestPoint.y, x0, y0);\n    },\n    /**\n     * 根据比例获取点\n     * @param {number} x 椭圆中心 x\n     * @param {number} y 椭圆中心 y\n     * @param {number} rx 椭圆 x 方向半径\n     * @param {number} ry 椭圆 y 方向半径\n     * @param {number} t 指定比例，x轴方向为 0\n     * @return {object} 点\n     */\n    pointAt: function (x, y, rx, ry, t) {\n        var angle = 2 * Math.PI * t; // 按照角度进行计算，而不按照周长计算\n        return {\n            x: x + rx * Math.cos(angle),\n            y: y + ry * Math.sin(angle),\n        };\n    },\n    /**\n     * 根据比例计算切线角度\n     * @param {number} x 椭圆中心 x\n     * @param {number} y 椭圆中心 y\n     * @param {number} rx 椭圆 x 方向半径\n     * @param {number} ry 椭圆 y 方向半径\n     * @param {number} t 指定比例 0 - 1 之间，x轴方向为 0。在 0-1 范围之外是循环还是返回 null，还需要调整\n     * @return {number} 角度，在 0 - 2PI 之间\n     */\n    tangentAngle: function (x, y, rx, ry, t) {\n        var angle = 2 * Math.PI * t; // 按照角度进行计算，而不按照周长计算\n        // 直接使用 x,y 的导数计算， x' = -rx * sin(t); y' = ry * cos(t);\n        var tangentAngle = Math.atan2(ry * Math.cos(angle), -rx * Math.sin(angle));\n        // 也可以使用指定点的切线方程计算，成本有些高\n        // const point = this.pointAt(0, 0, rx, ry, t); // 椭圆的切线同椭圆的中心不相关\n        // let tangentAngle = -1 * Math.atan((ry * ry * point.x) / (rx * rx * point.y));\n        // if (angle >= 0 && angle <= Math.PI) {\n        //   tangentAngle += Math.PI;\n        // }\n        return piMod(tangentAngle);\n    },\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}